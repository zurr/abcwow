Index: AIInterface.cpp
===================================================================
--- AIInterface.cpp	(revision 187)
+++ AIInterface.cpp	(working copy)
@@ -141,6 +141,10 @@
 	for(list<AI_Spell*>::iterator itr = m_spells.begin(); itr != m_spells.end(); ++itr)
 		if((*itr)->custom_pointer)
 			delete (*itr);
+#ifdef COLLISION_CRAP
+	for(list<LocationVector*>::iterator itr = AttackWaypoints.begin(); itr != AttackWaypoints.end(); ++itr)
+		delete (*itr);
+#endif
 }
 
 void AIInterface::Init(Unit *un, AIType at, MovementType mt, Unit *owner)
@@ -873,11 +877,11 @@
 				float combatReach[2]; // Calculate Combat Reach
 				float distance = m_Unit->CalcDistance(m_nextTarget);
 
-				combatReach[0] = 0.0f;
+				combatReach[0] = PLAYER_SIZE;
 				combatReach[1] = _CalcCombatRange(m_nextTarget, false);
 
 				if(	
-//					distance >= combatReach[0] && 
+					distance >= combatReach[0] && 
 					distance <= combatReach[1] + DISTANCE_TO_SMALL_TO_WALK) // Target is in Range -> Attack
 				{
 					if(UnitToFollow != NULL)
@@ -942,6 +946,8 @@
 
 					if(dist < PLAYER_SIZE)
 						dist = PLAYER_SIZE; //unbelievable how this could happen
+					if (distance<combatReach[0])
+						dist = -(distance+combatReach[0]*0.6666f);
 
 					m_moveRun = true;
 					_CalcDestinationAndMove(m_nextTarget, dist);
@@ -1026,7 +1032,11 @@
 					StopMovement(0);
 
 				float distance = m_Unit->GetDistanceSq(m_nextTarget);
-				if((distance <= (m_nextSpell->maxrange*m_nextSpell->maxrange)  && distance >= (m_nextSpell->minrange*m_nextSpell->minrange)) || m_nextSpell->maxrange == 0) // Target is in Range -> Attack
+				bool los = true;
+#ifdef COLLISION
+				los = CollideInterface.CheckLOS(m_Unit->GetMapId(), m_Unit->GetPositionNC(),m_nextTarget->GetPositionNC());
+#endif
+				if(los && ((distance <= (m_nextSpell->maxrange*m_nextSpell->maxrange)  && distance >= (m_nextSpell->minrange*m_nextSpell->minrange)) || m_nextSpell->maxrange == 0)) // Target is in Range -> Attack
 				{
 					SpellEntry* spellInfo = m_nextSpell->spell;
 /*					if(m_nextSpell->procCount)
@@ -1173,24 +1183,24 @@
 
 void AIInterface::AttackReaction(Unit* pUnit, uint32 damage_dealt, uint32 spellId)
 {
-	if(m_AIState == STATE_EVADE || m_fleeTimer != 0 || !pUnit || !pUnit->isAlive()
-		|| m_Unit->IsPacified() || m_Unit->IsStunned() || !m_Unit->isAlive())
+	if( m_AIState == STATE_EVADE || m_fleeTimer != 0 || !pUnit || !pUnit->isAlive() || m_Unit->IsPacified() || m_Unit->IsStunned() || !m_Unit->isAlive() )
 	{
 		return;
 	}
-	if(m_Unit == pUnit)
+
+	if( m_Unit == pUnit )
 	{
 		return;
 	}
 
-	if(m_AIState == STATE_IDLE || m_AIState == STATE_FOLLOWING)
+	if( m_AIState == STATE_IDLE || m_AIState == STATE_FOLLOWING )
 	{
 		WipeTargetList();
 		
 		HandleEvent(EVENT_ENTERCOMBAT, pUnit, 0);
 	}
 
-	HandleEvent(EVENT_DAMAGETAKEN, pUnit, _CalcThreat(damage_dealt, spellId, pUnit));
+	HandleEvent(EVENT_DAMAGETAKEN, pUnit, _CalcThreat(damage_dealt, spellId ? dbcSpell.LookupEntryForced(spellId) : NULL, pUnit));
 }
 
 bool AIInterface::HealReaction(Unit* caster, Unit* victim, uint32 amount)
@@ -1395,7 +1405,7 @@
 
 	#endif		// LOS_ONLY_IN_INSTANCE
 
-            if( CollideInterface.CheckLOSMod( m_Unit->GetMapId( ), m_Unit->GetPositionV( ), pUnit->GetPositionV( ) ) )
+            if( CollideInterface.CheckLOS( m_Unit->GetMapId( ), m_Unit->GetPositionNC( ), pUnit->GetPositionNC( ) ) )
 			{
 				distance = dist;
 				target = pUnit;
@@ -1573,7 +1583,7 @@
 		if( z == NO_WMO_HEIGHT )
 			z = m_Unit->GetMapMgr()->GetLandHeight(x, y);
 
-		if( abs( z - m_Unit->GetPositionZ() ) > 10.0f )
+		if( fabs( z - m_Unit->GetPositionZ() ) > 10.0f )
 			z = m_Unit->GetPositionZ();
 #else
 		float z = m_Unit->GetPositionZ();
@@ -1586,13 +1596,19 @@
 		if(!cp) return result;
 
 		uint32 languageid = (team == 0) ? LANG_COMMON : LANG_ORCISH;
-		m_Unit->SendChatMessage(CHAT_MSG_MONSTER_SAY, languageid, "Guards, help me!");
+		m_Unit->SendChatMessage(CHAT_MSG_MONSTER_SAY, languageid, "Guards!");
 
-		for(size_t i = 1; i <= m_Unit->GetInRangeOppFactCount(); i++)
+		uint8 spawned = 0;
+	
+		std::set<Player*>::iterator hostileItr = m_Unit->GetInRangePlayerSetBegin();
+		for(; hostileItr != m_Unit->GetInRangePlayerSetEnd(); hostileItr++)
 		{
-			if(i >= 3)
+			if(spawned >= 3)
 				break;
 
+			if(!isHostile(*hostileItr, m_Unit))
+				continue;
+
 			Creature * guard = m_Unit->GetMapMgr()->CreateCreature();
 			guard->Load(cp, x, y, z);
 			guard->SetInstanceID(m_Unit->GetInstanceID());
@@ -1616,7 +1632,7 @@
 			
 			sEventMgr.AddEvent(guard, &Creature::SetGuardWaypoints, EVENT_UNK, 10000, 1,0);
 			sEventMgr.AddEvent(guard, &Creature::SafeDelete, EVENT_CREATURE_SAFE_DELETE, 60*5*1000, 1,EVENT_FLAG_DO_NOT_EXECUTE_IN_WORLD_CONTEXT);
-
+			spawned++;
 		}
 	}
 
@@ -1692,19 +1708,81 @@
 	
 	if(target->GetTypeId() == TYPEID_UNIT || target->GetTypeId() == TYPEID_PLAYER)
 	{
-		float angle = m_Unit->calcAngle(m_Unit->GetPositionX(), m_Unit->GetPositionY(), target->GetPositionX(), target->GetPositionY()) * float(M_PI) / 180.0f;
+		float ResX = target->GetPositionX();
+		float ResY = target->GetPositionY();
+		float ResZ = target->GetPositionZ();
+
+#ifdef COLLISION_CRAP	
+		uint32 mapid = m_Unit->GetMapId();
+		LocationVector* v2add = new LocationVector(ResX,ResY,ResZ);
+
+		bool los = CollideInterface.CheckLOS(mapid,m_Unit->GetPositionNC(),target->GetPositionNC());
+		if (los)
+		{
+			AttackWaypoints.clear();
+			AttackWaypoints.push_back(v2add);
+		//	printf("Pushed: %f %f \n",v2add->x,v2add->y);
+		}
+		else
+		{
+			int32 i=0;
+			int32 index=-1;
+			//printf("\n===============\n");
+			for (list<LocationVector*>::iterator itr = AttackWaypoints.begin();itr!=AttackWaypoints.end();++itr)
+			{
+				LocationVector* cur = *itr;
+				if (CollideInterface.CheckLOS(mapid,m_Unit->GetPositionNC(),*cur))
+					index=i;
+				++i;
+			//	printf("List: %f %f \n",cur->x,cur->y);
+			}
+			//printf("===============\n");
+			//printf("Index: %d\n",index);
+
+			for (int32 x =0;x<index;x++)
+			{
+				if (AttackWaypoints.size()>0)
+				{
+					//printf(" deletion ");
+					AttackWaypoints.erase(AttackWaypoints.begin());
+				}
+			}
+
+			LocationVector* Res = v2add;
+			if (AttackWaypoints.size()>0)
+			{
+/*				LocationVector* Last = AttackWaypoints.back();
+				if (!CollideInterface.CheckLOS(mapid,*Last,target->GetPositionNC()))
+					AttackWaypoints.push_back(WaypointLOS);
+				*/
+
+				Res = *AttackWaypoints.begin();
+				//printf("Res: %f %f\n",Res->x,Res->y);
+			}
+
+			ResX = Res->x;
+			ResY = Res->y;
+		}
+		WaypointLOS = v2add;
+#endif
+
+		float angle = m_Unit->calcAngle(m_Unit->GetPositionX(), m_Unit->GetPositionY(), ResX, ResY) * float(M_PI) / 180.0f;
 		float x = dist * cosf(angle);
 		float y = dist * sinf(angle);
-		if( target->GetTypeId() == TYPEID_PLAYER && static_cast< Player* >( target )->m_isMoving )
+
+#ifdef COLLISION_CRAP
+		if (los)
+#endif
+		if(target->GetTypeId() == TYPEID_PLAYER && static_cast< Player* >( target )->m_isMoving )
 		{
 			// cater for moving player vector based on orientation
 			x -= cosf(target->GetOrientation());
 			y -= sinf(target->GetOrientation());
 		}
 
-		m_nextPosX = target->GetPositionX() - x;
-		m_nextPosY = target->GetPositionY() - y;
-		m_nextPosZ = target->GetPositionZ();
+		m_nextPosX = ResX - x;
+		m_nextPosY = ResY - y;
+		m_nextPosZ = ResZ;
 	}
 	else
 	{
@@ -1769,17 +1847,35 @@
 	return 0.0f;
 }
 
+/************************************************************************************************************
+SendMoveToPacket:
+Comments: Some comments on the SMSG_MONSTER_MOVE packet: 
+	the uint8 field:
+		0: Default															known
+		1: Don't move														known
+		2: there is an extra 3 floats, also known as a vector				unknown
+		3: there is an extra uint64 most likely a guid.						unknown
+		4: there is an extra float that causes the orientation to be set.	known
+		
+		note:	when this field is 1. 
+			there is no need to send  the next 3 uint32's as they are'nt used by the client
+	
+	the MoveFlags:
+		0x00000000 - Walk
+		0x00000100 - Run
+		0x00000200 - Fly
+		some comments on that 0x00000300 - Fly = 0x00000100 | 0x00000200
+
+	waypoints:
+		TODO.... as they somehow seemed to be changed long time ago..
+		
+*************************************************************************************************************/
+
 void AIInterface::SendMoveToPacket(float toX, float toY, float toZ, float toO, uint32 time, uint32 MoveFlags)
 {
 	//this should NEVER be called directly !!!!!!
 	//use MoveTo()
 
-	/*
-	Move Flags
-	0x00000000 - Walk
-	0x00000100 - Run
-	0x00000300 - Fly
-	*/
 #ifndef USING_BIG_ENDIAN
 	StackWorldPacket<60> data(SMSG_MONSTER_MOVE);
 #else
@@ -1802,10 +1898,8 @@
 	data << uint32(1);	  // 1 waypoint
 	data << toX << toY << toZ;
 
-	if(m_Unit->GetTypeId() == TYPEID_PLAYER)
-		m_Unit->SendMessageToSet( &data, true );
-	else
-		m_Unit->SendMessageToSet( &data, false );
+	bool self = m_Unit->GetTypeId() == TYPEID_PLAYER;
+	m_Unit->SendMessageToSet( &data, self );
 }
 
 /*
@@ -2608,13 +2702,13 @@
 			else
 			{
 				if( CollideInterface.GetFirstPoint(m_Unit->GetMapId(), m_Unit->GetPositionX(), m_Unit->GetPositionY(), m_Unit->GetPositionZ() + 2.0f,
-					Fx, Fy, Fz, &Fx, &Fy, &Fz, -1.0f) )
+					Fx, Fy, Fz + 2.0f, Fx, Fy, Fz, -1.0f) )
 				{
-					Fz = CollideInterface.GetHeight(m_Unit->GetMapId(), Fx, Fy, m_Unit->GetPositionZ() + 2.0f);
+					//Fz = CollideInterface.GetHeight(m_Unit->GetMapId(), Fx, Fy, m_Unit->GetPositionZ() + 2.0f);
 				}
 			}
 
-			if( abs( m_Unit->GetPositionZ() - Fz ) > 10.0f || 
+			if( fabs( m_Unit->GetPositionZ() - Fz ) > 10.0f || 
 				( wl != 0.0f && Fz < wl ) )		// in water
 			{
 				m_FearTimer=getMSTime() + 500;
@@ -2658,15 +2752,15 @@
 		else
 		{
 			if( CollideInterface.GetFirstPoint(m_Unit->GetMapId(), m_Unit->GetPositionX(), m_Unit->GetPositionY(), m_Unit->GetPositionZ() + 2.0f,
-				wanderX, wanderY, wanderZ + 2.0f, &wanderX, &wanderY, &wanderZ, -1.0f) )
+				wanderX, wanderY, wanderZ + 2.0f, wanderX, wanderY, wanderZ, -1.0f) )
 			{
-				wanderZ = CollideInterface.GetHeight(m_Unit->GetMapId(), wanderX, wanderY, m_Unit->GetPositionZ() + 2.0f);
+				//wanderZ = CollideInterface.GetHeight(m_Unit->GetMapId(), wanderX, wanderY, m_Unit->GetPositionZ() + 2.0f);
 			}
 			else
 				wanderZ = wanderZ2;
 		}
 
-		if( abs( m_Unit->GetPositionZ() - wanderZ ) > 10.0f )
+		if( fabs( m_Unit->GetPositionZ() - wanderZ ) > 10.0f )
 		{
 			m_WanderTimer=getMSTime() + 1000;
 		}
@@ -2752,6 +2846,9 @@
 
 void AIInterface::CastSpell(Unit* caster, SpellEntry *spellInfo, SpellCastTargets targets)
 {
+	if( m_AIType != AITYPE_PET && disable_spell )
+		return;
+
 	// Stop movement while casting.
 	m_AIState = STATE_CASTING;
 #ifdef _AI_DEBUG
@@ -3177,7 +3274,7 @@
 	{
 		isTaunted = false;
 		tauntedBy = NULL;
-		//taunt is ower, we should get a new target based on most hated list
+		//taunt is over, we should get a new target based on most hated list
 		SetNextTarget(GetMostHated());
 	}
 
@@ -3291,19 +3388,15 @@
 		m_assistTargets.erase(itr);
 }
 
-uint32 AIInterface::_CalcThreat(uint32 damage, uint32 spellId, Unit* Attacker)
+uint32 AIInterface::_CalcThreat(uint32 damage, SpellEntry * sp, Unit* Attacker)
 {
 	if (isSameFaction(m_Unit,Attacker))
 		return 0;
 
 	int32 mod = 0;
-	if(spellId != 0)
+	if( sp != NULL && sp->ThreatForSpell != 0 )
 	{
-		mod = objmgr.GetAIThreatToSpellId(spellId);
-		if(mod == 0)
-		{
-			mod = damage;
-		}
+		mod = sp->ThreatForSpell;
 	}
 	else
 	{
Index: AIInterface.h
===================================================================
--- AIInterface.h	(revision 187)
+++ AIInterface.h	(working copy)
@@ -310,7 +310,7 @@
 	void _CalcDestinationAndMove(Unit *target, float dist);
 	float _CalcCombatRange(Unit* target, bool ranged);
 	float _CalcDistanceFromHome();
-	uint32 _CalcThreat(uint32 damage, uint32 spellId, Unit* Attacker);
+	uint32 _CalcThreat(uint32 damage, SpellEntry * sp, Unit* Attacker);
 	
 	void SetAllowedToEnterCombat(bool val) { m_AllowedToEnterCombat = val; }
 	ASCENT_INLINE bool GetAllowedToEnterCombat(void) { return m_AllowedToEnterCombat; }
@@ -385,6 +385,11 @@
  
 	list<AI_Spell*> m_spells;
 
+#ifdef COLLISION_CRAP
+	list<LocationVector*> AttackWaypoints;
+	LocationVector* WaypointLOS;
+#endif
+
 	bool disable_combat;
 
 	bool disable_melee;
Index: AreaTrigger.cpp
===================================================================
--- AreaTrigger.cpp	(revision 187)
+++ AreaTrigger.cpp	(working copy)
@@ -133,8 +133,11 @@
 		return;
 	}
 
+	if( _player->GetSession()->CanUseCommand('z') )
+		sChatHandler.BlueSystemMessage( this, "[%sSystem%s] |rEntered areatrigger: %s%u (%s).", MSG_COLOR_WHITE, MSG_COLOR_LIGHTBLUE, MSG_COLOR_SUBWHITE, id, pAreaTrigger->Name );
+
 	// if in BG handle is triggers
-	if(_player->m_bg)
+	if( _player->m_bg )
 	{
 		_player->m_bg->HookOnAreaTrigger(_player, id);
 		return;
@@ -143,6 +146,9 @@
 	if (_player->GetMapMgr())
 		_player->GetMapMgr()->HookOnAreaTrigger(_player, id);
 
+	// Hook for Scripted Areatriggers
+	_player->GetMapMgr()->HookOnAreaTrigger(_player, id);
+
 	switch(pAreaTrigger->Type)
 	{
 	case ATTYPE_INSTANCE:
Index: AuctionHouse.cpp
===================================================================
--- AuctionHouse.cpp	(revision 187)
+++ AuctionHouse.cpp	(working copy)
@@ -459,12 +459,13 @@
 	recv_data >> bid >> buyout >> etime;
 
 	Creature * pCreature = _player->GetMapMgr()->GetCreature((uint32)guid);
-	if (!pCreature || !pCreature->auctionHouse)
+	if(  !pCreature || !pCreature->auctionHouse )
 		return;		// NPC doesnt exist or isnt an auctioneer
 
 	// Get item
 	Item * pItem = _player->GetItemInterface()->GetItemByGUID(item);
-	if (!pItem){
+	if( !pItem || pItem->IsSoulbound() || pItem->HasFlag(ITEM_FIELD_FLAGS, ITEM_FLAG_CONJURED ) )
+	{
 		WorldPacket data(SMSG_AUCTION_COMMAND_RESULT, 8);
 		data << uint32(0);
 		data << uint32(AUCTION_CREATE);
Index: BattlegroundHandler.cpp
===================================================================
--- BattlegroundHandler.cpp	(revision 187)
+++ BattlegroundHandler.cpp	(working copy)
@@ -135,6 +135,7 @@
 
 void WorldSession::HandleBattleMasterJoinOpcode(WorldPacket &recv_data)
 {
+	CHECK_INWORLD_RETURN
 	if(_player->GetGroup() && _player->GetGroup()->m_isqueued)
 	{
 		SystemMessage("You are in a group that is already queued for a battleground or inside a battleground. Leave this first.");
@@ -151,6 +152,7 @@
 
 void WorldSession::HandleArenaJoinOpcode(WorldPacket &recv_data)
 {
+	CHECK_INWORLD_RETURN
 	if(_player->GetGroup() && _player->GetGroup()->m_isqueued)
 	{
 		SystemMessage("You are in a group that is already queued for a battleground or inside a battleground. Leave this first.");
@@ -186,17 +188,89 @@
 		BattlegroundManager.HandleArenaJoin(this, bgtype, as_group, rated_match);
 }
 
-void WorldSession::HandleInspectHonorStatsOpcode(WorldPacket &recv_data)
+void WorldSession::HandleInspectHonorStatsOpcode( WorldPacket &recv_data )
 {
-	/* This belongs in HonorHandler. :P
-	 * - Burlex
-	 */
+    CHECK_PACKET_SIZE( recv_data, 8 );
+	CHECK_INWORLD_RETURN
 
-	sLog.outString("Received MSG_INSPECT_HONOR_STATS");
+    uint64 guid;
+    recv_data >> guid;
+
+  	if( _player == NULL )
+	{
+		sLog.outError( "HandleInspectHonorStatsOpcode : _player was null" );
+		return;
+	}
+
+	if( _player->GetMapMgr() == NULL )
+	{
+		sLog.outError( "HandleInspectHonorStatsOpcode : _player map mgr was null" );
+		return;
+	}
+
+	if( _player->GetMapMgr()->GetPlayer( (uint32)guid ) == NULL )
+	{
+		sLog.outError( "HandleInspectHonorStatsOpcode : guid was null" );
+		return;
+	}
+
+    Player* player =  _player->GetMapMgr()->GetPlayer( (uint32)guid );
+
+    WorldPacket data( MSG_INSPECT_HONOR_STATS, 13 );
+
+    data << player->GetGUID() << (uint8)player->GetUInt32Value( PLAYER_FIELD_HONOR_CURRENCY );
+    data << player->GetUInt32Value( PLAYER_FIELD_KILLS );
+    data << player->GetUInt32Value( PLAYER_FIELD_TODAY_CONTRIBUTION );
+    data << player->GetUInt32Value( PLAYER_FIELD_YESTERDAY_CONTRIBUTION );
+    data << player->GetUInt32Value( PLAYER_FIELD_LIFETIME_HONORBALE_KILLS );
+
+    SendPacket( &data );
 }
 
+void WorldSession::HandleInspectArenaStatsOpcode( WorldPacket & recv_data )
+{
+    CHECK_PACKET_SIZE( recv_data, 8 );
+	CHECK_INWORLD_RETURN
+
+    uint64 guid;
+    recv_data >> guid;
+
+    Player* player =  _player->GetMapMgr()->GetPlayer( (uint32)guid );
+	if( player == NULL )
+	{
+		sLog.outError( "HandleInspectHonorStatsOpcode : guid was null" );
+		return;
+	}
+
+	uint32 id;
+
+    for( uint8 i = 0; i < 3; i++ )
+    {
+		id = player->GetUInt32Value( PLAYER_FIELD_ARENA_TEAM_INFO_1_1 + ( i * 6 ) );
+        if( id > 0 )
+        {
+            ArenaTeam* team = objmgr.GetArenaTeamById( id );
+            if( team != NULL )
+			{
+				WorldPacket data( MSG_INSPECT_ARENA_STATS, 8 + 1 + 4 * 5 );
+				data << player->GetGUID();
+				data << team->m_type;
+				data << team->m_id;
+				data << team->m_stat_rating;
+				data << team->m_stat_gamesplayedweek;
+				data << team->m_stat_gameswonweek;
+				data << team->m_stat_gamesplayedseason;
+				SendPacket( &data );
+
+			}
+        }
+    }
+}
+
+
 void WorldSession::HandlePVPLogDataOpcode(WorldPacket &recv_data)
 {
+	CHECK_INWORLD_RETURN
 	if(_player->m_bg)
 		_player->m_bg->SendPVPData(_player);
 }
Index: BattlegroundMgr.cpp
===================================================================
--- BattlegroundMgr.cpp	(revision 187)
+++ BattlegroundMgr.cpp	(working copy)
@@ -250,6 +250,7 @@
 					{
 						plr = *tempPlayerVec[0].begin();
 						tempPlayerVec[0].pop_front();
+						plr->m_bgTeam=team;
 						arena->AddPlayer(plr, team);
 						ErasePlayerFromList(plr->GetGUIDLow(), &m_queuedPlayers[i][j]);
 						team = arena->GetFreeTeam();
@@ -1117,24 +1118,24 @@
 	if(m_countdownStage == 1)
 	{
 		m_countdownStage = 2;
-		SendChatMessage(CHAT_MSG_BATTLEGROUND_EVENT, 0, "One minute until the battle for %s begins!", GetName());
+		SendChatMessage( CHAT_MSG_BG_EVENT_NEUTRAL, 0, "One minute until the battle for %s begins!", GetName() );
 	}
 	else if(m_countdownStage == 2)
 	{
 		m_countdownStage = 3;
-		SendChatMessage(CHAT_MSG_BATTLEGROUND_EVENT, 0, "Thirty seconds until the battle for %s begins!", GetName());
+		SendChatMessage( CHAT_MSG_BG_EVENT_NEUTRAL, 0, "Thirty seconds until the battle for %s begins!", GetName() );
 	}
 	else if(m_countdownStage == 3)
 	if(m_countdownStage==1)
 	{
 		m_countdownStage = 4;
-		SendChatMessage(CHAT_MSG_BATTLEGROUND_EVENT, 0, "Fifteen seconds until the battle for %s begins!", GetName());
+		SendChatMessage( CHAT_MSG_BG_EVENT_NEUTRAL, 0, "Fifteen seconds until the battle for %s begins!", GetName() );
 		sEventMgr.ModifyEventTime(this, EVENT_BATTLEGROUND_COUNTDOWN, 15000);
 		sEventMgr.ModifyEventTimeLeft(this, EVENT_BATTLEGROUND_COUNTDOWN, 15000);
 	}
 	else
 	{
-		SendChatMessage(CHAT_MSG_BATTLEGROUND_EVENT, 0, "The battle for %s has begun!", GetName());
+		SendChatMessage( CHAT_MSG_BG_EVENT_NEUTRAL, 0, "The battle for %s has begun!", GetName() );
 		sEventMgr.RemoveEvents(this, EVENT_BATTLEGROUND_COUNTDOWN);
 		Start();
 	}
Index: ChannelHandler.cpp
===================================================================
--- ChannelHandler.cpp	(revision 187)
+++ ChannelHandler.cpp	(working copy)
@@ -34,7 +34,7 @@
 	recvPacket >> channelname;
 	recvPacket >> pass;
 
-	if(!stricmp(channelname.c_str(), "LookingForGroup") && HasFlag(ACCOUNT_FLAG_NO_AUTOJOIN))
+	if(!stricmp(channelname.c_str(), "LookingForGroup")/* && HasFlag(ACCOUNT_FLAG_NO_AUTOJOIN)*/)
 	{
 		// make sure we have lfg dungeons
 		for(i = 0; i < 3; ++i)
Index: CharacterHandler.cpp
===================================================================
--- CharacterHandler.cpp	(revision 187)
+++ CharacterHandler.cpp	(working copy)
@@ -112,7 +112,8 @@
 	};
 
 	player_item items[20];
-	uint32 slot;
+	int8 slot;
+	int8 containerslot;
 	uint32 i;
 	ItemPrototype * proto;
 	QueryResult * res;
@@ -201,21 +202,25 @@
 			else
 				data << uint32(0) << uint32(0) << uint32(0);
 
-			res = CharacterDatabase.Query("SELECT slot, entry FROM playeritems WHERE ownerguid=%u and containerslot=-1 and slot < 19 and slot >= 0", GUID_LOPART(guid));
+			res = CharacterDatabase.Query("SELECT containerslot, slot, entry FROM playeritems WHERE ownerguid=%u", GUID_LOPART(guid));
 
 			memset(items, 0, sizeof(player_item) * 20);
 			if(res)
 			{
 				do 
 				{
-					proto = ItemPrototypeStorage.LookupEntry(res->Fetch()[1].GetUInt32());
-					if(proto)
+					containerslot = res->Fetch()[0].GetInt8();
+					slot = res->Fetch()[1].GetInt8();
+					if( containerslot == -1 && slot < 19 && slot >= 0 )
 					{
-						// slot0 = head, slot14 = cloak
-						slot = res->Fetch()[0].GetUInt32();
-						if(!(slot == 0 && (flags & (uint32)PLAYER_FLAG_NOHELM) != 0) && !(slot == 14 && (flags & (uint32)PLAYER_FLAG_NOCLOAK) != 0)) {
-							items[slot].displayid = proto->DisplayInfoID;
-							items[slot].invtype = proto->InventoryType;
+						proto = ItemPrototypeStorage.LookupEntry(res->Fetch()[2].GetUInt32());
+						if(proto)
+						{
+							// slot0 = head, slot14 = cloak
+							if(!(slot == 0 && (flags & (uint32)PLAYER_FLAG_NOHELM) != 0) && !(slot == 14 && (flags & (uint32)PLAYER_FLAG_NOCLOAK) != 0)) {
+								items[slot].displayid = proto->DisplayInfoID;
+								items[slot].invtype = proto->InventoryType;
+							}
 						}
 					}
 				} while(res->NextRow());
@@ -483,7 +488,7 @@
 		fail = 0x3B;
 	} else {
 
-		QueryResult * result = CharacterDatabase.Query("SELECT name FROM characters WHERE guid = %u", (uint32)guid);
+		QueryResult * result = CharacterDatabase.Query("SELECT name FROM characters WHERE guid = %u AND acct = %u", (uint32)guid, _accountId);
 		PlayerInfo * inf = objmgr.GetPlayerInfo((uint32)guid);
 		if(!result || !inf)
 			return;
@@ -514,8 +519,10 @@
 				t->RemoveMember(inf);
 		}
 		
-		if( _socket != NULL )
-			sPlrLog.write("Account: %s | IP: %s >> Deleted player %s", GetAccountName().c_str(), GetSocket()->GetRemoteIP().c_str(), name.c_str());
+		/*if( _socket != NULL )
+			sPlrLog.write("Account: %s | IP: %s >> Deleted player %s", GetAccountName().c_str(), GetSocket()->GetRemoteIP().c_str(), name.c_str());*/
+		
+		sPlrLog.writefromsession(this, "deleted character %s (GUID: %u)", name.c_str(), (uint32)guid);
 
 		sSocialMgr.RemovePlayer((uint32)guid);
 
@@ -601,6 +608,8 @@
 	// correct capitalization
 	CapitalizeString(name);
 
+	sPlrLog.writefromsession(this, "a rename was pending. renamed character %s (GUID: %u) to %s.", pi->name, pi->guid, name.c_str());
+
 	// If we're here, the name is okay.
 	free(pi->name);
 	pi->name = strdup(name.c_str());
@@ -1001,5 +1010,7 @@
 	}
 
 	GreenSystemMessage(m_session, "Changed name of '%s' to '%s'.", name1, name2);
+	sGMLog.writefromsession(m_session, "renamed character %s (GUID: %u) to %s", name1, pi->guid, name2);
+	sPlrLog.writefromsession(m_session, "GM renamed character %s (GUID: %u) to %s", name1, pi->guid, name2);
 	return true;
 }
Index: Chat.cpp
===================================================================
--- Chat.cpp	(revision 187)
+++ Chat.cpp	(working copy)
@@ -383,6 +383,7 @@
 		{ "level",	  'z', &ChatHandler::HandleAccountLevelCommand,    "Sets gm level on account. Pass it username and 0,1,2,3,az, etc.", NULL, 0, 0, 0 },
 		{ "password", 'z', &ChatHandler::HandleAccountPasswordCommand, "Sets password on account. Pass it username password.",	NULL, 0, 0, 0},
 		{ "mute",	  'a', &ChatHandler::HandleAccountMuteCommand,		"Mutes account for <timeperiod>.", NULL, 0, 0, 0 },
+		{ "unmute",	  'a', &ChatHandler::HandleAccountUnmuteCommand,	"Unmutes account <x>", NULL, 0, 0, 0 },
 
 		{ NULL, 0, NULL, "", NULL, 0, 0, 0},
 	};
Index: Chat.h
===================================================================
--- Chat.h	(revision 187)
+++ Chat.h	(working copy)
@@ -45,26 +45,89 @@
 	CHAT_MSG_MONSTER_YELL							= 0x0C,
 	CHAT_MSG_MONSTER_EMOTE							= 0x0D,
 	CHAT_MSG_CHANNEL								= 0x0E,
-	CHAT_MSG_CHANNEL_JOIN							= 0x10,
-	CHAT_MSG_CHANNEL_LEAVE							= 0x11,
-	CHAT_MSG_CHANNEL_LIST							= 0x12,
-	CHAT_MSG_CHANNEL_NOTICE							= 0x13,
-	CHAT_MSG_CHANNEL_NOTICE_USER					= 0x14,
-	CHAT_MSG_AFK									= 0x15,
-	CHAT_MSG_DND									= 0x16,
-	CHAT_MSG_COMBAT_LOG								= 0x17,
-	CHAT_MSG_IGNORED								= 0x18,
-	CHAT_MSG_SKILL									= 0x19,
+    CHAT_MSG_CHANNEL_JOIN							= 0x0F,
+	CHAT_MSG_CHANNEL_LEAVE							= 0x10,
+    CHAT_MSG_CHANNEL_LIST							= 0x11,
+    CHAT_MSG_CHANNEL_NOTICE							= 0x12,
+    CHAT_MSG_CHANNEL_NOTICE_USER					= 0x13,
+    CHAT_MSG_AFK									= 0x14,
+    CHAT_MSG_DND									= 0x15,
+    CHAT_MSG_IGNORED								= 0x16,
+    CHAT_MSG_SKILL									= 0x17,
+    CHAT_MSG_LOOT									= 0x18,
+    CHAT_MSG_COMBAT_MISC_INFO						= 0x19,
 	CHAT_MSG_MONSTER_WHISPER						= 0x1A,
-	CHAT_MSG_LOOT									= 0x20,
-	CHAT_MSG_BATTLEGROUND_EVENT						= 0x53,
-	CHAT_MSG_RAIDLEADER								= 0x57,
-	CHAT_MSG_RAIDWARNING							= 0x58,
-	CHAT_MSG_RAID_BOSS_EMOTE						= 0x5A,
-    CHAT_MSG_MONEY,                                 // value is guessed...
+    CHAT_MSG_COMBAT_SELF_HITS						= 0x1B,
+    CHAT_MSG_COMBAT_SELF_MISSES						= 0x1C,
+    CHAT_MSG_COMBAT_PET_HITS						= 0x1D,
+    CHAT_MSG_COMBAT_PET_MISSES						= 0x1E,
+    CHAT_MSG_COMBAT_PARTY_HITS						= 0x1F,
+    CHAT_MSG_COMBAT_PARTY_MISSES					= 0x20,
+    CHAT_MSG_COMBAT_FRIENDLYPLAYER_HITS				= 0x21,
+    CHAT_MSG_COMBAT_FRIENDLYPLAYER_MISSES			= 0x22,
+    CHAT_MSG_COMBAT_HOSTILEPLAYER_HITS				= 0x23,
+    CHAT_MSG_COMBAT_HOSTILEPLAYER_MISSES			= 0x24,
+    CHAT_MSG_COMBAT_CREATURE_VS_SELF_HITS			= 0x25,
+    CHAT_MSG_COMBAT_CREATURE_VS_SELF_MISSES			= 0x26,
+    CHAT_MSG_COMBAT_CREATURE_VS_PARTY_HITS			= 0x27,
+    CHAT_MSG_COMBAT_CREATURE_VS_PARTY_MISSES		= 0x28,
+    CHAT_MSG_COMBAT_CREATURE_VS_CREATURE_HITS		= 0x29,
+    CHAT_MSG_COMBAT_CREATURE_VS_CREATURE_MISSES		= 0x2A,
+    CHAT_MSG_COMBAT_FRIENDLY_DEATH					= 0x2B,
+    CHAT_MSG_COMBAT_HOSTILE_DEATH					= 0x2C,
+    CHAT_MSG_COMBAT_XP_GAIN							= 0x2D,
+    CHAT_MSG_SPELL_SELF_DAMAGE						= 0x2E,
+    CHAT_MSG_SPELL_SELF_BUFF						= 0x2F,
+    CHAT_MSG_SPELL_PET_DAMAGE						= 0x30,
+    CHAT_MSG_SPELL_PET_BUFF							= 0x31,
+    CHAT_MSG_SPELL_PARTY_DAMAGE						= 0x32,
+    CHAT_MSG_SPELL_PARTY_BUFF						= 0x33,
+    CHAT_MSG_SPELL_FRIENDLYPLAYER_DAMAGE			= 0x34,
+    CHAT_MSG_SPELL_FRIENDLYPLAYER_BUFF				= 0x35,
+    CHAT_MSG_SPELL_HOSTILEPLAYER_DAMAGE				= 0x36,
+    CHAT_MSG_SPELL_HOSTILEPLAYER_BUFF				= 0x37,
+    CHAT_MSG_SPELL_CREATURE_VS_SELF_DAMAGE			= 0x38,
+    CHAT_MSG_SPELL_CREATURE_VS_SELF_BUFF			= 0x39,
+    CHAT_MSG_SPELL_CREATURE_VS_PARTY_DAMAGE			= 0x3A,
+    CHAT_MSG_SPELL_CREATURE_VS_PARTY_BUFF			= 0x3B,
+    CHAT_MSG_SPELL_CREATURE_VS_CREATURE_DAMAGE		= 0x3C,
+    CHAT_MSG_SPELL_CREATURE_VS_CREATURE_BUFF		= 0x3D,
+    CHAT_MSG_SPELL_TRADESKILLS						= 0x3E,
+    CHAT_MSG_SPELL_DAMAGESHIELDS_ON_SELF			= 0x3F,
+    CHAT_MSG_SPELL_DAMAGESHIELDS_ON_OTHERS			= 0x40,
+    CHAT_MSG_SPELL_AURA_GONE_SELF					= 0x41,
+    CHAT_MSG_SPELL_AURA_GONE_PARTY					= 0x42,
+    CHAT_MSG_SPELL_AURA_GONE_OTHER					= 0x43,
+    CHAT_MSG_SPELL_ITEM_ENCHANTMENTS				= 0x44,
+    CHAT_MSG_SPELL_BREAK_AURA						= 0x45,
+    CHAT_MSG_SPELL_PERIODIC_SELF_DAMAGE				= 0x46,
+    CHAT_MSG_SPELL_PERIODIC_SELF_BUFFS				= 0x47,
+    CHAT_MSG_SPELL_PERIODIC_PARTY_DAMAGE			= 0x48,
+    CHAT_MSG_SPELL_PERIODIC_PARTY_BUFFS				= 0x49,
+    CHAT_MSG_SPELL_PERIODIC_FRIENDLYPLAYER_DAMAGE	= 0x4A,
+    CHAT_MSG_SPELL_PERIODIC_FRIENDLYPLAYER_BUFFS	= 0x4B,
+    CHAT_MSG_SPELL_PERIODIC_HOSTILEPLAYER_DAMAGE	= 0x4C,
+    CHAT_MSG_SPELL_PERIODIC_HOSTILEPLAYER_BUFFS		= 0x4D,
+    CHAT_MSG_SPELL_PERIODIC_CREATURE_DAMAGE			= 0x4E,
+    CHAT_MSG_SPELL_PERIODIC_CREATURE_BUFFS			= 0x4F,
+    CHAT_MSG_SPELL_FAILED_LOCALPLAYER				= 0x50,
+    CHAT_MSG_COMBAT_HONOR_GAIN						= 0x51,
+    CHAT_MSG_BG_EVENT_NEUTRAL						= 0x52,
+    CHAT_MSG_BG_EVENT_ALLIANCE						= 0x53,
+    CHAT_MSG_BG_EVENT_HORDE							= 0x54,
+    CHAT_MSG_COMBAT_FACTION_CHANGE					= 0x55,
+    CHAT_MSG_MONEY									= 0x56,
+    CHAT_MSG_RAID_LEADER							= 0x57,
+    CHAT_MSG_RAID_WARNING							= 0x58,
+    CHAT_MSG_FOREIGN_TELL							= 0x59,
+    CHAT_MSG_RAID_BOSS_EMOTE						= 0x5A,
+    CHAT_MSG_FILTERED								= 0x5B,
+    CHAT_MSG_BATTLEGROUND							= 0x5C,
+    CHAT_MSG_BATTLEGROUND_LEADER					= 0x5D,
+    CHAT_MSG_MONSTER_PARTY							= 0x5E,
+    CHAT_MSG_RESTRICTED								= 0x5F,
 };
 
-
 enum Languages
 {
     LANG_UNIVERSAL                              = 0x00,
@@ -487,6 +550,7 @@
 	bool HandleRenameAllCharacter(const char * args, WorldSession * m_session);
 	bool HandleCollisionGetHeight(const char * args, WorldSession * m_session);
 	bool HandleAccountMuteCommand(const char * args, WorldSession * m_session);
+	bool HandleAccountUnmuteCommand(const char * args, WorldSession * m_session);
 	/* For skill related GM commands */
 	SkillNameMgr *SkillNameManager;
 };
Index: ChatHandler.cpp
===================================================================
--- ChatHandler.cpp	(revision 187)
+++ ChatHandler.cpp	(working copy)
@@ -187,8 +187,8 @@
 		} break;
 	case CHAT_MSG_PARTY:
 	case CHAT_MSG_RAID:
-	case CHAT_MSG_RAIDLEADER:
-	case CHAT_MSG_RAIDWARNING:
+	case CHAT_MSG_RAID_LEADER:
+	case CHAT_MSG_RAID_WARNING:
 		{
 			recv_data >> msg;
 
@@ -545,19 +545,6 @@
 	}
 }
 
-void WorldSession::HandleInspectOpcode( WorldPacket & recv_data )
-{
-    //CHECK_PACKET_SIZE(recvPacket, 8);
-
-    //GetPlayer()->GetSession()->OutPacket(SMSG_INSPECT_TALENTS, 0, 0 );
-
-    //uint64 guid;
-    //recvPacket >> guid;
-
-	// TODO return SMSG_INSPECT_TALENTS
-	return;
-}
-
 void WorldSession::HandleReportSpamOpcode(WorldPacket & recvPacket)
 {
 	CHECK_PACKET_SIZE(recvPacket, 29);
Index: CollideInterface.cpp
===================================================================
--- CollideInterface.cpp	(revision 187)
+++ CollideInterface.cpp	(working copy)
@@ -24,11 +24,10 @@
 #define MAX_MAP 600
 
 CCollideInterface CollideInterface;
+IVMapManager * CollisionMgr;
 Mutex m_loadLock;
 uint32 m_tilesLoaded[MAX_MAP][64][64];
 
-#define COLLISION_DEBUG
-
 #ifdef WIN32
 #ifdef COLLISION_DEBUG
 
@@ -58,26 +57,6 @@
 #pragma comment(lib, "collision.lib")
 #endif
 
-void log_normal(const char * msg)
-{
-	Log.Notice("Collision", msg);
-}
-
-void log_warning(const char * msg)
-{
-	Log.Warning("Collision", msg);
-}
-
-void log_error(const char* msg)
-{
-	Log.Error("Collision", msg);
-}
-
-void log_debug(const char* msg)
-{
-	Log.Debug("Collision", msg);
-}
-
 // Debug functions
 #ifdef COLLISION_DEBUG
 
@@ -85,7 +64,7 @@
 {
 	Log.Notice("CollideInterface", "Init");
 	COLLISION_BEGINTIMER;
-	collision_init(log_normal, log_warning, log_error, log_debug);
+	CollisionMgr = ((IVMapManager*)collision_init());
 	printf("[%u ns] collision_init\n", c_GetNanoSeconds(c_GetTimerValue(), v1));
 }
 
@@ -95,7 +74,7 @@
 	if(m_tilesLoaded[mapId][tileX][tileY] == 0)
 	{
 		COLLISION_BEGINTIMER;
-		collision_activate_cell(mapId, tileX, tileY);
+		CollisionMgr->loadMap("vmaps", mapId, tileY, tileX);
 		printf("[%u ns] collision_activate_cell %u %u %u\n", c_GetNanoSeconds(c_GetTimerValue(), v1), mapId, tileX, tileY);
 	}
 
@@ -109,7 +88,7 @@
 	if(!(--m_tilesLoaded[mapId][tileX][tileY]))
 	{
 		COLLISION_BEGINTIMER;
-		collision_deactivate_cell(mapId, tileX, tileY);
+		CollisionMgr->unloadMap(mapId, tileY, tileX);
 		printf("[%u ns] collision_deactivate_cell %u %u %u\n", c_GetNanoSeconds(c_GetTimerValue(), v1), mapId, tileX, tileY);
 	}
 
@@ -127,34 +106,34 @@
 float CCollideInterface::GetHeight(uint32 mapId, float x, float y, float z)
 {
 	COLLISION_BEGINTIMER;
-	float v = collision_get_height(mapId, x, y, z);
+	float v = CollisionMgr->getHeight(mapId, x, y, z);
 	printf("[%u ns] GetHeight Map:%u %f %f %f\n", c_GetNanoSeconds(c_GetTimerValue(), v1), mapId, x, y, z);
 	return v;
 }
 
-float CCollideInterface::GetHeight(uint32 mapId, LocationVector * pos)
+float CCollideInterface::GetHeight(uint32 mapId, LocationVector & pos)
 {
 	COLLISION_BEGINTIMER;
-	float v = collision_get_height(mapId, pos);
-	printf("[%u ns] GetHeight Map:%u %f %f %f\n", c_GetNanoSeconds(c_GetTimerValue(), v1), mapId, pos->x, pos->y, pos->z);
+	float v = CollisionMgr->getHeight(mapId, pos);
+	printf("[%u ns] GetHeight Map:%u %f %f %f\n", c_GetNanoSeconds(c_GetTimerValue(), v1), mapId, pos.x, pos.y, pos.z);
 	return v;
 }
 
-bool CCollideInterface::IsIndoor(uint32 mapId, LocationVector * pos)
+bool CCollideInterface::IsIndoor(uint32 mapId, LocationVector & pos)
 {
 	bool r;
 	COLLISION_BEGINTIMER;
-	printf("[%u ns] IsIndoor Map:%u %f %f %f\n", c_GetNanoSeconds(c_GetTimerValue(), v1), mapId, pos->x, pos->y, pos->z);
-	r = collision_check_indoor(mapId, pos);
+	r = CollisionMgr->isInDoors(mapId, pos);
+	printf("[%u ns] IsIndoor Map:%u %f %f %f\n", c_GetNanoSeconds(c_GetTimerValue(), v1), mapId, pos.x, pos.y, pos.z);
 	return r;
 }
 
-bool CCollideInterface::IsIndoorMod(uint32 mapId, LocationVector * pos)
+bool CCollideInterface::IsOutdoor(uint32 mapId, LocationVector & pos)
 {
 	bool r;
 	COLLISION_BEGINTIMER;
-	printf("[%u ns] IsIndoorMod Map:%u %f %f %f\n", c_GetNanoSeconds(c_GetTimerValue(), v1), mapId, pos->x, pos->y, pos->z);
-	r = collision_check_indoor_mod(mapId, pos);
+	r = CollisionMgr->isOutDoors(mapId, pos);
+	printf("[%u ns] IsOutdoor Map:%u %f %f %f\n", c_GetNanoSeconds(c_GetTimerValue(), v1), mapId, pos.x, pos.y, pos.z);
 	return r;
 }
 
@@ -162,26 +141,26 @@
 {
 	bool r;
 	COLLISION_BEGINTIMER;
+	r = CollisionMgr->isInDoors(mapId, x, y, z);
 	printf("[%u ns] IsIndoor Map:%u %f %f %f\n", c_GetNanoSeconds(c_GetTimerValue(), v1), mapId, x, y, z);
-	r = collision_check_indoor(mapId, x, y, z);
 	return r;
 }
 
-bool CCollideInterface::CheckLOS(uint32 mapId, LocationVector * pos1, LocationVector * pos2)
+bool CCollideInterface::IsOutdoor(uint32 mapId, float x, float y, float z)
 {
 	bool r;
 	COLLISION_BEGINTIMER;
-	printf("[%u ns] CheckLOS Map:%u %f %f %f -> %f %f %f\n", c_GetNanoSeconds(c_GetTimerValue(), v1), mapId, pos1->x, pos1->y, pos1->z, pos2->x, pos2->y, pos2->z);
-	r = collision_check_los(mapId, pos1, pos2);
+	r = CollisionMgr->isOutDoors(mapId, x, y, z);
+	printf("[%u ns] IsOutdoor Map:%u %f %f %f\n", c_GetNanoSeconds(c_GetTimerValue(), v1), mapId, x, y, z);
 	return r;
 }
 
-bool CCollideInterface::CheckLOSMod(uint32 mapId, LocationVector * pos1, LocationVector * pos2)
+bool CCollideInterface::CheckLOS(uint32 mapId, LocationVector & pos1, LocationVector & pos2)
 {
 	bool r;
 	COLLISION_BEGINTIMER;
-	printf("[%u ns] CheckLOSMod Map:%u %f %f %f -> %f %f %f\n", c_GetNanoSeconds(c_GetTimerValue(), v1), mapId, pos1->x, pos1->y, pos1->z, pos2->x, pos2->y, pos2->z);
-	r = collision_check_losmod(mapId, pos1, pos2);
+	r = CollisionMgr->isInLineOfSight(mapId, pos1, pos2);
+	printf("[%u ns] CheckLOS Map:%u %f %f %f -> %f %f %f\n", c_GetNanoSeconds(c_GetTimerValue(), v1), mapId, pos1.x, pos1.y, pos1.z, pos2.x, pos2.y, pos2.z);
 	return r;
 }
 
@@ -189,26 +168,26 @@
 {
 	bool r;
 	COLLISION_BEGINTIMER;
+	r = CollisionMgr->isInLineOfSight(mapId, x1, y1, z1, x2, y2, z2);
 	printf("[%u ns] CheckLOS Map:%u %f %f %f -> %f %f %f\n", c_GetNanoSeconds(c_GetTimerValue(), v1), mapId, x1, y1, z1, x2, y2, z2);
-	r = collision_check_los(mapId, x1, y1, z1, x2, y2, z2);
 	return r;
 }
 
-bool CCollideInterface::GetFirstPoint(uint32 mapId, LocationVector * pos1, LocationVector * pos2, LocationVector * outvec, float distmod)
+bool CCollideInterface::GetFirstPoint(uint32 mapId, LocationVector & pos1, LocationVector & pos2, LocationVector & outvec, float distmod)
 {
 	bool r;
 	COLLISION_BEGINTIMER;
-	printf("[%u ns] GetFirstPoint Map:%u %f %f %f -> %f %f %f\n", c_GetNanoSeconds(c_GetTimerValue(), v1), mapId, pos1->x, pos1->y, pos1->z, pos2->x, pos2->y, pos2->z);
-	r = collision_get_first_object_point(mapId, pos1, pos2, outvec, distmod);
+	r = CollisionMgr->getObjectHitPos(mapId, pos1, pos2, outvec, distmod);
+	printf("[%u ns] GetFirstPoint Map:%u %f %f %f -> %f %f %f\n", c_GetNanoSeconds(c_GetTimerValue(), v1), mapId, pos1.x, pos1.y, pos1.z, pos2.x, pos2.y, pos2.z);
 	return r;
 }
 
-bool CCollideInterface::GetFirstPoint(uint32 mapId, float x1, float y1, float z1, float x2, float y2, float z2, float * outx, float * outy, float * outz, float distmod)
+bool CCollideInterface::GetFirstPoint(uint32 mapId, float x1, float y1, float z1, float x2, float y2, float z2, float & outx, float & outy, float & outz, float distmod)
 {
 	bool r;
 	COLLISION_BEGINTIMER;
+	r = CollisionMgr->getObjectHitPos(mapId, x1, y1, z1, x2, y2, z2, outx, outy, outz, distmod);
 	printf("[%u ns] GetFirstPoint Map:%u %f %f %f -> %f %f %f\n", c_GetNanoSeconds(c_GetTimerValue(), v1), mapId, x1, y1, z1, x2, y2, z2);
-	r = collision_get_first_object_point(mapId, x1, y1, z1, x2, y2, z2, outx, outy, outz, distmod);
 	return r;
 }
 
@@ -217,14 +196,14 @@
 void CCollideInterface::Init()
 {
 	Log.Notice("CollideInterface", "Init");
-	collision_init(log_normal, log_warning, log_error, log_debug);
+	CollisionMgr = ((IVMapManager*)collision_init());
 }
 
 void CCollideInterface::ActivateTile(uint32 mapId, uint32 tileX, uint32 tileY)
 {
 	m_loadLock.Acquire();
 	if(m_tilesLoaded[mapId][tileX][tileY] == 0)
-		collision_activate_cell(mapId, tileX, tileY);
+		CollisionMgr->loadMap("vmaps", mapId, tileY, tileX);
 
 	++m_tilesLoaded[mapId][tileX][tileY];
 	m_loadLock.Release();
@@ -234,7 +213,7 @@
 {
 	m_loadLock.Acquire();
 	if(!(--m_tilesLoaded[mapId][tileX][tileY]))
-		collision_deactivate_cell(mapId, tileX, tileY);
+		CollisionMgr->unloadMap(mapId, tileY, tileX);
 
 	m_loadLock.Release();
 }
@@ -245,55 +224,5 @@
 	collision_shutdown();
 }
 
-float CCollideInterface::GetHeight(uint32 mapId, float x, float y, float z)
-{
-	return collision_get_height(mapId, x, y, z);
-}
-
-float CCollideInterface::GetHeight(uint32 mapId, LocationVector * pos)
-{
-	return collision_get_height(mapId, pos);
-}
-
-bool CCollideInterface::IsIndoor(uint32 mapId, LocationVector * pos)
-{
-	return collision_check_indoor(mapId, pos);
-}
-
-bool CCollideInterface::IsIndoorMod(uint32 mapId, LocationVector * pos)
-{
-	return collision_check_indoor_mod(mapId, pos);
-}
-
-bool CCollideInterface::IsIndoor(uint32 mapId, float x, float y, float z)
-{
-	return collision_check_indoor(mapId, x, y, z);
-}
-
-bool CCollideInterface::CheckLOS(uint32 mapId, LocationVector * pos1, LocationVector * pos2)
-{
-	return collision_check_los(mapId, pos1, pos2);
-}
-
-bool CCollideInterface::CheckLOSMod(uint32 mapId, LocationVector * pos1, LocationVector * pos2)
-{
-	return collision_check_losmod(mapId, pos1, pos2);
-}
-
-bool CCollideInterface::CheckLOS(uint32 mapId, float x1, float y1, float z1, float x2, float y2, float z2)
-{
-	return collision_check_los(mapId, x1, y1, z1, x2, y2, z2);
-}
-
-bool CCollideInterface::GetFirstPoint(uint32 mapId, LocationVector * pos1, LocationVector * pos2, LocationVector * outvec, float distmod)
-{
-	return collision_get_first_object_point(mapId, pos1, pos2, outvec, distmod);
-}
-
-bool CCollideInterface::GetFirstPoint(uint32 mapId, float x1, float y1, float z1, float x2, float y2, float z2, float * outx, float * outy, float * outz, float distmod)
-{
-	return collision_get_first_object_point(mapId, x1, y1, z1, x2, y2, z2, outx, outy, outz, distmod);
-}
-
 #endif		// COLLISION_DEBUG
 #endif		// COLLISION
Index: CollideInterface.h
===================================================================
--- CollideInterface.h	(revision 187)
+++ CollideInterface.h	(working copy)
@@ -23,7 +23,7 @@
 /* imports */
 #define NO_WMO_HEIGHT -100000.0f
 
-#ifdef _GAME
+//#define COLLISION_DEBUG 1
 
 #ifdef WIN32
 #define COLLISION_IMPORT __declspec(dllimport)
@@ -31,26 +31,48 @@
 #define COLLISION_IMPORT 
 #endif
 
-typedef void(*collision_log_func)(const char * msg);
-COLLISION_IMPORT void collision_init(collision_log_func normal_log, collision_log_func warning_log, collision_log_func error_log, collision_log_func debug_log);
-COLLISION_IMPORT void collision_shutdown();
-COLLISION_IMPORT void collision_activate_cell(uint32 mapid, uint32 x, uint32 y);
-COLLISION_IMPORT void collision_deactivate_cell(uint32 mapid, uint32 x, uint32 y);
+/* The class the dll sends back. */
+class IVMapManager
+{
+public:
+	IVMapManager() {}
 
-COLLISION_IMPORT bool collision_check_indoor(uint32 mapid, LocationVector * pos);
-COLLISION_IMPORT bool collision_check_indoor_mod(uint32 mapid, LocationVector * pos);
-COLLISION_IMPORT bool collision_check_los(uint32 mapid, LocationVector * pos1, LocationVector * pos2);
-COLLISION_IMPORT bool collision_check_losmod(uint32 mapid, LocationVector * pos1, LocationVector * pos2);
-COLLISION_IMPORT float collision_get_height(uint32 mapid, LocationVector * pos);
-COLLISION_IMPORT bool collision_get_first_object_point(uint32 mapid, LocationVector * pos1, LocationVector * pos2, LocationVector * outvec, float distmod);
+	virtual ~IVMapManager(void) {}
 
-COLLISION_IMPORT bool collision_check_indoor(uint32 mapid, float x, float y, float z);
-COLLISION_IMPORT bool collision_check_los(uint32 mapid, float x1, float y1, float z1, float x2, float y2, float z2);
-COLLISION_IMPORT float collision_get_height(uint32 mapid, float x, float y, float z);
-COLLISION_IMPORT bool collision_get_first_object_point(uint32 mapid, float x1, float y1, float z1, float x2, float y2, float z2, float * outx, float * outy, float * outz, float distmod);
+	virtual int loadMap(const char* pBasePath, unsigned int pMapId, int x, int y) = 0;
 
-#endif
+	virtual void unloadMap(unsigned int pMapId, int x, int y) = 0;
+	virtual void unloadMap(unsigned int pMapId) = 0;
 
+	// LOS
+	virtual bool isInLineOfSight(unsigned int pMapId, float x1, float y1, float z1, float x2, float y2, float z2) = 0;
+	virtual bool isInLineOfSight(unsigned int pMapId, LocationVector & v1, LocationVector & v2) = 0;
+
+	// Height
+	virtual float getHeight(unsigned int pMapId, float x, float y, float z) = 0;
+	virtual float getHeight(unsigned int mapid, LocationVector & vec) = 0;
+
+	// Indoors
+	virtual bool isInDoors(unsigned int mapid, float x, float y, float z) = 0;
+	virtual bool isInDoors(unsigned int mapid, LocationVector & vec) = 0;
+
+	// Outdoors
+	virtual bool isOutDoors(unsigned int mapid, float x, float y, float z) = 0;
+	virtual bool isOutDoors(unsigned int mapid, LocationVector & vec) = 0;
+
+	// Closest Point
+	virtual bool getObjectHitPos(unsigned int pMapId, float x1, float y1, float z1, float x2, float y2, float z2, float& rx, float &ry, float& rz, float pModifyDist) = 0;
+	virtual bool getObjectHitPos(unsigned int pMapId, LocationVector & v1, LocationVector & v2, LocationVector & vout, float pModifyDist) = 0;
+
+
+	virtual std::string getDirFileName(unsigned int pMapId, int x, int y) const =0;
+};
+
+COLLISION_IMPORT void * collision_init();
+COLLISION_IMPORT void collision_shutdown();
+
+extern IVMapManager * CollisionMgr;
+
 class CCollideInterface
 {
 public:
@@ -60,17 +82,74 @@
 	void ActivateTile(uint32 mapId, uint32 tileX, uint32 tileY);
 	void DeactivateTile(uint32 mapId, uint32 tileX, uint32 tileY);
 
+#ifdef COLLISION_DEBUG
+
 	bool CheckLOS(uint32 mapId, float x1, float y1, float z1, float x2, float y2, float z2);
-	bool GetFirstPoint(uint32 mapId, float x1, float y1, float z1, float x2, float y2, float z2, float * outx, float * outy, float * outz, float distmod);
+	bool GetFirstPoint(uint32 mapId, float x1, float y1, float z1, float x2, float y2, float z2, float & outx, float & outy, float & outz, float distmod);
 	bool IsIndoor(uint32 mapId, float x, float y, float z);
+	bool IsOutdoor(uint32 mapId, float x, float y, float z);
+
 	float GetHeight(uint32 mapId, float x, float y, float z);
+	bool CheckLOS(uint32 mapId, LocationVector & pos1, LocationVector & pos2);
+	bool GetFirstPoint(uint32 mapId, LocationVector & pos1, LocationVector & pos2, LocationVector & outvec, float distmod);
+	bool IsIndoor(uint32 mapId, LocationVector & pos);
+	bool IsOutdoor(uint32 mapId, LocationVector & pos);
+	float GetHeight(uint32 mapId, LocationVector & pos);
 
-	bool CheckLOS(uint32 mapId, LocationVector * pos1, LocationVector * pos2);
-	bool CheckLOSMod(uint32 mapId, LocationVector * pos1, LocationVector * pos2);
-	bool GetFirstPoint(uint32 mapId, LocationVector * pos1, LocationVector * pos2, LocationVector * outvec, float distmod);
-	bool IsIndoor(uint32 mapId, LocationVector * pos);
-	bool IsIndoorMod(uint32 mapId, LocationVector * pos);
-	float GetHeight(uint32 mapId, LocationVector * pos);
+#else
+
+	ASCENT_INLINE bool CheckLOS(uint32 mapId, float x1, float y1, float z1, float x2, float y2, float z2)
+	{
+		return CollisionMgr->isInLineOfSight( mapId, x1, y1, z1, x2, y2, z2 );
+	}
+
+	ASCENT_INLINE bool GetFirstPoint(uint32 mapId, float x1, float y1, float z1, float x2, float y2, float z2, float & outx, float & outy, float & outz, float distmod)
+	{
+		return CollisionMgr->getObjectHitPos( mapId, x1, y1, z1, x2, y2, z2, outx, outy, outz, distmod );
+	}
+	
+	ASCENT_INLINE bool IsIndoor(uint32 mapId, float x, float y, float z)
+	{
+		return CollisionMgr->isInDoors( mapId, x, y, z );
+	}
+
+	ASCENT_INLINE bool IsOutdoor(uint32 mapId, float x, float y, float z)
+	{
+		return CollisionMgr->isOutDoors( mapId, x, y, z );
+	}
+
+	ASCENT_INLINE float GetHeight(uint32 mapId, float x, float y, float z)
+	{
+		return CollisionMgr->getHeight( mapId, x, y, z );
+	}
+
+	ASCENT_INLINE bool CheckLOS(uint32 mapId, LocationVector & pos1, LocationVector & pos2)
+	{
+		return CollisionMgr->isInLineOfSight( mapId, pos1, pos2 );
+	}
+
+	ASCENT_INLINE bool GetFirstPoint(uint32 mapId, LocationVector & pos1, LocationVector & pos2, LocationVector & outvec, float distmod)
+	{
+		return CollisionMgr->getObjectHitPos( mapId, pos1, pos2, outvec, distmod );
+	}
+
+	ASCENT_INLINE bool IsIndoor(uint32 mapId, LocationVector & pos)
+	{
+		return CollisionMgr->isInDoors( mapId, pos );
+	}
+
+	ASCENT_INLINE bool IsOutdoor(uint32 mapId, LocationVector & pos)
+	{
+		return CollisionMgr->isOutDoors( mapId, pos );
+	}
+
+	ASCENT_INLINE float GetHeight(uint32 mapId, LocationVector & pos)
+	{
+		return CollisionMgr->getHeight( mapId, pos );
+	}
+
+#endif
+
 };
 
 extern CCollideInterface CollideInterface;
Index: Container.cpp
===================================================================
--- Container.cpp	(revision 187)
+++ Container.cpp	(working copy)
@@ -42,7 +42,7 @@
 {
    for(uint32 i = 0; i < m_itemProto->ContainerSlots; i++)
 	{
-		if(m_Slot[i])
+		if(m_Slot[i] && m_Slot[i]->GetOwner() == m_owner)
 		{
 			if(m_Slot[i]->IsContainer())
 				delete ((Container*)m_Slot[i]);
@@ -173,7 +173,7 @@
 void Container::SwapItems(int8 SrcSlot, int8 DstSlot)
 {
 	Item *temp;
-	if(m_Slot[DstSlot] &&  m_Slot[SrcSlot]&&m_Slot[DstSlot]->GetEntry()==m_Slot[SrcSlot]->GetEntry() && m_Slot[DstSlot]->GetProto()->MaxCount>1)
+	if(m_Slot[DstSlot] &&  m_Slot[SrcSlot]&&m_Slot[DstSlot]->GetEntry()==m_Slot[SrcSlot]->GetEntry() && m_Slot[SrcSlot]->wrapped_item_id == 0 && m_Slot[DstSlot]->wrapped_item_id == 0 && m_Slot[DstSlot]->GetProto()->MaxCount>1)
 	{
 		uint32 total=m_Slot[SrcSlot]->GetUInt32Value(ITEM_FIELD_STACK_COUNT)+m_Slot[DstSlot]->GetUInt32Value(ITEM_FIELD_STACK_COUNT);
 		m_Slot[DstSlot]->m_isDirty = m_Slot[SrcSlot]->m_isDirty = true;
@@ -233,17 +233,22 @@
 	if (pItem == NULL || pItem==this) return NULL;
 	m_Slot[slot] = NULL;
 
-	SetUInt64Value(CONTAINER_FIELD_SLOT_1  + slot*2, 0 );
-	pItem->SetUInt64Value(ITEM_FIELD_CONTAINED, 0);
+	if( pItem->GetOwner() == m_owner )
+	{
+		SetUInt64Value(CONTAINER_FIELD_SLOT_1  + slot*2, 0 );
+		pItem->SetUInt64Value(ITEM_FIELD_CONTAINED, 0);
 
-	if(destroy)
-	{
-		if(pItem->IsInWorld())
+		if(destroy)
 		{
-			pItem->RemoveFromWorld();
+			if(pItem->IsInWorld())
+			{
+				pItem->RemoveFromWorld();
+			}
+			pItem->DeleteFromDB();
 		}
-		pItem->DeleteFromDB();
 	}
+	else
+		pItem = NULL;
 
 	return pItem;
 }
Index: Corpse.h
===================================================================
--- Corpse.h	(revision 187)
+++ Corpse.h	(working copy)
@@ -25,6 +25,7 @@
 	CORPSE_STATE_BODY = 0,
 	CORPSE_STATE_BONES = 1,
 };
+
 struct CorpseData
 {
 	uint32 LowGuid;
@@ -37,6 +38,11 @@
 	void DeleteFromDB();
 };
 
+#define CORPSE_RECLAIM_TIME 30
+#define CORPSE_RECLAIM_TIME_MS CORPSE_RECLAIM_TIME * 1000
+#define CORPSE_MINIMUM_RECLAIM_RADIUS 39 
+#define CORPSE_MINIMUM_RECLAIM_RADIUS_SQ CORPSE_MINIMUM_RECLAIM_RADIUS * CORPSE_MINIMUM_RECLAIM_RADIUS
+
 class SERVER_DECL Corpse : public Object
 {
 public:
@@ -59,8 +65,13 @@
 
 	void SpawnBones();
 	void Delink();
+
+	void ResetDeathClock(){ m_time = time( NULL ); }
+	time_t GetDeathClock(){ return m_time; }
+
 private:
 	uint32 m_state;
+	time_t m_time;
 	uint32 _fields[CORPSE_END];
 	bool _loadedfromdb;
 };
Index: CThreads.cpp
===================================================================
--- CThreads.cpp	(revision 187)
+++ CThreads.cpp	(working copy)
@@ -24,38 +24,9 @@
 #include "NameTables.h"
 #include "CThreads.h"
 
-/* Name tables */
-NameTableEntry g_threadStates[] = {
-	{ THREADSTATE_TERMINATE, "STATE_TERM" },
-	{ THREADSTATE_PAUSED, "TSTATE_PAUSE" },
-	{ THREADSTATE_SLEEPING, "STATE_SLEEP" },
-	{ THREADSTATE_BUSY, "STATE_BUSY" },
-	{ THREADSTATE_AWAITING, "STATE_AWAIT" },
-	{ 0, NULL },
-};
-
-NameTableEntry g_threadTypes[] = {
-	{ THREADTYPE_UNASSIGNED, "UNASSIGNED" },
-	{ THREADTYPE_OBJECTUPDATER, "OBJECTUPDATER" },
-	{ THREADTYPE_MAPMGR, "MAPMGR" },
-	{ THREADTYPE_WORLDRUNNABLE, "WORLDRUNNABLE" },
-	{ THREADTYPE_MAILDELIVERY, "MAILDELIVERY" },
-	{ THREADTYPE_CONSOLEINTERFACE, "CONSOLE" },
-	{ THREADTYPE_IRCBOT, "IRCBOT" },
-	{ THREADTYPE_AUCTIONHOUSE, "AUCTIONHOUSE" },
-	{ THREADTYPE_NETWORK, "NETWORK" },
-	{ THREADTYPE_SESSIONUPDATER, "SESSIONUPDATER" },
-	{ THREADTYPE_SOCKETUPDATER, "SOCKETUPDATER" },
-	{ THREADTYPE_DATABASE, "DATABASEQUEUE" },
-	{ THREADTYPE_IOCPWORKER, "IOCPWORKER" },
-	{ THREADTYPE_IOCPLISTENER, "IOCPLISTENER" },
-	{ 0, NULL },
-};
-
 CThread::CThread() : ThreadBase()
 {
 	ThreadState = THREADSTATE_AWAITING;
-	ThreadType  = THREADTYPE_UNASSIGNED;
 	start_time  = 0;
 }
 
Index: CThreads.h
===================================================================
--- CThreads.h	(revision 187)
+++ CThreads.h	(working copy)
@@ -44,27 +44,8 @@
 	THREADSTATE_AWAITING  = 4,
 };
 
-enum CThreadType
-{
-	THREADTYPE_UNASSIGNED,	  
-	THREADTYPE_OBJECTUPDATER,
-	THREADTYPE_MAPMGR,
-	THREADTYPE_WORLDRUNNABLE,
-	THREADTYPE_MAILDELIVERY,
-	THREADTYPE_CONSOLEINTERFACE,
-	THREADTYPE_IRCBOT,
-	THREADTYPE_AUCTIONHOUSE,
-	THREADTYPE_NETWORK,
-	THREADTYPE_SESSIONUPDATER,
-	THREADTYPE_SOCKETUPDATER,
-	THREADTYPE_DATABASE,
-	THREADTYPE_IOCPLISTENER,
-	THREADTYPE_IOCPWORKER,
-};
 
 struct NameTableEntry;
-extern NameTableEntry g_threadStates[];
-extern NameTableEntry g_threadTypes[];
 
 class SERVER_DECL CThread : public ThreadBase
 {
@@ -74,7 +55,6 @@
 
 	ASCENT_INLINE void SetThreadState(CThreadState thread_state) { ThreadState = thread_state; }
 	ASCENT_INLINE CThreadState GetThreadState() { return ThreadState; }
-	ASCENT_INLINE CThreadType GetThreadType() { return ThreadType; }
 	int GetThreadId() { return ThreadId; }
 	time_t GetStartTime() { return start_time; }
 	virtual bool run();
@@ -82,7 +62,6 @@
 
 protected:
 	CThreadState ThreadState;
-	CThreadType  ThreadType;
 	time_t start_time;
 	int ThreadId;
 };
Index: DayWatcherThread.cpp
===================================================================
--- DayWatcherThread.cpp	(revision 187)
+++ DayWatcherThread.cpp	(working copy)
@@ -273,8 +273,8 @@
 				}
 			}
 
-			arenapointsPerTeam[0] = max(arenapointsPerTeam[0],arenapointsPerTeam[1]);
-			arenapoints += max(arenapointsPerTeam[0],arenapointsPerTeam[2]);
+			arenapointsPerTeam[0] = (uint32)max(arenapointsPerTeam[0],arenapointsPerTeam[1]);
+			arenapoints += (uint32)max(arenapointsPerTeam[0],arenapointsPerTeam[2]);
 
 			if(orig_arenapoints != arenapoints)
 			{
Index: debugcmds.cpp
===================================================================
--- debugcmds.cpp	(revision 187)
+++ debugcmds.cpp	(working copy)
@@ -741,7 +741,7 @@
 	if(!spellId)
 		return false;
 
-	uint32 threat = target->GetAIInterface()->_CalcThreat(atol(dmg), atol(spellId), m_session->GetPlayer());
+	uint32 threat = target->GetAIInterface()->_CalcThreat(atol(dmg), dbcSpell.LookupEntry( atoi( spellId ) ), m_session->GetPlayer());
 
 	std::stringstream sstext;
 	sstext << "generated threat is: " << threat <<'\0';
Index: faction.cpp
===================================================================
--- faction.cpp	(revision 187)
+++ faction.cpp	(working copy)
@@ -1,3 +1,4 @@
+<<<<<<< .mine
 #include "StdAfx.h"
 
 bool isHostile(Object* objA, Object* objB)// B is hostile for A?
@@ -360,3 +361,365 @@
 	return true;
 }
 
+=======
+#include "StdAfx.h"
+
+bool isHostile(Object* objA, Object* objB)// B is hostile for A?
+{
+	if(!objA || !objB)
+		return false;
+	bool hostile = false;
+
+	if(objB->m_faction == NULL || objA->m_faction == NULL)
+		return true;
+
+	if(objA == objB)
+		return false;   // can't attack self.. this causes problems with buffs if we dont have it :p
+
+	if(objA->GetTypeId() == TYPEID_CORPSE)
+		return false;
+
+	if(objB->GetTypeId() == TYPEID_CORPSE)
+		return false;
+
+	uint32 faction = objB->m_faction->Mask;
+	uint32 host = objA->m_faction->HostileMask;
+
+	/*if( faction != 0 )
+	{*/
+		if(faction & host)
+		{
+			hostile = true;
+		}
+	/*}
+	else
+	{
+		// default to true
+		hostile = true;
+	}*/
+
+	// check friend/enemy list
+	for(uint32 i = 0; i < 4; i++)
+	{
+		if(objA->m_faction->EnemyFactions[i] == objB->m_faction->Faction)
+		{
+			hostile = true;
+			break;
+		}
+		if(objA->m_faction->FriendlyFactions[i] == objB->m_faction->Faction)
+		{
+			hostile = false;
+			break;
+		}
+	}
+
+	// PvP Flag System Checks
+	// We check this after the normal isHostile test, that way if we're
+	// on the opposite team we'll already know :p
+
+	if(hostile && 
+		( objA->IsPlayer() || objA->IsPet() || ( objA->IsUnit() && !objA->IsPlayer() && static_cast<Creature *>(objA)->IsTotem() && static_cast<Creature *>(objA)->GetTotemOwner()->IsPvPFlagged() ) ) )
+	{
+		if(objB->IsPlayer())
+		{
+			// Check PvP Flags.
+			if(static_cast<Player*>(objB)->IsPvPFlagged())
+				return true;
+			else
+				return false;
+		}
+		if(objB->IsPet())
+		{
+			// Check PvP Flags.
+			if(static_cast<Pet*>(objB)->GetPetOwner() && static_cast<Pet*>(objB)->GetPetOwner()->IsPvPFlagged() && static_cast<Pet*>(objB)->GetPetOwner()->GetMapMgr() == objB->GetMapMgr())
+				return true;
+			else
+				return false;
+		}
+	}
+
+	// Reputation System Checks
+	if(objA->IsPlayer() && !objB->IsPlayer())	   // PvE
+	{
+		if(objB->m_factionDBC->RepListId >= 0)
+			hostile = static_cast< Player* >( objA )->IsHostileBasedOnReputation( objB->m_factionDBC );
+	}
+	
+	if(objB->IsPlayer() && !objA->IsPlayer())	   // PvE
+	{
+		if(objA->m_factionDBC->RepListId >= 0)
+			hostile = static_cast< Player* >( objB )->IsHostileBasedOnReputation( objA->m_factionDBC );
+	}
+
+	return hostile;
+}
+
+/// Where we check if we object A can attack object B. This is used in many feature's
+/// Including the spell class and the player class.
+bool isAttackable(Object* objA, Object* objB, bool CheckStealth)// A can attack B?
+{
+	if(!objA || !objB || objB->m_factionDBC == NULL || objA->m_factionDBC == NULL)
+		return false;
+
+	if(objB->m_faction == NULL || objA->m_faction == NULL )
+		return true;
+
+	if(objA == objB)
+		return false;   // can't attack self.. this causes problems with buffs if we don't have it :p
+
+	if(objA->GetTypeId() == TYPEID_CORPSE)
+		return false;
+
+	if(objB->GetTypeId() == TYPEID_CORPSE)
+		return false;
+	
+	// Players in feign death flags can't be attacked
+	if(objA->IsPlayer())
+		if(objA->HasFlag(UNIT_FIELD_FLAGS_2, 0x00000001))
+			return false;
+	if(objB->IsPlayer())
+		if(objB->HasFlag(UNIT_FIELD_FLAGS_2, 0x00000001))
+			return false;
+
+	// Checks for untouchable, unattackable
+	if(objA->IsUnit() && objA->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_ATTACKABLE_9 | UNIT_FLAG_MOUNTED_TAXI | UNIT_FLAG_NOT_SELECTABLE))
+		return false;
+	if(objB->IsUnit())
+	{
+		if(objB->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_ATTACKABLE_9 | UNIT_FLAG_MOUNTED_TAXI | UNIT_FLAG_NOT_SELECTABLE))
+			return false;
+
+		/// added by Zack : 
+        /// we cannot attack sheathed units. Maybe checked in other places too ?
+		/// !! warning, this presumes that objA is attacking ObjB
+        /// Capt: Added the possibility to disregard this (regarding the spell class)
+		if(static_cast<Unit *>(objB)->IsStealth() && CheckStealth)
+			return false;
+	}
+
+	if(objA->IsPlayer() && objB->IsPlayer())
+	{
+		if(
+			static_cast<Player *>(objA)->DuelingWith == static_cast<Player *>(objB) && 
+			static_cast<Player *>(objA)->GetDuelState() == DUEL_STATE_STARTED
+			)
+		return true;
+
+		if(objA->HasFlag(PLAYER_FLAGS,PLAYER_FLAG_FREE_FOR_ALL_PVP) && objB->HasFlag(PLAYER_FLAGS,PLAYER_FLAG_FREE_FOR_ALL_PVP))
+		{
+			if(static_cast<Player*>(objA)->m_bg != NULL)
+				if(static_cast<Player*>(objA)->GetGroup() == static_cast<Player*>(objB)->GetGroup())
+					return false;
+
+			return true;		// can hurt each other in FFA pvp
+		}
+	}
+	
+	// handle for pets in duel
+	if(objA->IsPet())
+	{
+		if(objB->IsPlayer())
+			if(
+				static_cast<Pet *>(objA)->GetPetOwner() &&
+				static_cast<Pet *>(objA)->GetPetOwner()->DuelingWith == static_cast<Player *>(objB) && 
+				static_cast<Pet *>(objA)->GetPetOwner()->GetDuelState() == DUEL_STATE_STARTED
+				)
+				return true;
+		if(objB->IsPet())
+			if(static_cast<Pet *>(objA)->GetPetOwner() &&
+				static_cast<Pet *>(objB)->GetPetOwner() &&
+				static_cast<Pet *>(objA)->GetPetOwner()->DuelingWith == static_cast<Pet *>(objB)->GetPetOwner() && 
+				static_cast<Pet *>(objA)->GetPetOwner()->GetDuelState() == DUEL_STATE_STARTED
+				)
+				return true;
+	}
+	if(objB->IsPet())
+	{
+		if(objA->IsPlayer())
+			if(
+				static_cast<Pet*>(objB)->GetPetOwner() && static_cast<Pet *>(objB)->GetPetOwner() &&
+				static_cast<Pet *>(objB)->GetPetOwner()->DuelingWith == static_cast<Player *>(objA) && 
+				static_cast<Pet *>(objB)->GetPetOwner()->GetDuelState() == DUEL_STATE_STARTED
+				)
+				return true;
+		else if(objA->IsPet())
+			if(static_cast<Pet*>(objA)->GetPetOwner() && static_cast<Pet *>(objB)->GetPetOwner() &&
+				static_cast<Pet*>(objB)->GetPetOwner() &&
+				static_cast<Pet *>(objB)->GetPetOwner()->DuelingWith == static_cast<Pet *>(objA)->GetPetOwner() && 
+				static_cast<Pet *>(objB)->GetPetOwner()->GetDuelState() == DUEL_STATE_STARTED
+				)
+				return true;
+	}
+
+	// handle for totems
+	if(objA->IsUnit() && !objA->IsPlayer()) // must be creature
+	{
+		if(static_cast<Creature *>(objA)->IsTotem())
+		{
+			if(objB->IsPlayer())
+				if( static_cast<Creature *>(objA)->GetTotemOwner() &&
+					static_cast<Creature *>(objA)->GetTotemOwner()->DuelingWith == static_cast<Player *>(objB) && 
+					static_cast<Creature *>(objA)->GetTotemOwner()->GetDuelState() == DUEL_STATE_STARTED
+					)
+					return true;
+			if(objB->IsPet())
+				if( static_cast<Creature *>(objA)->GetTotemOwner() &&
+					static_cast<Creature *>(objA)->GetTotemOwner()->DuelingWith == static_cast<Pet *>(objB)->GetPetOwner() && 
+					static_cast<Creature *>(objA)->GetTotemOwner()->GetDuelState() == DUEL_STATE_STARTED
+					)
+					return true;
+		}
+	}
+	if(objB->IsUnit() && !objB->IsPlayer()) // must be creature
+	{
+		if(static_cast<Creature *>(objB)->IsTotem())
+		{
+			if(objA->IsPlayer())
+				if( static_cast<Creature *>(objB)->GetTotemOwner() &&
+					static_cast<Creature *>(objB)->GetTotemOwner()->DuelingWith == static_cast<Player *>(objA) && 
+					static_cast<Creature *>(objB)->GetTotemOwner()->GetDuelState() == DUEL_STATE_STARTED
+					)
+					return true;
+			if(objA->IsPet())
+				if( static_cast<Creature *>(objB)->GetTotemOwner() &&
+					static_cast<Creature *>(objB)->GetTotemOwner()->DuelingWith == static_cast<Pet *>(objA)->GetPetOwner() && 
+					static_cast<Creature *>(objB)->GetTotemOwner()->GetDuelState() == DUEL_STATE_STARTED
+					)
+					return true;
+		}
+	}
+
+	// do not let people attack each other in sanctuary
+	// Dueling is already catered for
+	AreaTable *atA;
+	AreaTable *atB;
+	if(objA->IsPet() && ((Pet*)objA)->GetPetOwner())
+		atA = dbcArea.LookupEntry(static_cast<Pet *>(objA)->GetPetOwner()->GetAreaID());
+	else if (objA->IsPlayer())
+		atA = dbcArea.LookupEntry(static_cast<Player *>(objA)->GetAreaID());
+	else
+		atA = NULL;
+
+	if(objB->IsPet() && ((Pet*)objB)->GetPetOwner())
+		atB = dbcArea.LookupEntry(static_cast<Pet *>(objB)->GetPetOwner()->GetAreaID());
+	else if (objB->IsPlayer())
+		atB = dbcArea.LookupEntry(static_cast<Player *>(objB)->GetAreaID());
+	else
+		atB = NULL;
+
+	// We have the area codes
+	// We know they aren't dueling
+	if (atA && atB)
+	{
+		if(atA->AreaFlags & 0x800 || atB->AreaFlags & 0x800)
+			return false;
+	}
+
+	if(objA->m_faction == objB->m_faction)  // same faction can't kill each other unless in ffa pvp/duel
+		return false;
+
+	bool attackable = isHostile(objA, objB); // B is attackable if its hostile for A
+	/*if((objA->m_faction->HostileMask & 8) && (objB->m_factionDBC->RepListId != 0) && 
+		(objB->GetTypeId() != TYPEID_PLAYER) && objB->m_faction->Faction != 31) // B is attackable if its a neutral Creature*/
+
+	// Neutral Creature Check
+	if(objA->IsPlayer() || objA->IsPet())
+	{
+		if(objB->m_factionDBC->RepListId == -1 && objB->m_faction->HostileMask == 0 && objB->m_faction->FriendlyMask == 0)
+		{
+			attackable = true;
+		}
+	}
+	else if(objB->IsPlayer() || objB->IsPet())
+	{
+		if(objA->m_factionDBC->RepListId == -1 && objA->m_faction->HostileMask == 0 && objA->m_faction->FriendlyMask == 0)
+		{
+			attackable = true;
+		}
+	}
+
+	return attackable;
+}
+
+bool isCombatSupport(Object* objA, Object* objB)// B combat supports A?
+{
+	if(!objA || !objB)
+		return false;
+
+	if(objA->GetTypeId() == TYPEID_CORPSE)
+		return false;
+
+	if(objB->GetTypeId() == TYPEID_CORPSE)
+		return false;
+
+	if(objB->m_faction == 0 || objA->m_faction == 0)
+		return false;
+
+	bool combatSupport = false;
+
+	uint32 fSupport = objB->m_faction->FriendlyMask;
+	uint32 myFaction = objA->m_faction->Mask;
+
+	if(myFaction & fSupport)
+	{
+		combatSupport = true;
+	}
+	// check friend/enemy list
+	for(uint32 i = 0; i < 4; i++)
+	{
+		if(objB->m_faction->EnemyFactions[i] == objA->m_faction->Faction)
+		{
+			combatSupport = false;
+			break;
+		}
+		if(objB->m_faction->FriendlyFactions[i] == objA->m_faction->Faction)
+		{
+			combatSupport = true;
+			break;
+		}
+	}
+	return combatSupport;
+}
+
+
+bool isAlliance(Object* objA)// A is alliance?
+{
+	FactionTemplateDBC * m_sw_faction = dbcFactionTemplate.LookupEntry(11);
+	FactionDBC * m_sw_factionDBC = dbcFaction.LookupEntry(72);
+	if(!objA || objA->m_factionDBC == NULL || objA->m_faction == NULL)
+		return true;
+
+	if(m_sw_faction == objA->m_faction || m_sw_factionDBC == objA->m_factionDBC)
+		return true;
+
+	//bool hostile = false;
+	uint32 faction = m_sw_faction->Faction;
+	uint32 host = objA->m_faction->HostileMask;
+
+	if(faction & host)
+		return false;
+
+	// check friend/enemy list
+	for(uint32 i = 0; i < 4; i++)
+	{
+		if(objA->m_faction->EnemyFactions[i] == faction)
+			return false;
+	}
+
+	faction = objA->m_faction->Faction;
+	host = m_sw_faction->HostileMask;
+
+	if(faction & host)
+		return false;
+
+	// check friend/enemy list
+	for(uint32 i = 0; i < 4; i++)
+	{
+		if(objA->m_faction->EnemyFactions[i] == faction)
+			return false;
+	}
+
+	return true;
+}
+
+>>>>>>> .r3443
Index: Group.cpp
===================================================================
--- Group.cpp	(revision 187)
+++ Group.cpp	(working copy)
@@ -721,7 +721,7 @@
 		for(int j = 0; j < 5; ++j)
 		{
 			uint32 guid = fields[9 + (i*5) + j].GetUInt32();
-			if(guid==NULL)
+			if( guid == 0 )
 				continue;
 
 			PlayerInfo * inf = objmgr.GetPlayerInfo(guid);
Index: Item.cpp
===================================================================
--- Item.cpp	(revision 187)
+++ Item.cpp	(working copy)
@@ -68,6 +68,8 @@
 
 	if(IsInWorld())
 		RemoveFromWorld();
+
+	m_owner = NULL;
 }
 
 void Item::Create( uint32 itemid, Player *owner )
Index: Item.h
===================================================================
--- Item.h	(revision 187)
+++ Item.h	(working copy)
@@ -65,11 +65,12 @@
 	
 	ASCENT_INLINE void SoulBind()
 	{
-		this->SetFlag(ITEM_FIELD_FLAGS,1);
+		this->SetFlag( ITEM_FIELD_FLAGS, ITEM_FLAG_SOULBOUND );
 	}
+
 	ASCENT_INLINE bool IsSoulbound()
 	{
-		return HasFlag(ITEM_FIELD_FLAGS, 1);
+		return this->HasFlag( ITEM_FIELD_FLAGS, ITEM_FLAG_QUEST | ITEM_FLAG_SOULBOUND );
 	}
 
 	ASCENT_INLINE uint32 GetChargesLeft()
Index: ItemHandler.cpp
===================================================================
--- ItemHandler.cpp	(revision 187)
+++ ItemHandler.cpp	(working copy)
@@ -371,7 +371,7 @@
 	bool skip_combat = false;
 	if( srcslot < EQUIPMENT_SLOT_END || dstslot < EQUIPMENT_SLOT_END )	  // We're doing an equip swap.
 	{
-		if(_player->CombatStatus.IsInCombat())
+		if( _player->CombatStatus.IsInCombat() )
 		{
 			if( srcslot < EQUIPMENT_SLOT_MAINHAND || dstslot < EQUIPMENT_SLOT_MAINHAND )	// These can't be swapped
 			{
@@ -382,23 +382,23 @@
 		}
 	}
 
-	if (!srcitem)
+	if( !srcitem )
 	{
-		_player->GetItemInterface()->BuildInventoryChangeError(srcitem,dstitem,INV_ERR_YOU_CAN_NEVER_USE_THAT_ITEM);
+		_player->GetItemInterface()->BuildInventoryChangeError( srcitem, dstitem, INV_ERR_YOU_CAN_NEVER_USE_THAT_ITEM );
 		return;
 	}
 
-	if (srcslot == dstslot)
+	if( srcslot == dstslot )
 	{
-		_player->GetItemInterface()->BuildInventoryChangeError(srcitem,dstitem, INV_ERR_ITEM_DOESNT_GO_TO_SLOT);
+		_player->GetItemInterface()->BuildInventoryChangeError( srcitem, dstitem, INV_ERR_ITEM_DOESNT_GO_TO_SLOT );
 		return;
 	}
 	
-	if((error=_player->GetItemInterface()->CanEquipItemInSlot(INVENTORY_SLOT_NOT_SET, dstslot, srcitem->GetProto(), skip_combat)))
+	if( ( error = _player->GetItemInterface()->CanEquipItemInSlot( INVENTORY_SLOT_NOT_SET, dstslot, srcitem->GetProto(), skip_combat ) ) )
 	{
-		if(dstslot < INVENTORY_KEYRING_END)
+		if( dstslot < INVENTORY_KEYRING_END )
 		{
-			_player->GetItemInterface()->BuildInventoryChangeError(srcitem,dstitem, error);
+			_player->GetItemInterface()->BuildInventoryChangeError( srcitem, dstitem, error );
 			return;
 		}
 	}
@@ -1737,14 +1737,14 @@
 	}
 	else
 	{
-		if(slotresult.ContainerSlot == INVENTORY_SLOT_NOT_SET)
+		if( slotresult.ContainerSlot == INVENTORY_SLOT_NOT_SET )
 		{
 			_player->GetItemInterface()->SwapItemSlots(SrcSlot, slotresult.Slot);
 		}
 		else
 		{
-				eitem = _player->GetItemInterface()->SafeRemoveAndRetreiveItemFromSlot(SrcInvSlot, SrcSlot, false);
-				result = _player->GetItemInterface()->AddItemToFreeSlot(eitem);
+			eitem = _player->GetItemInterface()->SafeRemoveAndRetreiveItemFromSlot(SrcInvSlot, SrcSlot, false);
+			result = _player->GetItemInterface()->AddItemToFreeSlot(eitem);
 		}
 	}
 }
@@ -1768,13 +1768,7 @@
 	GemPropertyEntry * gp;
 	EnchantEntry * Enchantment;
 	recvPacket >> itemguid ;
-	enum {
-		GEM_META_SOCKET =	1,
-		GEM_RED_SOCKET =	2,
-		GEM_YELLOW_SOCKET =	4,
-		GEM_BLUE_SOCKET	=	8
-	};
-	
+
 	Item * TargetItem =_player->GetItemInterface()->GetItemByGUID(itemguid);
 	if(!TargetItem)
 		return;
@@ -1829,7 +1823,6 @@
 		}
 	}
 
-
 	//Add color match bonus
 	if(TargetItem->GetProto()->SocketBonus)
 	{
Index: ItemInterface.cpp
===================================================================
--- ItemInterface.cpp	(revision 187)
+++ ItemInterface.cpp	(working copy)
@@ -36,7 +36,7 @@
 {
 	for(int i = 0; i < MAX_INVENTORY_SLOT; i++)
 	{
-		if( m_pItems[i] != NULL )
+		if( m_pItems[i] != NULL && m_pItems[i]->GetOwner() == m_pOwner )
 		{
 			if( m_pItems[i]->IsContainer() )
 			{
@@ -186,9 +186,46 @@
 {
 	ASSERT(slot < MAX_INVENTORY_SLOT);
 	ASSERT(ContainerSlot < MAX_INVENTORY_SLOT);
-	ASSERT(item != NULL);
+	if( item == NULL || !item->GetProto() )
+		return false;
+
 	item->m_isDirty = true;
 
+	// doublechecking
+	/*uint32 i, j, k;
+	Item * tempitem;
+	for(i = 0; i < MAX_INVENTORY_SLOT; ++i)
+	{
+		tempitem = m_pItems[i];
+		if( tempitem != NULL )
+		{
+			if( tempitem == item )
+			{
+				OutputCrashLogLine("item duplication, callstack:");
+				printf("item duplication, callstack: ");
+				CStackWalker ws;
+				ws.ShowCallstack();
+				return false;
+			}
+
+			if( tempitem->IsContainer() )
+			{
+				k = tempitem->GetProto()->ContainerSlots;
+				for(j = 0; j < k; ++j)
+				{
+					if( static_cast<Container*>(tempitem)->GetItem( j ) == item )
+					{
+						OutputCrashLogLine("item duplication in container, callstack:");
+						printf("item duplication in container, callstack: ");
+						CStackWalker ws;
+						ws.ShowCallstack();
+						return false;
+					}
+				}
+			}
+		}
+	}*/
+
 	if(item->GetProto())
 	{
 		//case 1, item is from backpack container
@@ -334,33 +371,38 @@
 		}
 
 		m_pItems[(int)slot] = NULL;
-		pItem->m_isDirty = true;
+		if(pItem->GetOwner() == m_pOwner)
+		{
+			pItem->m_isDirty = true;
 
-		m_pOwner->SetUInt64Value(PLAYER_FIELD_INV_SLOT_HEAD  + (slot*2), 0 );
+			m_pOwner->SetUInt64Value(PLAYER_FIELD_INV_SLOT_HEAD  + (slot*2), 0 );
 
-		if ( slot < EQUIPMENT_SLOT_END )
-		{
-			m_pOwner->ApplyItemMods( pItem, slot, false );
-			int VisibleBase = PLAYER_VISIBLE_ITEM_1_0 + (slot * 16);
-			for (int i = VisibleBase; i < VisibleBase + 12; ++i)
+			if ( slot < EQUIPMENT_SLOT_END )
 			{
-				m_pOwner->SetUInt32Value(i, 0);
+				m_pOwner->ApplyItemMods( pItem, slot, false );
+				int VisibleBase = PLAYER_VISIBLE_ITEM_1_0 + (slot * 16);
+				for (int i = VisibleBase; i < VisibleBase + 12; ++i)
+				{
+					m_pOwner->SetUInt32Value(i, 0);
+				}
 			}
-		}
-		else if ( slot < INVENTORY_SLOT_BAG_END )
-			m_pOwner->ApplyItemMods( pItem, slot, false );
+			else if ( slot < INVENTORY_SLOT_BAG_END )
+				m_pOwner->ApplyItemMods( pItem, slot, false );
 
-		if(slot == EQUIPMENT_SLOT_OFFHAND)
-			m_pOwner->SetDuelWield(false);
+			if(slot == EQUIPMENT_SLOT_OFFHAND)
+				m_pOwner->SetDuelWield(false);
 
-		if(destroy)
-		{
-			if (pItem->IsInWorld())
+			if(destroy)
 			{
-				pItem->RemoveFromWorld();
+				if (pItem->IsInWorld())
+				{
+					pItem->RemoveFromWorld();
+				}
+				pItem->DeleteFromDB();
 			}
-			pItem->DeleteFromDB();
 		}
+		else
+			pItem = NULL;
 	}
 	else
 	{
@@ -491,32 +533,36 @@
 		}
 
 		m_pItems[(int)slot] = NULL;
-		pItem->m_isDirty = true;
+		// hacky crashfix
+		if( pItem->GetOwner() == m_pOwner )
+		{
+			pItem->m_isDirty = true;
 
-		m_pOwner->SetUInt64Value(PLAYER_FIELD_INV_SLOT_HEAD  + (slot*2), 0 );
+			m_pOwner->SetUInt64Value(PLAYER_FIELD_INV_SLOT_HEAD  + (slot*2), 0 );
 
-		if ( slot < EQUIPMENT_SLOT_END )
-		{
-			m_pOwner->ApplyItemMods(pItem, slot, false );
-			int VisibleBase = PLAYER_VISIBLE_ITEM_1_0 + (slot * 16);
-			for (int i = VisibleBase; i < VisibleBase + 12; ++i)
+			if ( slot < EQUIPMENT_SLOT_END )
 			{
-				m_pOwner->SetUInt32Value(i, 0);
+				m_pOwner->ApplyItemMods(pItem, slot, false );
+				int VisibleBase = PLAYER_VISIBLE_ITEM_1_0 + (slot * 16);
+				for (int i = VisibleBase; i < VisibleBase + 12; ++i)
+				{
+					m_pOwner->SetUInt32Value(i, 0);
+				}
 			}
-		}
-		else if( slot < INVENTORY_SLOT_BAG_END )
-			m_pOwner->ApplyItemMods(pItem, slot, false ); //watch containers that give attackspeed and stuff ;)
+			else if( slot < INVENTORY_SLOT_BAG_END )
+				m_pOwner->ApplyItemMods(pItem, slot, false ); //watch containers that give attackspeed and stuff ;)
 
-		if(slot == EQUIPMENT_SLOT_OFFHAND)
-			m_pOwner->SetDuelWield(false);
+			if(slot == EQUIPMENT_SLOT_OFFHAND)
+				m_pOwner->SetDuelWield(false);
 
-		if (pItem->IsInWorld())
-		{
-			pItem->RemoveFromWorld();
+			if (pItem->IsInWorld())
+			{
+				pItem->RemoveFromWorld();
+			}
+
+			pItem->DeleteFromDB();
+			delete pItem;
 		}
-
-		pItem->DeleteFromDB();
-		delete pItem;
 	}
 	else
 	{
@@ -1093,21 +1139,27 @@
 //-------------------------------------------------------------------//
 bool ItemInterface::AddItemToFreeSlot(Item *item)
 {
-	if(!item) { return false; }
+	if( item == NULL )
+		return false;
+
+	if( item->GetProto() == NULL )
+		return false;
+
 	uint32 i = 0;
 	bool result2;
 
 	//detect special bag item
-	if(item->GetProto()->BagFamily)
+	if( item->GetProto()->BagFamily )
 	{
-		if(item->GetProto()->BagFamily == ITEM_TYPE_KEYRING)
+		if( item->GetProto()->BagFamily == ITEM_TYPE_KEYRING )
 		{
-			for(i=INVENTORY_KEYRING_START; i<INVENTORY_KEYRING_END; i++)
+			for(i=INVENTORY_KEYRING_START; i<INVENTORY_KEYRING_END; i++ )
 			{
 				if(m_pItems[i] == NULL)
 				{
-					result2 = SafeAddItem(item, INVENTORY_SLOT_NOT_SET, i);
-					if(result2) {
+					result2 = SafeAddItem( item, INVENTORY_SLOT_NOT_SET, i );
+					if( result2 )
+					{
 						result.ContainerSlot = INVENTORY_SLOT_NOT_SET;
 						result.Slot = i;
 						result.Result = true;
@@ -2380,14 +2432,31 @@
 				m_pOwner->SetUInt32Value(VisibleBase + 8, 0);
 			}
 		}
-	}  
-	if(dstslot == EQUIPMENT_SLOT_OFFHAND || srcslot == EQUIPMENT_SLOT_OFFHAND)
+	}
+
+	if( dstslot == EQUIPMENT_SLOT_OFFHAND || srcslot == EQUIPMENT_SLOT_OFFHAND )
 	{
-		if(m_pItems[EQUIPMENT_SLOT_OFFHAND] != 0 && m_pItems[EQUIPMENT_SLOT_OFFHAND]->GetProto()->Class == ITEM_CLASS_WEAPON)
-			m_pOwner->SetDuelWield(true);
+		if( m_pItems[EQUIPMENT_SLOT_OFFHAND] != NULL && m_pItems[EQUIPMENT_SLOT_OFFHAND]->GetProto()->Class == ITEM_CLASS_WEAPON )
+			m_pOwner->SetDuelWield( true );
 		else
-			m_pOwner->SetDuelWield(false);
+			m_pOwner->SetDuelWield( false );
 	}
+
+	// Reapply weapon mods immediately to prevent exploit
+	if( ( dstslot >= EQUIPMENT_SLOT_MAINHAND && dstslot <= EQUIPMENT_SLOT_RANGED ) || ( srcslot >= EQUIPMENT_SLOT_MAINHAND && srcslot <= EQUIPMENT_SLOT_RANGED ) )
+	{
+		if( m_pItems[dstslot] != NULL )
+		{
+			m_pOwner->ApplyItemMods( m_pItems[dstslot], dstslot, false, false );
+			m_pOwner->ApplyItemMods( m_pItems[dstslot], dstslot, true, false );
+		}
+		if( m_pItems[srcslot] != NULL )
+		{
+			m_pOwner->ApplyItemMods( m_pItems[srcslot], srcslot, false, false );
+			m_pOwner->ApplyItemMods( m_pItems[srcslot], srcslot, true, false );
+		}
+	}
+
 }
 
 //-------------------------------------------------------------------//
Index: ItemPrototype.h
===================================================================
--- ItemPrototype.h	(revision 187)
+++ ItemPrototype.h	(working copy)
@@ -21,6 +21,11 @@
 #define _ITEMPROTOTYPE_H
 class Spell;
 
+#define GEM_META_SOCKET 1
+#define GEM_RED_SOCKET 2
+#define GEM_YELLOW_SOCKET 4
+#define GEM_BLUE_SOCKET 8
+
 #define MAX_INVENTORY_SLOT 118
 #define MAX_BUYBACK_SLOT 12
 
Index: Level1.cpp
===================================================================
--- Level1.cpp	(revision 187)
+++ Level1.cpp	(working copy)
@@ -429,16 +429,17 @@
 	}
 
 	Player *chr = getSelectedChar(m_session);
-	if (chr == NULL) return true;
+	if( chr == NULL )
+		return true;
 	
 	char buf[256];
 
 	// send message to user
-	BlueSystemMessage(m_session, "You set the speed to %2.2f of %s.", Speed, chr->GetName());
+	BlueSystemMessage(m_session, "You set the speed of %s to %2.2f.", chr->GetName(), Speed);
 
 	// send message to player
 	snprintf((char*)buf,256, "%s set your speed to %2.2f.", m_session->GetPlayer()->GetName(), Speed);
-   SystemMessage(m_session, buf);
+	SystemMessage(chr->GetSession(), buf);
 
 	chr->SetPlayerSpeed(RUN, Speed);
 	chr->SetPlayerSpeed(SWIM, Speed);
@@ -624,34 +625,59 @@
 
 bool ChatHandler::HandleModifyGoldCommand(const char* args, WorldSession *m_session)
 {
-	WorldPacket data;
+//	WorldPacket data;
 
-	if (!*args)
+	if ( *args == NULL )
 		return false;
 
-	int32 gold = atoi((char*)args);
+	Player *chr = getSelectedChar( m_session, true );
+	if( chr == NULL ) return true;
 
-	Player *chr = getSelectedChar(m_session, true);
-	if(!chr) return true;
+	int32 total   = atoi( (char*)args );
+
+	// gold = total / 10000;
+	// silver = (total / 100) % 100;
+	// copper = total % 100;
+	uint32 gold   = (uint32) floor( (float)int32abs( total ) / 10000.0f );
+	uint32 silver = (uint32) floor( ((float)int32abs( total ) / 100.0f) ) % 100;
+	uint32 copper = int32abs2uint32( total ) % 100;
 	
-	sGMLog.writefromsession(m_session, "used modify gold on %s, gold: %u", chr->GetName(), gold);
-	BlueSystemMessage(m_session, "Adding %d gold to %s's backpack...", gold, chr->GetName());
+	sGMLog.writefromsession( m_session, "used modify gold on %s, gold: %d", chr->GetName(), total );
 
-	int32 currentgold = chr->GetUInt32Value(PLAYER_FIELD_COINAGE);
-	int32 newgold = currentgold + gold;
+	int32 newgold = chr->GetUInt32Value( PLAYER_FIELD_COINAGE ) + total;
 
 	if(newgold < 0)
 	{
+		BlueSystemMessage( m_session, "Taking all gold from %s's backpack...", chr->GetName() );
 		GreenSystemMessageToPlr(chr, "%s took the all gold from your backpack.", m_session->GetPlayer()->GetName());
 		newgold = 0;
-	} else {
-		if(newgold > currentgold)
-			GreenSystemMessageToPlr(chr, "%s added %d gold to your backpack.", m_session->GetPlayer()->GetName(), myabs(gold));
+	}
+	else
+	{
+		if(total >= 0) {
+			BlueSystemMessage( m_session,
+				"Adding %u gold, %u silver, %u copper to %s's backpack...",
+				gold, silver, copper,
+				chr->GetName() );
+
+			GreenSystemMessageToPlr( chr, "%s added %u gold, %u silver, %u copper to your backpack.",
+				m_session->GetPlayer()->GetName(),
+				gold, silver, copper );
+		}
 		else
-			GreenSystemMessageToPlr(chr, "%s took %d gold from your backpack.", m_session->GetPlayer()->GetName(), myabs(gold));
+		{
+			BlueSystemMessage( m_session,
+				"Taking %u gold, %u silver, %u copper from %s's backpack...",
+				gold, silver, copper,
+				chr->GetName() );
+
+			GreenSystemMessageToPlr( chr, "%s took %u gold, %u silver, %u copper from your backpack.",
+				m_session->GetPlayer()->GetName(),
+				gold, silver, copper );
+		}
 	}
 
-	chr->SetUInt32Value(PLAYER_FIELD_COINAGE, newgold);
+	chr->SetUInt32Value( PLAYER_FIELD_COINAGE, newgold );
 	
 	return true;
 }
@@ -734,3 +760,4 @@
 
 
 
+
Index: Level3.cpp
===================================================================
--- Level3.cpp	(revision 187)
+++ Level3.cpp	(working copy)
@@ -151,10 +151,10 @@
 			{ 750, 1020, 1038, 1044, 1152, 3127, 4987, 5502, 5573, 7620, 10278, 10308, 10322, 10324, 10326, 19746, 19752, 20271, 20347, 20348, 20356, 20772, 20773, 25780, 25895, 25898, 27136, 27137, 27138, 27139, 27140, 27141, 27142, 27143, 27144, 27145, 27148, 27149, 27150, 27151, 27152, 27153, 27154, 27155, 27158, 27169, 27173, 27180, 31789, 31801, 31884, 31895, 32223, 33388, 33391, 33776, 34090, 34091, 0 },		// CLASS 2
 			{ 136, 674, 781, 883, 982, 1002, 1130, 1462, 1494, 1495, 1499, 1510, 1513, 1515, 1543, 1978, 2641, 2643, 2974, 3018, 3034, 3043, 3044, 3045, 3111, 3127, 3661, 3662, 5116, 5118, 5384, 6197, 6991, 13159, 13161, 13163, 13165, 13542, 13543, 13544, 13549, 13550, 13551, 13552, 13553, 13554, 13555, 13795, 13809, 13813, 14260, 14261, 14262, 14263, 14264, 14265, 14266, 14267, 14268, 14269, 14270, 14271, 14272, 14273, 14274, 14279, 14280, 14281, 14282, 14283, 14284, 14285, 14286, 14287, 14288, 14289, 14290, 14294, 14295, 14302, 14303, 14304, 14305, 14310, 14311, 14316, 14317, 14318, 14319, 14320, 14321, 14322, 14323, 14324, 14325, 14326, 14327, 15629, 15630, 15631, 15632, 19801, 19878, 19879, 19880, 19882, 19883, 19884, 19885, 20043, 20190, 20736, 25294, 25295, 25296, 27014, 27015, 27016, 27018, 27019, 27020, 27021, 27022, 27023, 27025, 27044, 27045, 27046, 34026, 34074, 34120, 34477, 34600, 36916, 0 },		// CLASS 3
 			{ 674, 921, 1725, 1787, 1804, 1833, 1842, 1860, 2094, 2836, 2842, 3127, 5938, 6774, 8643, 8681, 11297, 11305, 26669, 26679, 26862, 26863, 26865, 26866, 26867, 26884, 26889, 27441, 27448, 31224, 32684, 38764, 38768, 0 },		// CLASS 4
-			{ 17, 139, 453, 527, 528, 552, 586, 588, 589, 591, 592, 594, 596, 598, 600, 602, 605, 970, 976, 984, 988, 992, 996, 1004, 1006, 1243, 1244, 1245, 1706, 2006, 2010, 2052, 2053, 2054, 2055, 2060, 2061, 2096, 2767, 2791, 3747, 6060, 6063, 6064, 6065, 6066, 6074, 6075, 6076, 6077, 6078, 7128, 8092, 8102, 8103, 8104, 8105, 8106, 8122, 8124, 8129, 8131, 8192, 9472, 9473, 9474, 9484, 9485, 9578, 9579, 9592, 10797, 10874, 10875, 10876, 10880, 10881, 10888, 10890, 10892, 10893, 10894, 10898, 10899, 10900, 10901, 10909, 10911, 10912, 10915, 10916, 10917, 10927, 10928, 10929, 10933, 10934, 10937, 10938, 10941, 10942, 10945, 10946, 10947, 10951, 10952, 10953, 10955, 10957, 10960, 10961, 10963, 10964, 10965, 14914, 15261, 15262, 15263, 15264, 15265, 15266, 15267, 19289, 19291, 19292, 19293, 19296, 19299, 19302, 19303, 19304, 19305, 20770, 25210, 25213, 25217, 25218, 25221, 25222, 25233, 25235, 25308, 25314, 25315, 25316, 25363, 25364, 25367, 25368, 25372, 25375, 25379, 25380, 25384, 25389, 25429, 25431, 25435, 25446, 25450, 25596, 32375, 32379, 32546, 32996, 33076, 34433, 34863, 34864, 34865, 34866, 0 },		// CLASS 5
+			{ 17, 139, 453, 527, 528, 552, 586, 588, 589, 591, 592, 594, 596, 598, 600, 602, 605, 970, 976, 984, 988, 992, 996, 1004, 1006, 1243, 1244, 1245, 1706, 2006, 2010, 2052, 2053, 2054, 2055, 2060, 2061, 2096, 2767, 2791, 3747, 6060, 6063, 6064, 6065, 6066, 6074, 6075, 6076, 6077, 6078, 7128, 8092, 8102, 8103, 8104, 8105, 8106, 8122, 8124, 8129, 8131, 8192, 9472, 9473, 9474, 9484, 9485, 9578, 9579, 9592, 10874, 10875, 10876, 10880, 10881, 10888, 10890, 10892, 10893, 10894, 10898, 10899, 10900, 10901, 10909, 10911, 10912, 10915, 10916, 10917, 10927, 10928, 10929, 10933, 10934, 10937, 10938, 10941, 10942, 10945, 10946, 10947, 10951, 10952, 10953, 10955, 10957, 10960, 10961, 10963, 10964, 10965, 14914, 15261, 15262, 15263, 15264, 15265, 15266, 15267, 19289, 19291, 19292, 19293, 20770, 25210, 25213, 25217, 25218, 25221, 25222, 25233, 25235, 25308, 25314, 25315, 25316, 25363, 25364, 25367, 25368, 25372, 25375, 25379, 25380, 25384, 25389, 25429, 25431, 25435, 25450, 25596, 32375, 32379, 32546, 32996, 33076, 34433, 34863, 34864, 34865, 34866, 0 },		// CLASS 5
 			{ 0 },		// CLASS 6
 			{ 131, 324, 325, 332, 370, 421, 526, 529, 546, 547, 548, 556, 905, 913, 915, 930, 939, 943, 945, 959, 1064, 1535, 2008, 2484, 2645, 2860, 2870, 3599, 5394, 5675, 5730, 6041, 6196, 6363, 6364, 6365, 6375, 6377, 6390, 6391, 6392, 6495, 8004, 8005, 8008, 8010, 8012, 8017, 8024, 8027, 8030, 8033, 8038, 8042, 8044, 8045, 8046, 8050, 8052, 8053, 8056, 8058, 8071, 8075, 8134, 8143, 8154, 8155, 8160, 8161, 8166, 8170, 8177, 8181, 8184, 8190, 8227, 8232, 8235, 8249, 8498, 8499, 8512, 8835, 10391, 10392, 10395, 10396, 10406, 10407, 10408, 10412, 10413, 10414, 10427, 10428, 10431, 10432, 10437, 10438, 10442, 10447, 10448, 10456, 10462, 10463, 10466, 10467, 10468, 10472, 10473, 10478, 10479, 10486, 10495, 10496, 10497, 10526, 10537, 10538, 10585, 10595, 10600, 10601, 10605, 10613, 10622, 10623, 10627, 11314, 11315, 15107, 15111, 15112, 15207, 15208, 16339, 16341, 16342, 16355, 16356, 16362, 16387, 20608, 20609, 20610, 20776, 20777, 24398, 25357, 25359, 25361, 25391, 25396, 25420, 25422, 25423, 25439, 25442, 25448, 25449, 25454, 25457, 25464, 25469, 25472, 25489, 25500, 25505, 25508, 25509, 25525, 25528, 25533, 25546, 25547, 25557, 25560, 25563, 25567, 25570, 25574, 25577, 25908, 29228, 33736, 36936, 0 },		// CLASS 7
-			{ 10, 66, 116, 118, 120, 122, 130, 143, 145, 205, 475, 543, 587, 597, 604, 759, 837, 865, 990, 1008, 1449, 1459, 1460, 1461, 1463, 1953, 2120, 2121, 2136, 2137, 2138, 2139, 2855, 2948, 3140, 3552, 3563, 3566, 3567, 5143, 5144, 5145, 5504, 5505, 5506, 6117, 6127, 6129, 6131, 6141, 6143, 7300, 7301, 7302, 7320, 7322, 8400, 8401, 8402, 8406, 8407, 8408, 8412, 8413, 8416, 8417, 8422, 8423, 8427, 8437, 8438, 8439, 8444, 8445, 8446, 8450, 8451, 8455, 8457, 8458, 8461, 8462, 8492, 8494, 8495, 10053, 10054, 10138, 10139, 10140, 10144, 10145, 10148, 10149, 10150, 10151, 10156, 10157, 10159, 10160, 10161, 10169, 10170, 10173, 10174, 10177, 10179, 10180, 10181, 10185, 10186, 10187, 10191, 10192, 10193, 10197, 10199, 10201, 10202, 10205, 10206, 10207, 10211, 10212, 10215, 10216, 10219, 10220, 10223, 10225, 10230, 11417, 11418, 11420, 12051, 12824, 12825, 12826, 22782, 22783, 25304, 25306, 25345, 27070, 27071, 27072, 27073, 27074, 27075, 27078, 27079, 27080, 27082, 27085, 27086, 27087, 27088, 27101, 27124, 27125, 27126, 27128, 27130, 27131, 28609, 28612, 30449, 30451, 30455, 30482, 32267, 32272, 32796, 33717, 33944, 33946, 35715, 35717, 37420, 38699, 0 },		// CLASS 8
+			{ 10, 66, 116, 118, 120, 122, 130, 143, 145, 205, 475, 543, 587, 597, 604, 759, 837, 865, 990, 1008, 1449, 1459, 1460, 1461, 1463, 1953, 2120, 2121, 2136, 2137, 2138, 2139, 2855, 2948, 3140, 3552, 5143, 5144, 5145, 5504, 5505, 5506, 6117, 6127, 6129, 6131, 6141, 6143, 7300, 7301, 7302, 7320, 7322, 8400, 8401, 8402, 8406, 8407, 8408, 8412, 8413, 8416, 8417, 8422, 8423, 8427, 8437, 8438, 8439, 8444, 8445, 8446, 8450, 8451, 8455, 8457, 8458, 8461, 8462, 8492, 8494, 8495, 10053, 10054, 10138, 10139, 10140, 10144, 10145, 10148, 10149, 10150, 10151, 10156, 10157, 10159, 10160, 10161, 10169, 10170, 10173, 10174, 10177, 10179, 10180, 10181, 10185, 10186, 10187, 10191, 10192, 10193, 10197, 10199, 10201, 10202, 10205, 10206, 10207, 10211, 10212, 10215, 10216, 10219, 10220, 10223, 10225, 10230, 12051, 12824, 12825, 12826, 22782, 22783, 25304, 25306, 25345, 27070, 27071, 27072, 27073, 27074, 27075, 27078, 27079, 27080, 27082, 27085, 27086, 27087, 27088, 27101, 27124, 27125, 27126, 27128, 27130, 27131, 28609, 28612, 30449, 30451, 30455, 30482, 32796, 33717, 33944, 33946, 37420, 38699, 0 },		// CLASS 8
 			{ 126, 132, 172, 348, 603, 688, 689, 691, 693, 695, 696, 697, 698, 699, 702, 704, 705, 706, 707, 709, 710, 712, 755, 980, 1010, 1014, 1086, 1088, 1094, 1098, 1106, 1108, 1120, 1122, 1454, 1455, 1456, 1490, 1714, 1949, 2362, 2941, 3698, 3699, 3700, 5138, 5484, 5500, 5676, 5697, 5699, 5740, 5782, 5784, 6201, 6202, 6205, 6213, 6215, 6217, 6219, 6222, 6223, 6226, 6229, 6353, 6366, 6789, 7641, 7646, 7648, 7651, 7658, 7659, 8288, 8289, 11659, 11660, 11661, 11665, 11667, 11668, 11671, 11672, 11675, 11677, 11678, 11683, 11684, 11687, 11688, 11689, 11693, 11694, 11695, 11699, 11700, 11703, 11704, 11707, 11708, 11711, 11712, 11713, 11717, 11719, 11721, 11722, 11725, 11726, 11729, 11730, 11733, 11734, 11735, 11739, 11740, 17727, 17728, 17862, 17919, 17920, 17921, 17922, 17923, 17924, 17925, 17926, 17928, 17937, 18540, 18647, 20752, 20755, 20756, 20757, 23161, 25307, 25309, 25311, 27209, 27210, 27211, 27212, 27213, 27215, 27216, 27217, 27218, 27219, 27220, 27221, 27222, 27223, 27224, 27226, 27228, 27229, 27230, 27238, 27243, 27259, 27260, 28172, 28176, 28189, 28610, 29722, 29858, 29893, 30459, 30545, 30908, 30909, 30910, 32231, 0 },		// CLASS 9
 			{ 0 },		// CLASS 10
 			{ 99, 339, 467, 740, 768, 769, 770, 774, 778, 779, 780, 782, 783, 1058, 1062, 1066, 1075, 1079, 1082, 1126, 1178, 1430, 1735, 1822, 1823, 1824, 1850, 2090, 2091, 2637, 2782, 2893, 2908, 2912, 3025, 3029, 3137, 3627, 5177, 5178, 5179, 5180, 5186, 5187, 5188, 5189, 5195, 5196, 5201, 5209, 5211, 5215, 5217, 5221, 5225, 5229, 5232, 5234, 6756, 6778, 6780, 6783, 6785, 6787, 6793, 6795, 6798, 6800, 6807, 6808, 6809, 8903, 8905, 8907, 8910, 8914, 8918, 8921, 8924, 8925, 8926, 8927, 8928, 8929, 8936, 8938, 8939, 8940, 8941, 8946, 8949, 8950, 8951, 8955, 8972, 8983, 8992, 8998, 9005, 9490, 9492, 9493, 9634, 9745, 9747, 9749, 9750, 9752, 9754, 9756, 9758, 9821, 9823, 9827, 9829, 9830, 9833, 9834, 9835, 9839, 9840, 9841, 9845, 9846, 9849, 9850, 9852, 9853, 9856, 9857, 9858, 9862, 9863, 9866, 9867, 9875, 9876, 9880, 9881, 9884, 9885, 9888, 9889, 9894, 9896, 9898, 9901, 9904, 9907, 9908, 9910, 9912, 9913, 16914, 16952, 16954, 16958, 16961, 17401, 17402, 18657, 18658, 18960, 20484, 20719, 20739, 20742, 20747, 20748, 22568, 22570, 22812, 22827, 22828, 22829, 22842, 22895, 22896, 24248, 25297, 25298, 25299, 26978, 26979, 26980, 26981, 26982, 26983, 26984, 26985, 26986, 26987, 26988, 26989, 26990, 26992, 26993, 26994, 26995, 26996, 26997, 26998, 26999, 27000, 27001, 27002, 27003, 27005, 27006, 27008, 27012, 29166, 31018, 33357, 33745, 33763, 33786, 33943, 34090, 0 },		// CLASS 11
@@ -165,6 +165,91 @@
 		{
 			plr->addSpell(spellarray[c][i]);
 		}
+
+		static uint32 paladinspellarray[RACE_DRAENEI+1][2] = {
+			{ 0 },		// RACE 0
+			{ 13819, 0 },		// HUMAN
+			{ 0 },		// ORC
+			{ 13819, 0 },		// DWARF
+			{ 0 },		// NIGHTELF
+			{ 0 },		// UNDEAD
+			{ 0 },		// TAUREN
+			{ 0 },		// GNOME
+			{ 0 },		// TROLL
+			{ 34769, 0 },		// BLOODELF
+			{ 13819, 0 },		// DRAENEI
+		};
+
+		static uint32 priestspellarray[RACE_DRAENEI+1][16] = {
+			{ 0 },		// RACE 0
+			{ 13896, 13908, 19236, 19238, 19240, 19241, 19242, 19243, 19271, 19273, 19274, 19275, 25437, 25441, 0 },		// HUMAN
+			{ 0 },		// ORC
+			{ 13908, 19236, 19238, 19240, 44041, 19241, 19242, 19243, 25437, 44043, 44044, 44045, 44046, 44047, 0 },		// DWARF
+			{ 2651, 10797, 19296, 19299, 19302, 19303, 19304, 19305, 25446, 0 },		// NIGHTELF
+			{ 2652, 2944, 19261, 19262, 19264, 19265, 19266, 19276, 19277, 19278, 19279, 19280, 25461, 25467, 0 },		// UNDEAD
+			{ 0 },		// TAUREN
+			{ 0 },		// GNOME
+			{ 9035, 18137, 19281, 19282, 19283, 19284, 19285, 19308, 19309, 19310, 19311, 19312, 25470, 25477, 0 },		// TROLL
+			{ 2652, 19261, 19262, 19264, 19265, 19266, 25461, 32676, 0 },		// BLOODELF
+			{ 32548, 44041, 44043, 44044, 44045, 44046, 44047, 0 },		// DRAENEI
+		};
+
+		static uint32 shamanspellarray[RACE_DRAENEI+1][2] = {
+			{ 0 },		// RACE 0
+			{ 0 },		// HUMAN
+			{ 2825, 0 },		// ORC
+			{ 0 },		// DWARF
+			{ 0 },		// NIGHTELF
+			{ 0 },		// UNDEAD
+			{ 2825, 0 },		// TAUREN
+			{ 0 },		// GNOME
+			{ 2825, 0 },		// TROLL
+			{ 0 },		// BLOODELF
+			{ 32182, 0 },		// DRAENEI
+		};
+
+		static uint32 magespellarray[RACE_DRAENEI+1][11] = {
+			{ 0 },		// RACE 0
+			{ 3561, 3562, 3565, 10059, 11416, 11419, 32266, 32271, 33690, 33691, 0 },		// HUMAN
+			{ 3563, 3566, 3567, 11417, 11418, 11420, 32267, 32272, 35715, 35717, 0 },		// ORC
+			{ 3561, 3562, 3565, 10059, 11416, 11419, 32266, 32271, 33690, 33691, 0 },		// DWARF
+			{ 3561, 3562, 3565, 10059, 11416, 11419, 32266, 32271, 33690, 33691, 0 },		// NIGHTELF
+			{ 3563, 3566, 3567, 11417, 11418, 11420, 32267, 32272, 35715, 35717, 0 },		// UNDEAD
+			{ 3563, 3566, 3567, 11417, 11418, 11420, 32267, 32272, 35715, 35717, 0 },		// TAUREN
+			{ 3561, 3562, 3565, 10059, 11416, 11419, 32266, 32271, 33690, 33691, 0 },		// GNOME
+			{ 3563, 3566, 3567, 11417, 11418, 11420, 32267, 32272, 35715, 35717, 0 },		// TROLL
+			{ 3563, 3566, 3567, 11417, 11418, 11420, 32267, 32272, 35715, 35717, 0 },		// BLOODELF
+			{ 3561, 3562, 3565, 10059, 11416, 11419, 32266, 32271, 33690, 33691, 0 },		// DRAENEI
+		};
+
+		uint32 r = plr->getRace();
+		switch(c)
+		{
+		case PALADIN:
+			for( uint32 i = 0; paladinspellarray[r][i] != 0; ++i )
+			{
+				plr->addSpell( paladinspellarray[r][i] );
+			}
+			break;
+		case PRIEST:
+			for( uint32 i = 0; priestspellarray[r][i] != 0; ++i )
+			{
+				plr->addSpell( priestspellarray[r][i] );
+			}
+			break;
+		case MAGE:
+			for( uint32 i = 0; magespellarray[r][i] != 0; ++i )
+			{
+				plr->addSpell( magespellarray[r][i] );
+			}
+			break;
+		case SHAMAN:
+			for( uint32 i = 0; shamanspellarray[r][i] != 0; ++i )
+			{
+				plr->addSpell( shamanspellarray[r][i] );
+			}
+			break;
+		}
 		return true;
 	}
 
@@ -738,14 +823,14 @@
 
 	char * pAccount = (char*)args;
 	char * pDuration = strchr(pAccount, ' ');
-	if(pDuration == NULL)
+	if( pDuration == NULL )
 		return false;
 	*pDuration = 0;
 	++pDuration;
 
 	int32 timeperiod = GetTimePeriodFromString(pDuration);
-	if(timeperiod < 0)
-		return NULL;
+	if( timeperiod < 0 )
+		return false;
 
 	uint32 banned = (timeperiod ? (uint32)UNIXTIME+timeperiod : 1);
 
@@ -780,22 +865,45 @@
 
 	uint32 banned = (uint32)UNIXTIME+timeperiod;
 
-	sLogonCommHandler.LogonDatabaseSQLExecute("UPDATE accounts SET banned = %u WHERE login = '%s'", banned, CharacterDatabase.EscapeString(string(pAccount)).c_str());
+	sLogonCommHandler.LogonDatabaseSQLExecute("UPDATE accounts SET muted = %u WHERE login = '%s'", banned, CharacterDatabase.EscapeString(string(pAccount)).c_str());
 	sLogonCommHandler.LogonDatabaseReloadAccounts();
 
+	string tsstr = ConvertTimeStampToDataTime(timeperiod+(uint32)UNIXTIME);
 	GreenSystemMessage(m_session, "Account '%s' has been muted until %s. The change will be effective with the next reload cycle.", pAccount, 
-		ConvertTimeStampToDataTime(timeperiod+(uint32)UNIXTIME).c_str());
+		tsstr.c_str());
 
-	sWorld.DisconnectUsersWithAccount(pAccount, m_session);
 	sGMLog.writefromsession(m_session, "mutex account %s until %s", pAccount, ConvertTimeStampToDataTime(timeperiod+(uint32)UNIXTIME).c_str());
 
 	WorldSession * pSession = sWorld.FindSessionByName(pAccount);
 	if( pSession != NULL )
+	{
 		pSession->m_muted = banned;
+		pSession->SystemMessage("Your voice has been muted until %s by a GM. Until this time, you will not be able to speak in any form.", tsstr.c_str());
+	}
 
 	return true;
 }
 
+bool ChatHandler::HandleAccountUnmuteCommand(const char * args, WorldSession * m_session)
+{
+	string escaped_account = CharacterDatabase.EscapeString( string(args) );
+	if( escaped_account.empty() )
+		return false;
+
+	sLogonCommHandler.LogonDatabaseSQLExecute("UPDATE accounts SET muted = 0 WHERE login = '%s'", escaped_account.c_str());
+	sLogonCommHandler.LogonDatabaseReloadAccounts();
+
+	GreenSystemMessage(m_session, "Account '%s' has been unmuted.", args);
+	WorldSession * pSession = sWorld.FindSessionByName(args);
+	if( pSession != NULL )
+	{
+		pSession->m_muted = 0;
+		pSession->SystemMessage("Your voice has restored. You may speak again.");
+	}
+
+	return true;
+}
+
 bool ChatHandler::HandleAccountFlagsCommand(const char * args, WorldSession * m_session)
 {
     if(!*args) return false;
@@ -2121,6 +2229,7 @@
 
 	CharacterDatabase.Execute("INSERT INTO banned_names VALUES('%s')", CharacterDatabase.EscapeString(string(pi->name)).c_str());
 	GreenSystemMessage(m_session, "Forcing %s to rename his character next logon.", args);
+	sGMLog.writefromsession(m_session, "forced %s to rename his charater (%u)", pi->name, pi->guid);
 	return true;
 }
 
Index: LUAEngine.cpp
===================================================================
--- LUAEngine.cpp	(revision 187)
+++ LUAEngine.cpp	(working copy)
@@ -1241,14 +1241,14 @@
 }
 int luaUnit_GetRandomPlayer(lua_State * L, Unit * ptr)
 {
-	if(!ptr)
+	if( ptr == NULL )
 		return 0;
 
-	int flag = luaL_checkint(L,1);
+	int flag = luaL_checkint( L, 1 );
 
-	Player * ret=NULL;
+	Player* ret = NULL;
 
-	switch (flag)
+	switch( flag )
 	{
 	case RANDOM_ANY:
 		{
@@ -1735,8 +1735,8 @@
 	float posX = (float)luaL_checknumber(L, 2);
 	float posY = (float)luaL_checknumber(L, 3);
 	float posZ = (float)luaL_checknumber(L, 4);
-	if(!mapId || !posX || !posY || !posZ)
-		return 0;
+	//if(!mapId || !posX || !posY || !posZ)
+	//	return 0;
 	
 	LocationVector vec(posX, posY, posZ);
 	((Player*)ptr)->SafeTeleport((uint32)mapId, 0, vec);
@@ -1752,8 +1752,9 @@
 	double posX = luaL_checknumber(L, 3);
 	double posY = luaL_checknumber(L, 4);
 	double posZ = luaL_checknumber(L, 5);
-	if(!mapId || !posX || !posY || !posZ)
-		return 0;
+	//if(!mapId || !posX || !posY || !posZ)
+	//	return 0;
+
 	LocationVector vec((float)posX, (float)posY, (float)posZ);
 	((Player*)target)->SafeTeleport((uint32)mapId, 0, vec);
 	return 0;
Index: MailSystem.cpp
===================================================================
--- MailSystem.cpp	(revision 187)
+++ MailSystem.cpp	(working copy)
@@ -303,7 +303,7 @@
 		recv_data >> itemguid;
 
         pItem = _player->GetItemInterface()->GetItemByGUID( itemguid );
-		if( pItem == NULL || pItem->IsSoulbound() )
+		if( pItem == NULL || pItem->IsSoulbound() || pItem->HasFlag( ITEM_FIELD_FLAGS, ITEM_FLAG_CONJURED ) )
 		{
 			SendMailError( MAIL_ERR_INTERNAL_ERROR );
 			return;
@@ -891,7 +891,7 @@
 		msg.read_flag = fields[i++].GetBool();
 		msg.deleted_flag = fields[i++].GetBool();
 
-		if( msg.copy_made )
+		/*if( msg.copy_made )
 		{
 			QueryResult * result = CharacterDatabase.Query( "SELECT * FROM playeritems WHERE itemtext = %u", msg.message_id );
 			if( result == NULL )
@@ -906,7 +906,7 @@
 			}
 			else
 				delete result;
-		}
+		}*/
 
 		// Add to the mailbox
 		AddMessage(&msg);
Index: Makefile.am
===================================================================
--- Makefile.am	(revision 187)
+++ Makefile.am	(working copy)
@@ -4,6 +4,8 @@
 noinst_LIBRARIES = libgame.a
 
 libgame_a_SOURCES = \
+    CollideInterface.cpp \
+    CollideInterface.h \
     VoiceChatClientSocket.cpp \
     VoiceChatClientSocket.h \
     VoiceChatHandler.cpp \
Index: MapCell.h
===================================================================
--- MapCell.h	(revision 187)
+++ MapCell.h	(working copy)
@@ -74,6 +74,7 @@
 	ObjectSet _objects;
 	bool _active, _loaded;
 	bool _unloadpending;
+
 	uint16 _playerCount;
 	MapMgr* _mapmgr;
 };
Index: MapMgr.cpp
===================================================================
--- MapMgr.cpp	(revision 187)
+++ MapMgr.cpp	(working copy)
@@ -28,7 +28,6 @@
 
 MapMgr::MapMgr(Map *map, uint32 mapId, uint32 instanceid) : CellHandler<MapCell>(map), _mapId(mapId), eventHolder(instanceid)
 {
-	ThreadType = THREADTYPE_MAPMGR;
 	_shutdown = false;
 	m_instanceID = instanceid;
 	pMapInfo = WorldMapInfoStorage.LookupEntry(mapId);
@@ -1094,7 +1093,56 @@
 			plyr->ProcessPendingUpdates();
 	}
 }
+void MapMgr::LoadAllCells()
+{
+	// eek
+	MapCell * cellInfo;
+	CellSpawns * spawns;
 
+	for( uint32 x = 0 ; x < _sizeX ; x ++ )
+	{
+		for( uint32 y = 0 ; y < _sizeY ; y ++ )
+		{
+			cellInfo = GetCell( x , y );
+			
+			if( !cellInfo )
+			{
+				// Cell doesn't exist, create it.
+				// There is no spoon. Err... cell.
+				cellInfo = Create( x , y );
+				cellInfo->Init( x , y , _mapId , this );
+				sLog.outDetail( "Created cell [%u,%u] on map %d (instance %d)." , x , y , _mapId , m_instanceID );
+				cellInfo->SetActivity( true );
+				_map->CellGoneActive( x , y );
+				ASSERT( !cellInfo->IsLoaded() );
+
+				spawns = _map->GetSpawnsList( x , y );
+				if( spawns )
+					cellInfo->LoadObjects( spawns );
+			}
+			else
+			{
+				// Cell exists, but is inactive
+				if ( !cellInfo->IsActive() )
+				{
+					sLog.outDetail("Activated cell [%u,%u] on map %d (instance %d).", x, y, _mapId, m_instanceID );
+					_map->CellGoneActive( x , y );
+					cellInfo->SetActivity( true );
+
+					if (!cellInfo->IsLoaded())
+					{
+						//sLog.outDetail("Loading objects for Cell [%d][%d] on map %d (instance %d)...", 
+						//	posX, posY, this->_mapId, m_instanceID);
+						spawns = _map->GetSpawnsList( x , y );
+						if( spawns )
+							cellInfo->LoadObjects( spawns );
+					}
+				}
+			}
+		}
+	}
+}
+
 void MapMgr::UpdateCellActivity(uint32 x, uint32 y, int radius)
 {
 	CellSpawns * sp;
Index: MiscHandler.cpp
===================================================================
--- MiscHandler.cpp	(revision 187)
+++ MiscHandler.cpp	(working copy)
@@ -395,42 +395,42 @@
 	_player->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_LOOTING);
 	_player->m_currentLoot = 0;
 
-	if(UINT32_LOPART(GUID_HIPART(guid)) == HIGHGUID_UNIT)
+	if( UINT32_LOPART( GUID_HIPART( guid ) ) == HIGHGUID_UNIT )
 	{
-		Creature* pCreature = _player->GetMapMgr()->GetCreature((uint32)guid);
-		if(!pCreature)
+		Creature* pCreature = _player->GetMapMgr()->GetCreature( (uint32)guid );
+		if( pCreature == NULL )
 			return;
 		// remove from looter set
 		pCreature->loot.looters.erase(_player->GetGUIDLow());
-		if(!pCreature->loot.gold)
+		if( pCreature->loot.gold <= 0)
 		{			
-			for(std::vector<__LootItem>::iterator i=pCreature->loot.items.begin();i!=pCreature->loot.items.end();i++)
-			if(i->iItemsCount)
+			for( std::vector<__LootItem>::iterator i = pCreature->loot.items.begin(); i != pCreature->loot.items.end(); i++ )
+			if( i->iItemsCount > 0 )
 			{
-				ItemPrototype *proto=i->item.itemproto;
-				if(proto->Class != 12)
-				return;
-				if(_player->HasQuestForItem(i->item.itemproto->ItemId))
-				return;
+				ItemPrototype* proto = i->item.itemproto;
+				if( proto->Class != 12 )
+					return;
+				if( _player->HasQuestForItem( i->item.itemproto->ItemId ) )
+					return;
 			}
-			pCreature->BuildFieldUpdatePacket(_player, UNIT_DYNAMIC_FLAGS, 0);
+			pCreature->BuildFieldUpdatePacket( _player, UNIT_DYNAMIC_FLAGS, 0 );
 
-			if(!pCreature->Skinned)
+			if( !pCreature->Skinned )
 			{
-				if(lootmgr.IsSkinnable(pCreature->GetEntry()))
+				if( lootmgr.IsSkinnable( pCreature->GetEntry() ) )
 				{
-					pCreature->BuildFieldUpdatePacket(_player, UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);
+					pCreature->BuildFieldUpdatePacket( _player, UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE );
 				}
 			}
 		}
 	}
-	else if(UINT32_LOPART(GUID_HIPART(guid)) == HIGHGUID_GAMEOBJECT)
+	else if( UINT32_LOPART( GUID_HIPART( guid ) ) == HIGHGUID_GAMEOBJECT )
 	{	   
-		GameObject* pGO = _player->GetMapMgr()->GetGameObject((uint32)guid);
-		if(!pGO)
+		GameObject* pGO = _player->GetMapMgr()->GetGameObject( (uint32)guid );
+		if( pGO == NULL )
 			return;
 
-        switch(pGO->GetUInt32Value(GAMEOBJECT_TYPE_ID))
+        switch( pGO->GetUInt32Value( GAMEOBJECT_TYPE_ID ) )
         {
         case GAMEOBJECT_TYPE_FISHINGNODE:
             {
@@ -443,37 +443,47 @@
             }break;
         case GAMEOBJECT_TYPE_CHEST:
             {
-                pGO->loot.looters.erase(_player->GetGUIDLow());
+                pGO->loot.looters.erase( _player->GetGUIDLow() );
                 //check for locktypes
                 
-                Lock *pLock = dbcLock.LookupEntry(pGO->GetInfo()->SpellFocus);
-                if(pLock)
+                Lock* pLock = dbcLock.LookupEntry( pGO->GetInfo()->SpellFocus );
+                if( pLock )
                 {
-                    for(uint32 i=0; i < 5; i++)
+                    for( uint32 i=0; i < 5; i++ )
                     {
-                        if(pLock->locktype[i])
+                        if( pLock->locktype[i] )
                         {
-                            if(pLock->locktype[i] == 2) //locktype;
+                            if( pLock->locktype[i] == 2 ) //locktype;
                             {
                                 //herbalism and mining;
-                                if(pLock->lockmisc[i] == LOCKTYPE_MINING || pLock->lockmisc[i] == LOCKTYPE_HERBALISM)
+                                if( pLock->lockmisc[i] == LOCKTYPE_MINING || pLock->lockmisc[i] == LOCKTYPE_HERBALISM )
                                 {
                                     //we still have loot inside.
-                                    if(pGO->HasLoot())
+                                    if( pGO->HasLoot() )
                                     {
-                                        pGO->SetUInt32Value(GAMEOBJECT_STATE, 1);
+                                        pGO->SetUInt32Value( GAMEOBJECT_STATE, 1 );
+										// TODO : redo this temporary fix, because for some reason hasloot is true even when we loot everything
+										// my guess is we need to set up some even that rechecks the GO in 10 seconds or something
+										pGO->Despawn( 600000 + ( RandomUInt( 300000 ) ) );
                                         return;
                                     }
-                                    if(pGO->CanMine())
-                                    {   pGO->loot.items.clear();
+                                    else
+                                    {
+										pGO->Despawn( 600000 + ( RandomUInt( 300000 ) ) );
+										return;
+                                    }
+
+                                    if( pGO->CanMine() )
+                                    {
+										pGO->loot.items.clear();
                                         pGO->UseMine();
-                                       
+										return;
                                     }
                                     else
                                     {
-    					    pGO->CalcMineRemaining(true);
-			                    pGO->Despawn(900000);
-					    return;
+    									pGO->CalcMineRemaining( true );
+										pGO->Despawn( 600000 + ( RandomUInt( 300000 ) ) );
+										return;
                                     }
                                 }
                                 else //other type of locks that i dont bother to split atm ;P
@@ -501,7 +511,7 @@
                 }
                 else
                 {
-                    if(pGO->HasLoot())
+                    if( pGO->HasLoot() )
                     {
                         pGO->SetUInt32Value(GAMEOBJECT_STATE, 1);
                         return;
@@ -765,7 +775,7 @@
 void WorldSession::HandlePlayerLogoutOpcode( WorldPacket & recv_data )
 {
 	sLog.outDebug( "WORLD: Recvd CMSG_PLAYER_LOGOUT Message" );
-	if(!_logoutTime && !HasGMPermissions())
+	if(!HasGMPermissions())
 	{
 		// send "You do not have permission to use this"
 		SendNotification(NOTIFICATION_MESSAGE_NO_PERMISSION);
@@ -928,18 +938,27 @@
 
 	uint64 guid;
 	recv_data >> guid;
+
+	Corpse* pCorpse = objmgr.GetCorpse( (uint32)guid );
+
+	if( pCorpse == NULL )
+		return;
+
 	// Check that we're reviving from a corpse, and that corpse is associated with us.
-	Corpse * pCorpse = objmgr.GetCorpse((uint32)guid);
-	if(pCorpse == 0) return;
-
-	if(pCorpse == 0 ||
-		pCorpse->GetUInt32Value(CORPSE_FIELD_OWNER) != _player->GetGUIDLow() &&
-		pCorpse->GetUInt32Value(CORPSE_FIELD_FLAGS) == 5)
+	if( pCorpse->GetUInt32Value( CORPSE_FIELD_OWNER ) != _player->GetGUIDLow() && pCorpse->GetUInt32Value( CORPSE_FIELD_FLAGS ) == 5 )
 	{
-		WorldPacket data(SMSG_RESURRECT_FAILED, 4);
-		data << uint32(1);  // this is a real guess!
+		WorldPacket data( SMSG_RESURRECT_FAILED, 4 );
+		data << uint32(1); // this is a real guess!
 		SendPacket(&data);
+		return;
+	}
 
+	// Check we are actually in range of our corpse
+    if ( pCorpse->GetDistance2dSq( _player ) > CORPSE_MINIMUM_RECLAIM_RADIUS_SQ )
+  	{
+		WorldPacket data( SMSG_RESURRECT_FAILED, 4 );
+		data << uint32(1);
+		SendPacket(&data);
 		return;
 	}
 
@@ -1487,6 +1506,103 @@
 	SendPacket(&data);
 }
 
+void WorldSession::HandleInspectOpcode( WorldPacket & recv_data )
+{
+	CHECK_PACKET_SIZE( recv_data, 8 );
+	CHECK_INWORLD_RETURN
+
+	uint64 guid;
+	uint32 talent_points = 0x0000003D;
+	recv_data >> guid;
+
+	Player * player = _player->GetMapMgr()->GetPlayer( (uint32)guid );
+    
+	if( player == NULL )
+	{
+		sLog.outError( "HandleInspectOpcode: guid was null" );
+		return;
+	}
+
+	_player->SetSelection( guid );
+
+    WorldPacket data( SMSG_INSPECT_TALENTS, 4 + talent_points );
+
+    data << uint32( talent_points );
+
+	uint32 talent_tab_pos = 0;
+	uint32 talent_max_rank;
+	uint32 talent_tab_id;
+	uint32 talent_index;
+	uint32 rank_index;
+	uint32 rank_slot;
+	uint32 rank_offset;
+	uint32 mask;
+
+    for( uint32 i = 0; i < talent_points; ++i )
+        data << uint8( 0 );
+
+    for( uint32 i = 0; i < 3; ++i )
+    {
+		talent_tab_id = sWorld.InspectTalentTabPages[player->getClass()][i];
+
+		for( uint32 j = 0; j < dbcTalent.GetNumRows(); ++j )
+		{
+			TalentEntry const* talent_info = dbcTalent.LookupRow( j );
+
+			//sLog.outDebug( "HandleInspectOpcode: i(%i) j(%i)", i, j );
+
+			if( talent_info == NULL )
+				continue;
+
+			//sLog.outDebug( "HandleInspectOpcode: talent_info->TalentTree(%i) talent_tab_id(%i)", talent_info->TalentTree, talent_tab_id );
+
+			if( talent_info->TalentTree != talent_tab_id )
+				continue;
+
+			talent_max_rank = 0;
+			for( uint32 k = 5; k > 0; --k )
+			{
+				//sLog.outDebug( "HandleInspectOpcode: k(%i) RankID(%i) HasSpell(%i) TalentTree(%i) Tab(%i)", k, talent_info->RankID[k - 1], player->HasSpell( talent_info->RankID[k - 1] ), talent_info->TalentTree, talent_tab_id );
+				if( talent_info->RankID[k - 1] != 0 && player->HasSpell( talent_info->RankID[k - 1] ) )
+				{
+					talent_max_rank = k;
+					break;
+				}
+			}
+
+			//sLog.outDebug( "HandleInspectOpcode: RankID(%i) talent_max_rank(%i)", talent_info->RankID[talent_max_rank-1], talent_max_rank );
+
+			if( talent_max_rank <= 0 )
+				continue;
+
+			talent_index = talent_tab_pos;
+
+			std::map< uint32, uint32 >::iterator itr = sWorld.InspectTalentTabPos.find( talent_info->TalentID );
+
+			if( itr != sWorld.InspectTalentTabPos.end() )
+				talent_index += itr->second;
+			//else
+				//sLog.outDebug( "HandleInspectOpcode: talent(%i) rank_id(%i) talent_index(%i) talent_tab_pos(%i) rank_index(%i) rank_slot(%i) rank_offset(%i)", talent_info->TalentID, talent_info->RankID[talent_max_rank-1], talent_index, talent_tab_pos, rank_index, rank_slot, rank_offset );
+
+			rank_index = ( uint32( ( talent_index + talent_max_rank - 1 ) / 7 ) ) * 8  + ( uint32( ( talent_index + talent_max_rank - 1 ) % 7 ) );
+			rank_slot = rank_index / 8;
+			rank_offset = rank_index % 8;
+			mask = 1 << rank_offset;
+			data.put< uint8 >( 4 + rank_slot, mask & 0xFF );
+
+			sLog.outDebug( "HandleInspectOpcode: talent(%i) talent_max_rank(%i) rank_id(%i) talent_index(%i) talent_tab_pos(%i) rank_index(%i) rank_slot(%i) rank_offset(%i)", talent_info->TalentID, talent_max_rank, talent_info->RankID[talent_max_rank-1], talent_index, talent_tab_pos, rank_index, rank_slot, rank_offset );
+		}
+
+		std::map< uint32, uint32 >::iterator itr = sWorld.InspectTalentTabSize.find( talent_tab_id );
+
+		if( itr != sWorld.InspectTalentTabSize.end() )
+			talent_tab_pos += itr->second;
+
+	}
+
+    SendPacket( &data );
+}
+
 void WorldSession::HandleSetActionBarTogglesOpcode(WorldPacket &recvPacket)
 {
 	uint8 cActionBarId;
Index: MovementHandler.cpp
===================================================================
--- MovementHandler.cpp	(revision 187)
+++ MovementHandler.cpp	(working copy)
@@ -169,6 +169,21 @@
 			data << uint32(1) << _player->m_UnderwaterTime << _player->m_UnderwaterMaxTime << int32(-1) << uint32(0);
 			pSession->SendPacket(&data);
 		}
+
+		// player is above water level
+		if( pSession->m_bIsWLevelSet )
+		{
+			if( ( movement_info.z + _player->m_noseLevel ) > pSession->m_wLevel )
+			{
+				// remove druid aquatic form on land
+				if( _player->getClass() == DRUID )
+					_player->RemoveAura( 1066 );
+
+				// unset swim session water level
+				pSession->m_bIsWLevelSet = false;
+			}
+		}
+
 		return;
 	}
 
@@ -309,7 +324,10 @@
 	/************************************************************************/
 	/* Update player movement state                                         */
 	/************************************************************************/
-	if(recv_data.GetOpcode() == MSG_MOVE_STOP)
+	if( recv_data.GetOpcode() == MSG_MOVE_STOP 
+		|| recv_data.GetOpcode() == MSG_MOVE_STOP_STRAFE 
+		|| recv_data.GetOpcode() == MSG_MOVE_STOP_TURN 
+		)
 		_player->m_isMoving = false;
 	else
 		_player->m_isMoving = true;
@@ -564,7 +582,8 @@
 
 	if( !_player->bFeatherFall && !_player->blinked && sWorld.antihack_speed && !_player->m_uint32Values[UNIT_FIELD_CHARM] && !_player->m_TransporterGUID && !( movement_info.flags & ( MOVEFLAG_FALLING | MOVEFLAG_FALLING_FAR | MOVEFLAG_FREE_FALLING ) ) )
 	{
-		if( ( sWorld.no_antihack_on_gm && !HasGMPermissions() ) || !sWorld.no_antihack_on_gm )
+		if( !HasGMPermissions() )
+		//if( ( sWorld.no_antihack_on_gm && !HasGMPermissions() ) || !sWorld.no_antihack_on_gm )
 		{
 			float speed;
 
Index: NPCHandler.cpp
===================================================================
--- NPCHandler.cpp	(revision 187)
+++ NPCHandler.cpp	(working copy)
@@ -224,7 +224,7 @@
 	if(	(pSpell->RequiredLevel && _player->getLevel()<pSpell->RequiredLevel)
 		|| (pSpell->RequiredSpell && !_player->HasSpell(pSpell->RequiredSpell))
 		|| (pSpell->Cost && _player->GetUInt32Value(PLAYER_FIELD_COINAGE) < pSpell->Cost)
-		|| (pSpell->RequiredSkillLine && _player->_GetSkillLineCurrent(pSpell->RequiredSkillLine,false) < pSpell->RequiredSkillLineValue)
+		|| (pSpell->RequiredSkillLine && _player->_GetSkillLineCurrent(pSpell->RequiredSkillLine,true) < pSpell->RequiredSkillLineValue)
 		|| (pSpell->IsProfession && pSpell->RequiredSkillLine==0 && _player->GetUInt32Value(PLAYER_CHARACTER_POINTS2) == 0)//check level 1 professions if we can learn a new proffesion
 		)
 		return TRAINER_STATUS_NOT_LEARNABLE;
Index: Object.cpp
===================================================================
--- Object.cpp	(revision 187)
+++ Object.cpp	(working copy)
@@ -1371,29 +1371,53 @@
 
 bool Object::isInFront(Object* target)
 {
-	double dx=double(target->GetPositionX()-GetPositionX());
-	double dy=double(target->GetPositionY()-GetPositionY());
-	double d = double(m_position.o);
+	// check if we facing something ( is the object within a 180 degree slice of our positive y axis )
 
-	while(d < 0) d+=2*M_PI;
-	while(d > 2*M_PI) d-=2*M_PI;
-	m_position.o = float(d);
+    double x = target->GetPositionX() - GetPositionX();
+    double y = target->GetPositionY() - GetPositionY();
 
-	if(dy>=0.0)
-	{
-		d-=atan(dy/dx);
+    double angle = atan2( y, x );
+    angle = ( angle >= 0.0 ) ? angle : 2.0 * M_PI + angle;
+	angle -= m_position.o;
 
-		if(dx<0.0)
-			d-=M_PI;
-	}
-	else
-	{
-		d-=3*M_PI/2 - atan(dx/dy);
-	}
+    while( angle > M_PI)
+        angle -= 2.0 * M_PI;
 
-	if(d < -M_PI*2/3 || d > M_PI*2/3)
-		return false;
-	return true;
+    while(angle < -M_PI)
+        angle += 2.0 * M_PI;
+
+	// replace M_PI in the two lines below to reduce or increase angle
+
+    double left = -1.0 * ( M_PI / 2.0 );
+    double right = ( M_PI / 2.0 );
+
+    return( ( angle >= left ) && ( angle <= right ) );
+
+	// old version jsut in case
+
+	//double dx = double( target->GetPositionX()-GetPositionX() );
+	//double dy = double( target->GetPositionY()-GetPositionY() );
+	//double d = double( m_position.o );
+
+	//while(d < 0) d+=2*M_PI;
+	//while(d > 2*M_PI) d-=2*M_PI;
+
+	//m_position.o = float(d);
+
+	//if(dy>=0.0)
+	//{
+	//	d-=atan(dy/dx);
+	//	if(dx<0.0)
+	//		d-=M_PI;
+	//}
+	//else
+	//{
+	//	d-=3*M_PI/2 - atan(dx/dy);
+	//}
+
+	//if(d < -M_PI*2/3 || d > M_PI*2/3)
+	//	return false;
+	//return true;
 }
 
 
@@ -1623,19 +1647,24 @@
 	}
 
         ///Rage
-        uint32 val;
+        float val;
 
-        if(pVictim->GetPowerType() == POWER_TYPE_RAGE 
+		if( pVictim->GetPowerType() == POWER_TYPE_RAGE 
 			//&& !spellId //zack : general opinion is that spells should generate rage. I share the feeling
 			&& pVictim != this
 			&& pVictim->IsPlayer())
-	  {
-	      val = pVictim->GetUInt32Value(UNIT_FIELD_POWER2)+(damage*20)/(pVictim->getLevel()*3);
-	      pVictim->SetUInt32Value(UNIT_FIELD_POWER2, val>=1000?1000:val);
-	  }
-        //
+		{
+			float level = (float)pVictim->getLevel();
+			float c = 0.0091107836f * level * level + 3.225598133f * level + 4.2652911f;
+			val = 2.5f * damage / c;
+			uint32 rage = pVictim->GetUInt32Value( UNIT_FIELD_POWER2 );
+			if( rage + float2int32( val ) > 1000 )
+			  val = 1000.0f - (float)pVictim->GetUInt32Value( UNIT_FIELD_POWER2 );
 
-	if(pVictim->IsPlayer())
+			ModUInt32Value(UNIT_FIELD_POWER2, (int32)val);
+		}
+
+	if( pVictim->IsPlayer() )
 	{
 		Player *pThis = static_cast<Player *>(pVictim);
 		if(pThis->cannibalize)
@@ -2273,7 +2302,7 @@
 		if((int32)dmg.resisted_damage > dmg.full_damage)
 			res = 0;
 		else
-            res = float(dmg.full_damage - dmg.resisted_damage);
+			res = float(dmg.full_damage - dmg.resisted_damage);
 	}
 	//------------------------------special states----------------------------------------------
 	if(pVictim->GetTypeId() == TYPEID_PLAYER && static_cast<Player*>(pVictim)->GodModeCheat == true)
Index: Object.h
===================================================================
--- Object.h	(revision 187)
+++ Object.h	(working copy)
@@ -174,6 +174,7 @@
 	ASCENT_INLINE const float& GetSpawnO( ) const { return m_spawnLocation.o; }
 
 	ASCENT_INLINE const LocationVector & GetPosition() { return m_position; }
+	ASCENT_INLINE LocationVector & GetPositionNC() { return m_position; }
 	ASCENT_INLINE LocationVector * GetPositionV() { return &m_position; }
 
 	//Distance Calculation
Index: ObjectMgr.cpp
===================================================================
--- ObjectMgr.cpp	(revision 187)
+++ ObjectMgr.cpp	(working copy)
@@ -66,13 +66,6 @@
 		delete i->second;
 	}
 
-	Log.Notice("ObjectMgr", "Deleting AI Threat Spells...");
-	for( ThreadToSpellList::iterator i = threatToSpells.begin( ); i != threatToSpells.end( ); ++ i ) 
-	{
-		ThreatToSpellId *gc=(*i);
-		delete gc;
-	}
-
 	Log.Notice("ObjectMgr", "Deleting Spell Override...");
 	for(OverrideIdMap::iterator i = mOverrideIdMap.begin(); i != mOverrideIdMap.end(); ++i)
 	{
@@ -616,7 +609,7 @@
 	ss2 << ticket->timestamp << ");";
 
 	if(buf == NULL)
-		CharacterDatabase.Execute(ss2.str( ).c_str( ));
+		CharacterDatabase.ExecuteNA(ss2.str( ).c_str( ));
 	else
 		buf->AddQueryStr(ss2.str());
 }
@@ -1106,35 +1099,20 @@
 		return;
 	}
 
-	ThreatToSpellId *t2s = NULL;
+	SpellEntry * sp;
 
 	do
 	{
 		Field *fields = result->Fetch();
+		sp = dbcSpell.LookupEntryForced( fields[0].GetUInt32() );
+		if( sp != NULL )
+			sp->ThreatForSpell = fields[1].GetUInt32();
 
-		t2s = new ThreatToSpellId;
-		t2s->spellId = fields[0].GetUInt32();
-		t2s->mod = atoi(fields[1].GetString());
-		threatToSpells.push_back(t2s);
-
 	} while( result->NextRow() );
 
 	delete result;
-	Log.Notice("ObjectMgr", "%u spell threats loaded.", threatToSpells.size());
 }
 
-int32 ObjectMgr::GetAIThreatToSpellId(uint32 spellId)
-{
-	for(ThreadToSpellList::iterator i = threatToSpells.begin(); i != threatToSpells.end(); i++)
-	{
-		if((*i)->spellId == spellId)
-		{
-			return (*i)->mod;
-		}
-	}
-	return 0;
-}
-
 Item * ObjectMgr::CreateItem(uint32 entry,Player * owner)
 {
 	ItemPrototype * proto = ItemPrototypeStorage.LookupEntry(entry);
Index: ObjectMgr.h
===================================================================
--- ObjectMgr.h	(revision 187)
+++ ObjectMgr.h	(working copy)
@@ -39,12 +39,6 @@
 	uint32 timestamp;
 };
 
-struct ThreatToSpellId
-{
-	uint32 spellId;
-	int32 mod;
-};
-
 #pragma pack(push,1)
 struct FishingZoneEntry
 {
@@ -312,13 +306,9 @@
 	typedef std::map<uint32, uint32>                                    PetSpellCooldownMap;
 	typedef std::map<uint32, SpellEntry*>                               TotemSpellMap;
 
-    // List typedef's
-    typedef std::list<ThreatToSpellId*>                                 ThreadToSpellList;
-    
     // object holders
 	GmTicketList        GM_TicketList;
 	TotemSpellMap       m_totemSpells;
-	ThreadToSpellList   threatToSpells;
 	OverrideIdMap       mOverrideIdMap;
 
 	Player* GetPlayer(const char* name, bool caseSensitive = true);
@@ -414,9 +404,6 @@
 	//Totem
 	SpellEntry* GetTotemSpell(uint32 spellId);
 
-	// AI Threat by SpellId
-	int32 GetAIThreatToSpellId(uint32 spellId);
-
 	std::list<ItemPrototype*>* GetListForItemSet(uint32 setid);
 
 	Pet * CreatePet();
Index: ObjectStorage.cpp
===================================================================
--- ObjectStorage.cpp	(revision 187)
+++ ObjectStorage.cpp	(working copy)
@@ -120,6 +120,20 @@
 		itr->Destruct();
 	}
 
+	{
+		StorageContainerIterator<Quest> * itr = QuestStorage.MakeIterator();
+		Quest * qst;
+		while(!itr->AtEnd())
+		{
+			qst = itr->Get();
+			qst->pQuestScript = NULL;
+
+			if( !itr->Inc() )
+				break;
+		}
+		itr->Destruct();
+	}
+
 	// Load AI Agents
 	QueryResult * result = WorldDatabase.Query( "SELECT * FROM ai_agents" );
 	CreatureProto * cn;
Index: Pet.cpp
===================================================================
--- Pet.cpp	(revision 187)
+++ Pet.cpp	(working copy)
@@ -34,11 +34,21 @@
 
 	case SPELL_HASH_FIREBOLT:			// Firebolt
 	case SPELL_HASH_LASH_OF_PAIN:		// Lash of Pain
-	case SPELL_HASH_TORMENT:			// Torment
+	case SPELL_HASH_TORMENT:            // Torment
+	case SPELL_HASH_SUFFERING:
+	case SPELL_HASH_SOOTHING_KISS:
+	case SPELL_HASH_SEDUCTION:
+	case SPELL_HASH_CLEAVE:
+	case SPELL_HASH_INTERCEPT:
+	case SPELL_HASH_DEVOUR_MAGIC:
+	case SPELL_HASH_SPELL_LOCK:
+
 		return AUTOCAST_EVENT_ATTACK;
 		break;
 
-	case SPELL_HASH_BLOOD_PACT:			// Blood Pact
+	case SPELL_HASH_BLOOD_PACT:       // Blood Pact
+	case SPELL_HASH_AVOIDANCE:
+	case SPELL_HASH_PARANOIA:
 		return AUTOCAST_EVENT_ON_SPAWN;
 		break;
 
@@ -47,6 +57,8 @@
 		break;
 		
 	case SPELL_HASH_PHASE_SHIFT:		// Phase Shift
+	case SPELL_HASH_CONSUME_SHADOWS:     
+	case SPELL_HASH_LESSER_INVISIBILITY:
 		return AUTOCAST_EVENT_LEAVE_COMBAT;
 		break;
 
@@ -203,9 +215,6 @@
 	m_base_walkSpeed = m_walkSpeed = owner->m_base_walkSpeed; //should we be able to keep up with master ?
 
 	InitializeMe(true);
-
-	if( owner && owner->IsPlayer() )
-		static_cast<Player*>( owner )->EventSummonPet( this );
 }
 
 
@@ -270,13 +279,13 @@
 		} 
 		else 
 		{
-			if(time > m_HappinessTimer)
+			if( time > m_HappinessTimer )
 				m_HappinessTimer = 0;
 			else
 				m_HappinessTimer -= time;
 		}
 		//Loyalty
-		if(m_LoyaltyTimer==0 && GetHappinessState()!=NULL)
+		if( m_LoyaltyTimer == 0 && GetHappinessState() != 0 )
 		{
 			UpdateLoyalty(LoyaltyTicks[GetHappinessState()-1]);//loyalty tick is happiness state dependent
 			m_LoyaltyTimer = PET_LOYALTY_UPDATE_TIMER;
@@ -466,6 +475,7 @@
 
 		free(ab);
 	}
+
 	InitializeMe(false);
 
 	if(m_Owner && getLevel() > m_Owner->getLevel())
@@ -476,15 +486,28 @@
 		ApplyStatsForLevel();
 	}
 	
+	//Zack : moved these before casting self talents
 	// Nuke auras
+//	for(uint32 x = UNIT_FIELD_AURA_01; x <= UNIT_FIELD_AURA_55; x++)
+//		SetUInt32Value(x, 0);
+}
+
+void Pet::OnPushToWorld()
+{
+	// Nuke auras
 	for(uint32 x = UNIT_FIELD_AURA_01; x <= UNIT_FIELD_AURA_55; x++)
 		SetUInt32Value(x, 0);
+
+	//before we initialize pet spells so we can apply spell mods on them 
+	if( m_Owner && m_Owner->IsPlayer() )
+		static_cast<Player*>( m_Owner )->EventSummonPet( this );
+
+	Creature::OnPushToWorld();
 }
 
 void Pet::InitializeMe(bool first)
 {
 	// set up ai and shit
-	
 	GetAIInterface()->Init(this,AITYPE_PET,MOVEMENTTYPE_NONE,m_Owner);
 	GetAIInterface()->SetUnitToFollow(m_Owner);
 	GetAIInterface()->SetFollowDistance(3.0f);
@@ -537,7 +560,8 @@
 		UpdateTP();
 	}
 
-	InitializeSpells();
+	InitializeSpells(); 
+
 	PushToWorld(m_Owner->GetMapMgr());
 
 	if(first)
@@ -674,7 +698,7 @@
 		sEventMgr.AddEvent(this, &Pet::DelayedRemove, true, bDeath, EVENT_PET_DELAYED_REMOVE, PET_DELAYED_REMOVAL_TIME, 1,EVENT_FLAG_DO_NOT_EXECUTE_IN_WORLD_CONTEXT);
 }
 
-void Pet::GiveXP(uint32 xp)
+void Pet::GiveXP( uint32 xp )
 {
 	if( !m_Owner || Summon )
 		return;	
@@ -689,6 +713,9 @@
 		return;
 
 	
+	if( getLevel() >= m_Owner->getLevel() )		//pet do not get xp if its level >= owners level
+		return;
+
 	xp += m_uint32Values[UNIT_FIELD_PETEXPERIENCE];
 	uint32 nxp = m_uint32Values[UNIT_FIELD_PETNEXTLEVELEXP];
 	bool changed = false;
@@ -1535,7 +1562,7 @@
 	}
 	return tmp ? tmp->Id : 0;
 }
-void Pet::UpdateLoyalty(char pts)
+void Pet::UpdateLoyalty( char pts )
 {	
 	//updates loyalty_pts and loyalty lvl if needed
 	if( !m_Owner || Summon )
@@ -1566,6 +1593,11 @@
 	LoyaltyPts = newLvl > curLvl ? 0 : LoyLvlRange[ newLvl ];		//reset loy_pts
 	LoyaltyXP = 0;													//reset loy_xp
 	UpdateTP();
+	
+	SetUInt32Value( UNIT_FIELD_BYTES_1, 0 | ( newLvl << 8 ) );		//set new loy level
+	LoyaltyPts = newLvl > curLvl ? 0 : LoyLvlRange[ newLvl ];		//reset loy_pts
+	LoyaltyXP = 0;													//reset loy_xp
+	UpdateTP();
 }
 
 AI_Spell * Pet::HandleAutoCastEvent()
@@ -1665,14 +1697,17 @@
 		return;
 	}
 
-	for( list<AI_Spell*>::iterator itr = m_autoCastSpells[Type].begin(); itr != m_autoCastSpells[Type].end(); ++itr )
+	for( list<AI_Spell*>::iterator itr = m_autoCastSpells[Type].begin(); itr != m_autoCastSpells[Type].end(); )
 	{
-		if( (*itr)->spelltargetType == TTYPE_OWNER )
-			CastSpell( m_Owner, (*itr)->spell, false );
+		AI_Spell * sp = *itr;
+		++itr;
+
+		if( sp->spelltargetType == TTYPE_OWNER )
+			CastSpell( m_Owner, sp->spell, false );
 		else
 		{
 			//modified by Zack: Spell targetting will be generated in the castspell function now.You cannot force to target self all the time
-			CastSpell( static_cast< Unit* >( NULL ), (*itr)->spell, false);
+			CastSpell( static_cast< Unit* >( NULL ), sp->spell, false);
 		}
 	}
 }
Index: Pet.h
===================================================================
--- Pet.h	(revision 187)
+++ Pet.h	(working copy)
@@ -122,6 +122,8 @@
 	void CreateAsSummon(uint32 entry, CreatureInfo *ci, Creature *created_from_creature, Unit* owner, SpellEntry *created_by_spell, uint32 type, uint32 expiretime);
 
 	virtual void Update(uint32 time);
+	void OnPushToWorld();
+
 	ASCENT_INLINE uint32 GetXP(void) { return m_PetXP; }
 
 	void InitializeSpells();
Index: Player.cpp
===================================================================
--- Player.cpp	(revision 187)
+++ Player.cpp	(working copy)
@@ -34,7 +34,7 @@
 	SetUInt32Value( OBJECT_FIELD_GUID+1,high);
 	m_wowGuid.Init(GetGUID());
 
-
+	m_finishingmovesdodge = false;
 	iActivePet			  = 0;
 	resurrector			 = 0;
 	SpellCrtiticalStrikeRatingBonus=0;
@@ -573,7 +573,7 @@
 	if(!info)
 	{
 		// info not found... disconnect
-		sCheatLog.writefromsession(m_session, "tried to create invalid player with race %u and class %u", race, class_);
+		//sCheatLog.writefromsession(m_session, "tried to create invalid player with race %u and class %u", race, class_);
 		m_session->Disconnect();
 		return false;
 	}
@@ -581,7 +581,7 @@
 	// check that the account CAN create TBC characters, if we're making some
 	if(race >= RACE_BLOODELF && !m_session->HasFlag(ACCOUNT_FLAG_XPACK_01))
 	{
-		sCheatLog.writefromsession(m_session, "tried to create player with race %u and class %u but no expansion flags", race, class_);
+		//sCheatLog.writefromsession(m_session, "tried to create player with race %u and class %u but no expansion flags", race, class_);
 		m_session->Disconnect();
 		return false;
 	}
@@ -893,7 +893,7 @@
 	{
 		if( mstime >= m_mountCheckTimer )
 		{
-			if( CollideInterface.IsIndoorMod( m_mapId, &m_position ) )
+			if( CollideInterface.IsIndoor( m_mapId, m_position ) )
 			{
 				RemoveAura( m_MountSpellId );
 				m_MountSpellId = 0;
@@ -1867,7 +1867,6 @@
 	Pet *pPet = objmgr.CreatePet();
 	pPet->SetInstanceID(GetInstanceID());
 	pPet->LoadFromDB(this, itr->second);
-	EventSummonPet(pPet); //cast our talent on the little bastard :)
 }
 
 void Player::_LoadPetSpells(QueryResult * result)
@@ -3807,57 +3806,58 @@
 
 void Player::RepopRequestedPlayer()
 {
-	if(myCorpse)
+	if( myCorpse != NULL )
 	{
-		GetSession()->SendNotification(NOTIFICATION_MESSAGE_NO_PERMISSION);
+		GetSession()->SendNotification( NOTIFICATION_MESSAGE_NO_PERMISSION );
 		return;
 	}
 
-	if(m_CurrentTransporter != NULL)
+	if( m_CurrentTransporter != NULL )
 	{
-		m_CurrentTransporter->RemovePlayer(this);
+		m_CurrentTransporter->RemovePlayer( this );
 		m_CurrentTransporter = NULL;
 		m_TransporterGUID = 0;
 
 		ResurrectPlayer();
-		RepopAtGraveyard(GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId());
+		RepopAtGraveyard( GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId() );
 		return;
 	}
 
 	MapInfo * pMapinfo;
 
-	sEventMgr.RemoveEvents(this,EVENT_PLAYER_FORECED_RESURECT); //in case somebody resurrected us before this event happened
+	sEventMgr.RemoveEvents( this, EVENT_PLAYER_FORECED_RESURECT ); //in case somebody resurrected us before this event happened
 
 	// Set death state to corpse, that way players will lose visibility
-	setDeathState(CORPSE);
+	setDeathState( CORPSE );
 	
 	// Update visibility, that way people wont see running corpses :P
 	UpdateVisibility();
 
 	// If we're in battleground, remove the skinnable flag.. has bad effects heheh
-	RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE);
+	RemoveFlag( UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE );
 
-	bool corpse = (m_bg != NULL) ? m_bg->CreateCorpse(this) : true;
-	if(corpse)
+	bool corpse = (m_bg != NULL) ? m_bg->CreateCorpse( this ) : true;
+
+	if( corpse )
 		CreateCorpse();
 	
 	BuildPlayerRepop();
 
-	pMapinfo = WorldMapInfoStorage.LookupEntry(GetMapId());
-	if(pMapinfo)
+	pMapinfo = WorldMapInfoStorage.LookupEntry( GetMapId() );
+	if( pMapinfo != NULL )
 	{
-		if(pMapinfo->type == INSTANCE_NULL || pMapinfo->type == INSTANCE_PVP)
+		if( pMapinfo->type == INSTANCE_NULL || pMapinfo->type == INSTANCE_PVP )
 		{
-			RepopAtGraveyard(GetPositionX(),GetPositionY(),GetPositionZ(),GetMapId());
+			RepopAtGraveyard( GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId() );
 		}
 		else
 		{
-			RepopAtGraveyard(pMapinfo->repopx, pMapinfo->repopy, pMapinfo->repopz, pMapinfo->repopmapid);
+			RepopAtGraveyard( pMapinfo->repopx, pMapinfo->repopy, pMapinfo->repopz, pMapinfo->repopmapid );
 		}
 	}
 	else
 	{
-		RepopAtGraveyard(GetPositionX(),GetPositionY(),GetPositionZ(),GetMapId());
+		RepopAtGraveyard( GetPositionX(), GetPositionY(), GetPositionZ(), GetMapId() );
 	}
 	
 	if(m_bg != NULL && !(m_bg->GetType()>=BATTLEGROUND_ARENA_2V2 && m_bg->GetType()<=BATTLEGROUND_ARENA_5V5)) // add to ress queue in BG
@@ -3877,11 +3877,19 @@
 		SpawnCorpseBody();
 
 		/* Send Spirit Healer Location */
-		WorldPacket data(SMSG_SPIRIT_HEALER_POS, 16);
+		WorldPacket data( SMSG_SPIRIT_HEALER_POS, 16 );
 		data << m_mapId << m_position;
-		m_session->SendPacket(&data);
+		m_session->SendPacket( &data );
+
+		/* Corpse reclaim delay */
+		WorldPacket data2( SMSG_CORPSE_RECLAIM_DELAY, 4 );
+		data2 << (uint32)( CORPSE_RECLAIM_TIME_MS );
+		GetSession()->SendPacket( &data2 );
 	}
 
+	if( myCorpse != NULL )
+		myCorpse->ResetDeathClock();
+	
 	switch( pMapinfo->mapid )
 	{
 		case 550: //The Eye
@@ -4942,7 +4950,9 @@
 							detectRange = 5.0f + getLevel() + 0.2f * (float)(GetStealthDetectBonus() - pObj->GetStealthLevel());
 						else
 							detectRange = 65.0f + 0.2f * (float)(GetStealthDetectBonus() - pObj->GetStealthLevel());
-
+						// Hehe... stealth skill is increased by 5 each level and detection skill is increased by 5 each level too.
+						// This way, a level 70 should easily be able to detect a level 4 rogue (level 4 because that's when you get stealth)
+						//	detectRange += 0.2f * ( getLevel() - pObj->getLevel() );
 						if(detectRange < 1.0f) detectRange = 1.0f; // Minimum Detection Range = 1yd
 					}
 					else // stealthed player is behind us
@@ -4953,8 +4963,8 @@
 
 					detectRange += GetFloatValue(UNIT_FIELD_BOUNDINGRADIUS); // adjust range for size of player
 					detectRange += pObj->GetFloatValue(UNIT_FIELD_BOUNDINGRADIUS); // adjust range for size of stealthed player
-
-					if(GetDistance2dSq(pObj) > detectRange * detectRange)
+					//sLog.outString( "Player::CanSee(%s): detect range = %f yards (%f ingame units), cansee = %s , distance = %f" , pObj->GetName() , detectRange , detectRange * detectRange , ( GetDistance2dSq(pObj) > detectRange * detectRange ) ? "yes" : "no" , GetDistanceSq(pObj) );
+					if(GetDistanceSq(pObj) > detectRange * detectRange)
 						return bGMTagOn; // GM can see stealthed players
 				}
 
@@ -6780,8 +6790,8 @@
 {
 	uint32 destsize = size + size/10 + 16;
 	int rate = sWorld.getIntRate(INTRATE_COMPRESSION);
-	if(size > 30000)
-		rate = 9;		// max
+	if(size >= 40000 && rate < 6)
+		rate = 6;
 
 	// set up stream
 	z_stream stream;
@@ -6796,7 +6806,7 @@
 	}
 
 	uint8 *buffer = new uint8[destsize];
-	memset(buffer,0,destsize);	/* fix umr - burlex */
+	//memset(buffer,0,destsize);	/* fix umr - burlex */
 	
 	// set up stream pointers
 	stream.next_out  = (Bytef*)buffer+4;
@@ -7951,8 +7961,21 @@
 		if ( sp->c_is_flags & SPELL_FLAG_IS_EXPIREING_WITH_PET )
 			continue; //do not load auras that only exist while pet exist. We should recast these when pet is created anyway
 
-		Aura * a = new Aura(sp,(*i).dur,this,this);
+		Aura * a;
+		if(sp->Id == 8326 || sp->Id == 9036 || sp->Id == 20584 || sp->Id == 150007)		// death auras
+		{
+			if(!isDead())
+				continue;
 
+			a = new Aura(sp,(*i).dur,this,this);
+			a->SetNegative();
+		}
+		else
+		{
+			a = new Aura(sp,(*i).dur,this,this);
+		}
+		
+
 		for(uint32 x =0;x<3;x++)
         {
 		    if(sp->Effect[x]==SPELL_EFFECT_APPLY_AURA)
@@ -7961,8 +7984,6 @@
 		    }
         }
 
-		if(a->GetSpellId() == 8326 || a->GetSpellId() == 9036 || a->GetSpellId() == 20584 || a->GetSpellId() == 150007)		// death auras
-			a->SetNegative();
 
 		this->AddAura(a);		//FIXME: must save amt,pos/neg
 		//Somehow we should restore number of appearence. Right now i have no idea how :(
@@ -8318,15 +8339,16 @@
 
 void Player::SetShapeShift(uint8 ss)
 {
-	uint8 old_ss = GetByte(UNIT_FIELD_BYTES_1, 2);
-	SetByte(UNIT_FIELD_BYTES_1,2,ss);
+	uint8 old_ss = GetByte( UNIT_FIELD_BYTES_1, 2 );
+	SetByte( UNIT_FIELD_BYTES_1, 2, ss );
+
 	//remove auras that we should not have
-	for(uint32 x =0;x<MAX_AURAS+MAX_PASSIVE_AURAS;x++)
+	for( uint32 x = 0; x < MAX_AURAS + MAX_PASSIVE_AURAS; x++ )
 	{
-		if(m_auras[x])
+		if( m_auras[x] != NULL )
 		{
 			uint32 reqss = m_auras[x]->GetSpellProto()->RequiredShapeShift;
-			if(reqss && m_auras[x]->IsPositive())
+			if( reqss != 0 && m_auras[x]->IsPositive() )
 			{
 				if( old_ss > 0 )
 				{
@@ -8339,22 +8361,24 @@
 				}
 			}
 
-			if (this->getClass()==DRUID)
+			if( this->getClass() == DRUID )
 			{
-				for(uint32 y = 0; y < 3; ++y)
+				for (uint32 y = 0; y < 3; ++y )
 				{
-					switch (m_auras[x]->GetSpellProto()->EffectApplyAuraName[y])
+					switch( m_auras[x]->GetSpellProto()->EffectApplyAuraName[y])
 					{
-					case 26: //Root
-					case 31: //Movement speed
-					case 5:  //Confuse (polymorph)
+					case SPELL_AURA_MOD_ROOT: //Root
+					case SPELL_AURA_MOD_DECREASE_SPEED: //Movement speed
+					case SPELL_AURA_MOD_CONFUSE:  //Confuse (polymorph)
+						{
 							m_auras[x]->Remove();
+						}
 						break;
 					default:
 						break;
 					}
 
-					if(m_auras[x] == NULL)
+					if( m_auras[x] == NULL )
 						break;
 				}
 			}
@@ -8414,7 +8438,7 @@
 	int ss = GetShapeShift();
 /////////////////MAIN HAND
 		float ap_bonus = GetAP()/14000.0f;
-		delta = float(GetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS)-GetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_NEG));
+		delta = (float)GetUInt32Value( PLAYER_FIELD_MOD_DAMAGE_DONE_POS ) - (float)GetUInt32Value( PLAYER_FIELD_MOD_DAMAGE_DONE_NEG );
 		if(IsInFeralForm())
 		{
 			uint32 lev = getLevel();
@@ -8431,9 +8455,12 @@
 			//SetFloatValue(UNIT_FIELD_MINDAMAGE,r);
 			//SetFloatValue(UNIT_FIELD_MAXDAMAGE,r);
 
-			SetFloatValue(UNIT_FIELD_MINDAMAGE,r * 0.9f);
-			SetFloatValue(UNIT_FIELD_MAXDAMAGE,r * 1.1f);
+			r *= 0.9f;
+			r *= 1.1f;
 
+			SetFloatValue(UNIT_FIELD_MINDAMAGE,r>0?r:0);
+			SetFloatValue(UNIT_FIELD_MAXDAMAGE,r>0?r:0);
+
 			return;
 		}
 //////no druid ss	
@@ -8475,7 +8502,7 @@
 					cr=itr->second;
 			}
 		}
-		SetUInt32Value(PLAYER_FIELD_COMBAT_RATING_20,cr);
+		SetUInt32Value( PLAYER_RATING_MODIFIER_MELEE_MAIN_HAND_SKILL, cr );
 		/////////////// MAIN HAND END
 
 		/////////////// OFF HAND START
@@ -8513,7 +8540,7 @@
 					cr=itr->second;
 			}
 		}
-		SetUInt32Value(PLAYER_FIELD_COMBAT_RATING_21,cr);
+		SetUInt32Value( PLAYER_RATING_MODIFIER_MELEE_OFF_HAND_SKILL, cr );
 
 /////////////second hand end
 ///////////////////////////RANGED
@@ -8567,7 +8594,7 @@
 			}
 		
 		}
-		SetUInt32Value(PLAYER_FIELD_COMBAT_RATING_1,cr);
+		SetUInt32Value( PLAYER_RATING_MODIFIER_RANGED_SKILL, cr );
 
 /////////////////////////////////RANGED end
 		tmp = 1;
@@ -8592,7 +8619,7 @@
 		ap_bonus = AP_owerride/14000.0f;
 	else 
 		ap_bonus = GetAP()/14000.0f;
-	delta = float(GetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS)-GetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_NEG));
+	delta = (float)GetUInt32Value( PLAYER_FIELD_MOD_DAMAGE_DONE_POS ) - (float)GetUInt32Value( PLAYER_FIELD_MOD_DAMAGE_DONE_NEG );
 	if(IsInFeralForm())
 	{
 		uint32 lev = getLevel();
@@ -9373,6 +9400,7 @@
 		string escaped_note2 = m_playerInfo->officerNote ?  CharacterDatabase.EscapeString(m_playerInfo->officerNote) : "";
 		CharacterDatabase.Execute("UPDATE characters SET guildid=%u, guildRank=%u, publicNote='%s', officerNote='%s' WHERE guid = %u",
 			GetGuildId(), GetGuildRank(), escaped_note.c_str(), escaped_note2.c_str(), m_uint32Values[OBJECT_FIELD_GUID]);
+
 	}
 	else
 	{
@@ -9708,20 +9736,25 @@
 		SpellEntry *spellInfo = dbcSpell.LookupEntry(SpellID);
 		if( spellInfo->c_is_flags & SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_PET_OWNER )
 		{
+			this->RemoveAllAuras( SpellID, this->GetGUID() ); //this is required since unit::addaura does not check for talent stacking
 			SpellCastTargets targets( this->GetGUID() );
 			Spell *spell = new Spell(this, spellInfo ,true, NULL);	//we cast it as a proc spell, maybe we should not !
 			spell->prepare(&targets);
 		}
 		if( spellInfo->c_is_flags & SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET )
 		{
+			this->RemoveAllAuras( SpellID, this->GetGUID() ); //this is required since unit::addaura does not check for talent stacking
 			SpellCastTargets targets( new_pet->GetGUID() );
 			Spell *spell = new Spell(this, spellInfo ,true, NULL);	//we cast it as a proc spell, maybe we should not !
 			spell->prepare(&targets);
 		}
 	}
+	//there are talents that stop working after you gain pet
 	for(uint32 x=0;x<MAX_AURAS+MAX_PASSIVE_AURAS;x++)
 		if(m_auras[x] && m_auras[x]->GetSpellProto()->c_is_flags & SPELL_FLAG_IS_EXPIREING_ON_PET)
 			m_auras[x]->Remove();
+	//pet should inherit some of the talents from caster
+	//new_pet->InheritSMMods(); //not required yet. We cast full spell to have visual effect too
 }
 
 //if pet/charm died or whatever hapened we should call this function
Index: Player.h
===================================================================
--- Player.h	(revision 187)
+++ Player.h	(working copy)
@@ -33,7 +33,6 @@
 class Charter;
 class LFGMatch;
 struct LevelInfo;
-#define myabs(a) (a<0)?(-a):a
 #define MAX_PET_NO 3
 #define PLAYER_NORMAL_RUN_SPEED 7.0f
 #define PLAYER_NORMAL_SWIM_SPEED 4.722222f
@@ -658,6 +657,7 @@
 #define UNDERWATERSTATE_FATIGUE	     16
 #define UNDERWATERSTATE_LAVA		 32
 #define UNDERWATERSTATE_SLIME		 64
+
 enum TRADE_STATUS
 {
 	TRADE_STATUS_PLAYER_BUSY	    = 0x00,
@@ -956,12 +956,11 @@
 	ASCENT_INLINE bool IsInFeralForm()
 	{
 		int s = GetShapeShift();
-		if(!s)return false;
+		if( s <= 0 )
+			return false;
+
 		//Fight forms that do not use player's weapon
-		if(s==1 || s == 5 || s == 8)
-			return true;
-		else 
-			return false;
+		return ( s == 1 || s == 5 || s == 8 );
 	}
 	void CalcDamage();
 	uint32 GetMainMeleeDamage(uint32 AP_owerride); //i need this for windfury
@@ -1817,6 +1816,7 @@
 	bool m_setwaterwalk;
 	bool m_setflycheat;
 	uint32 m_areaspirithealer_guid;
+	bool m_finishingmovesdodge;
 
 	ASCENT_INLINE bool IsAttacking() {return m_attacking; }
 
Index: Quest.cpp
===================================================================
--- Quest.cpp	(revision 187)
+++ Quest.cpp	(working copy)
@@ -140,10 +140,14 @@
 	m_quest = NULL;
 	mDirty = false;
 	m_slot = -1;
-	_questScript = NULL;
 	completed=0;
 }
 
+QuestLogEntry::~QuestLogEntry()
+{
+
+}
+
 void QuestLogEntry::Init(Quest* quest, Player* plr, uint32 slot)
 {
 	ASSERT(quest);
@@ -183,8 +187,7 @@
 	else
 		m_time_left = 0;
 
-	LoadScript();
-	CALL_QUESTSCRIPT_EVENT(this, OnQuestStart)(plr);
+	CALL_QUESTSCRIPT_EVENT(this, OnQuestStart)(plr, this);
 }
 
 void QuestLogEntry::ClearAffectedUnits()
@@ -242,16 +245,16 @@
 	for(int i = 0; i < 4; ++i)
 	{
 		m_explored_areas[i] = fields[f].GetUInt32();	f++;
-		CALL_QUESTSCRIPT_EVENT(this, OnExploreArea)(m_explored_areas[i], m_plr);
+		CALL_QUESTSCRIPT_EVENT(this, OnExploreArea)(m_explored_areas[i], m_plr, this);
 	}
 
 	for(int i = 0; i < 4; ++i)
 	{
 		m_mobcount[i] = fields[f].GetUInt32();	f++;
 		if(GetQuest()->required_mobtype[i] == QUEST_MOB_TYPE_CREATURE)
-			CALL_QUESTSCRIPT_EVENT(this, OnCreatureKill)(GetQuest()->required_mob[i], m_plr);
+			CALL_QUESTSCRIPT_EVENT(this, OnCreatureKill)(GetQuest()->required_mob[i], m_plr, this);
 		else
-			CALL_QUESTSCRIPT_EVENT(this, OnGameObjectActivate)(GetQuest()->required_mob[i], m_plr);
+			CALL_QUESTSCRIPT_EVENT(this, OnGameObjectActivate)(GetQuest()->required_mob[i], m_plr, this);
 	}
 	mDirty = false;
 	return true;
@@ -395,7 +398,7 @@
 	data.SetOpcode(SMSG_QUESTUPDATE_COMPLETE);
 	data << m_quest->id;
 	m_plr->GetSession()->SendPacket(&data);
-	CALL_QUESTSCRIPT_EVENT(this, OnQuestComplete)(m_plr);
+	CALL_QUESTSCRIPT_EVENT(this, OnQuestComplete)(m_plr, this);
 }
 
 void QuestLogEntry::SendUpdateAddKill(uint32 i)
@@ -403,21 +406,3 @@
 	sQuestMgr.SendQuestUpdateAddKill(m_plr, m_quest->id, m_quest->required_mob[i], m_mobcount[i], m_quest->required_mobcount[i], 0);
 }
 
-void QuestLogEntry::LoadScript()
-{
-	//_questScript = sScriptMgr.CreateQuestScriptClassForEntry(GetQuest()->id, this);
-}
-
-void QuestLogEntry::CallScriptUpdate()
-{
-	ASSERT(_questScript);
-	_questScript->EventUpdate();
-}
-
-QuestLogEntry::~QuestLogEntry()
-{
-	//sEventMgr.RemoveEvents(this);
-	if(_questScript != 0)
-		_questScript->Destroy();
-}
-
Index: Quest.h
===================================================================
--- Quest.h	(revision 187)
+++ Quest.h	(working copy)
@@ -108,6 +108,7 @@
 	QUEST_SHARE_MSG_FINISH_QUEST	= 8,
 };
 
+class QuestScript;
 #pragma pack(push,1)
 struct Quest
 {
@@ -185,6 +186,8 @@
 	uint32 required_mobtype[4];
 	uint32 count_reward_item;
 	uint32 reward_xp_as_money;
+
+	QuestScript* pQuestScript;
 };
 #pragma pack(pop)
 
@@ -195,7 +198,7 @@
 };
 
 class QuestScript;
-#define CALL_QUESTSCRIPT_EVENT(obj, func) if(static_cast<QuestLogEntry*>(obj)->GetScript() != NULL) static_cast<QuestLogEntry*>(obj)->GetScript()->func
+#define CALL_QUESTSCRIPT_EVENT(obj, func) if(static_cast<QuestLogEntry*>(obj)->GetQuest()->pQuestScript != NULL) static_cast<QuestLogEntry*>(obj)->GetQuest()->pQuestScript->func
 
 class SERVER_DECL QuestLogEntry : public EventableObject
 {
@@ -236,13 +239,8 @@
 		return PLAYER_QUEST_LOG_1_1 + (slot * 3);
 	}
 
-	ASCENT_INLINE QuestScript * GetScript() { return _questScript; }
-	void LoadScript();
-	void CallScriptUpdate();
-
 private:
 	uint32 completed;
-	QuestScript *_questScript;
 
 	bool mInitialized;
 	bool mDirty;
Index: QuestHandler.cpp
===================================================================
--- QuestHandler.cpp	(revision 187)
+++ QuestHandler.cpp	(working copy)
@@ -297,7 +297,7 @@
 		|| !hasquest)
 	{
 		// We've got a hacker. Disconnect them.
-		sCheatLog.writefromsession(this, "tried to accept incompatible quest %u from %u.", qst->id, qst_giver->GetEntry());
+		//sCheatLog.writefromsession(this, "tried to accept incompatible quest %u from %u.", qst->id, qst_giver->GetEntry());
 		//Disconnect();
 		return;
 	}
Index: QuestMgr.cpp
===================================================================
--- QuestMgr.cpp	(revision 187)
+++ QuestMgr.cpp	(working copy)
@@ -51,10 +51,7 @@
 		status = QMGR_QUEST_AVAILABLE;
 	else
     {
-        if(isRepeatableQuestFinished(plr, qst))
-            return QMGR_QUEST_FINISHED;
-        else
-		    return QMGR_QUEST_REPEATABLE;
+		status = QMGR_QUEST_REPEATABLE;
     }
 
 	if (plr->getLevel() < qst->min_level && !skiplevelcheck)
@@ -602,7 +599,7 @@
 					// (auto-dirtys it)
 					qle->SetMobCount( j, qle->m_mobcount[j] + 1 );
 					qle->SendUpdateAddKill( j );
-					CALL_QUESTSCRIPT_EVENT( qle, OnGameObjectActivate )( entry, plr );
+					CALL_QUESTSCRIPT_EVENT( qle, OnGameObjectActivate )( entry, plr, qle );
 
 					if( qle->CanBeFinished() )
 						qle->SendQuestComplete();
@@ -645,7 +642,7 @@
 						// add another kill.(auto-dirtys it)
 						qle->SetMobCount( j, qle->m_mobcount[j] + 1 );
 						qle->SendUpdateAddKill( j );
-						CALL_QUESTSCRIPT_EVENT( qle, OnCreatureKill)( entry, plr );
+						CALL_QUESTSCRIPT_EVENT( qle, OnCreatureKill)( entry, plr, qle );
 						qle->UpdatePlayerFields();
 						break;
 					}
@@ -661,7 +658,9 @@
 	{
 		if(Group* pGroup = plr->GetGroup())
 		{
-			if(pGroup->GetGroupType() != GROUP_TYPE_PARTY) return;  // Raid's don't get shared kills.
+//			removed by Zack How the hell will healers get the kills then ?
+//			if(pGroup->GetGroupType() != GROUP_TYPE_PARTY) 
+//				return;  // Raid's don't get shared kills.
 
 			GroupMembersSet::iterator gitr;
 			pGroup->Lock();
@@ -691,7 +690,7 @@
 										// (auto-dirtys it)
 										qle->SetMobCount(j, qle->m_mobcount[j] + 1);
 										qle->SendUpdateAddKill( j );
-										CALL_QUESTSCRIPT_EVENT( qle, OnCreatureKill )( entry, plr );
+										CALL_QUESTSCRIPT_EVENT( qle, OnCreatureKill )( entry, plr, qle );
 										qle->UpdatePlayerFields();
 
 										// lua stuff
@@ -770,7 +769,7 @@
 				if( qle->GetQuest()->required_item[j] == entry )
 				{
 					pcount = plr->GetItemInterface()->GetItemCount(entry, true);
-					CALL_QUESTSCRIPT_EVENT(qle, OnPlayerItemPickup)(entry, pcount, plr);
+					CALL_QUESTSCRIPT_EVENT(qle, OnPlayerItemPickup)(entry, pcount, plr, qle);
 					if(pcount < qle->GetQuest()->required_itemcount[j])
 					{
 						WorldPacket data(8);
@@ -808,7 +807,7 @@
 					!qle->m_explored_areas[j])
 				{
 					qle->SetTrigger(j);
-					CALL_QUESTSCRIPT_EVENT(qle, OnExploreArea)(qle->m_explored_areas[j], plr);
+					CALL_QUESTSCRIPT_EVENT(qle, OnExploreArea)(qle->m_explored_areas[j], plr, qle);
 					qle->UpdatePlayerFields();
 					if(qle->CanBeFinished())
 					{
@@ -871,7 +870,7 @@
 		    return;
     }
     BuildQuestComplete(plr, qst);
-    if(!qst->is_repeatable) CALL_QUESTSCRIPT_EVENT(qle, OnQuestComplete)(plr);
+    if(!qst->is_repeatable) CALL_QUESTSCRIPT_EVENT(qle, OnQuestComplete)(plr, qle);
 	LUA_ON_QUEST_EVENT(plr,qst->id,QUEST_EVENT_ON_COMPLETE,qst_giver);
 
 	if(!qst->is_repeatable) 
@@ -897,7 +896,7 @@
 	{
 		if(!((Creature*)qst_giver)->HasQuest(qst->id, 2))
 		{
-			sCheatLog.writefromsession(plr->GetSession(), "tried to finish quest from invalid npc.");
+			//sCheatLog.writefromsession(plr->GetSession(), "tried to finish quest from invalid npc.");
 			plr->GetSession()->Disconnect();
 			return;
 		}
Index: QuestMgr.h
===================================================================
--- QuestMgr.h	(revision 187)
+++ QuestMgr.h	(working copy)
@@ -30,8 +30,6 @@
 
 typedef std::list<QuestRelation *> QuestRelationList;
 
-#define CALL_QUESTSCRIPT_EVENT(obj, func) if(static_cast<QuestLogEntry*>(obj)->GetScript() != NULL) static_cast<QuestLogEntry*>(obj)->GetScript()->func
-
 class SERVER_DECL QuestMgr :  public Singleton < QuestMgr >
 {
 public:
Index: RecallCommands.cpp
===================================================================
--- RecallCommands.cpp	(revision 187)
+++ RecallCommands.cpp	(working copy)
@@ -30,7 +30,7 @@
 	if( m_session == NULL )
 		return false;
 
-	QueryResult *result = WorldDatabase.Query( "SELECT * FROM recall" );
+	QueryResult *result = WorldDatabase.Query( "SELECT * FROM recall ORDER BY name" );
 
 	if( result == NULL)
 		return false;
@@ -181,7 +181,7 @@
 	Player * plr = objmgr.GetPlayer(player, false);
 	if(!plr) return false;
 
-	QueryResult *result = WorldDatabase.Query( "SELECT * FROM recall" );
+	QueryResult *result = WorldDatabase.Query( "SELECT * FROM recall ORDER BY name" );
 	if(!result)
 		return false;
 
Index: ScriptMgr.cpp
===================================================================
--- ScriptMgr.cpp	(revision 187)
+++ ScriptMgr.cpp	(working copy)
@@ -222,6 +222,15 @@
 	_customgossipscripts.insert(gs);
 }
 
+void ScriptMgr::register_quest_script(uint32 entry, QuestScript * qs)
+{
+	Quest * q = QuestStorage.LookupEntry( entry );
+	if( q != NULL )
+		q->pQuestScript = qs;
+
+	_questscripts.insert( qs );
+}
+
 CreatureAIScript* ScriptMgr::CreateAIScriptClassForEntry(Creature* pCreature)
 {
 	CreatureCreateMap::iterator itr = _creatures.find(pCreature->GetEntry());
@@ -324,20 +333,6 @@
 
 /* QuestScript Stuff */
 
-QuestScript::QuestScript(QuestLogEntry *qle) : _qLogEntry(qle)
-{
-}
-
-void QuestScript::RegisterQuestEvent(uint32 frequency)
-{
-	sEventMgr.AddEvent(_qLogEntry, &QuestLogEntry::CallScriptUpdate, EVENT_SCRIPT_UPDATE_EVENT, frequency, 0,0);
-}
-
-void QuestScript::RemoveQuestEvent()
-{
-	sEventMgr.RemoveEvents(_qLogEntry, EVENT_SCRIPT_UPDATE_EVENT);
-}
-
 /* Gossip Stuff*/
 
 GossipScript::GossipScript()
@@ -658,11 +653,18 @@
 
 bool HookInterface::OnLogoutRequest(Player * pPlayer)
 {
-	OUTER_LOOP_BEGIN_COND(SERVER_HOOK_EVENT_ON_LOGOUT, tOnLogoutRequest)
+	OUTER_LOOP_BEGIN_COND(SERVER_HOOK_EVENT_ON_LOGOUT_REQUEST, tOnLogoutRequest)
 		ret_val = (call)(pPlayer);
 	OUTER_LOOP_END_COND
 }
 
+void HookInterface::OnLogout(Player * pPlayer)
+{
+	OUTER_LOOP_BEGIN(SERVER_HOOK_EVENT_ON_LOGOUT, tOnLogout)
+		(call)(pPlayer);
+	OUTER_LOOP_END
+}
+
 void HookInterface::OnQuestAccept(Player * pPlayer, Quest * pQuest)
 {
 	OUTER_LOOP_BEGIN(SERVER_HOOK_EVENT_ON_QUEST_ACCEPT, tOnQuestAccept)
Index: ScriptMgr.h
===================================================================
--- ScriptMgr.h	(revision 187)
+++ ScriptMgr.h	(working copy)
@@ -72,6 +72,7 @@
 typedef bool(*tOnCastSpell)(Player * pPlayer, SpellEntry * pSpell);
 typedef void(*tOnTick)();
 typedef bool(*tOnLogoutRequest)(Player * pPlayer);
+typedef void(*tOnLogout)(Player * pPlayer);
 typedef void(*tOnQuestAccept)(Player * pPlayer, Quest * pQuest);
 typedef void(*tOnZone)(Player * pPlayer, uint32 Zone);
 typedef bool(*tOnChat)(Player * pPlayer, uint32 Type, uint32 Lang, const char * Message, const char * Misc);
@@ -105,6 +106,7 @@
 typedef HM_NAMESPACE::hash_map<uint32, exp_handle_dummy_aura> HandleDummyAuraMap;
 typedef HM_NAMESPACE::hash_map<uint32, exp_handle_dummy_spell> HandleDummySpellMap;
 typedef set<GossipScript*> CustomGossipScripts;
+typedef set<QuestScript*> QuestScripts;
 typedef list<void*> ServerHookList;
 typedef list<SCRIPT_MODULE> LibraryHandleMap;
 
@@ -134,6 +136,7 @@
 	void register_dummy_spell(uint32 entry, exp_handle_dummy_spell callback);
 	void register_hook(ServerHookEvents event, void * function_pointer);
 	void register_item_gossip_script(uint32 entry, GossipScript * gs);
+	void register_quest_script(uint32 entry, QuestScript * qs);
 
 	ASCENT_INLINE GossipScript * GetDefaultGossipScript() { return DefaultGossipScript; }
 
@@ -146,6 +149,7 @@
 	ServerHookList _hooks[NUM_SERVER_HOOKS];
 	GossipScript * DefaultGossipScript;
 	CustomGossipScripts _customgossipscripts;
+	QuestScripts _questscripts;
 };
 
 class SERVER_DECL CreatureAIScript
@@ -226,25 +230,16 @@
 class SERVER_DECL QuestScript
 {
 public:
-	QuestScript(QuestLogEntry* qle);
+	QuestScript() {};
 	virtual ~QuestScript() {};
 
-	virtual void OnQuestStart(Player* mTarget) {}
-	virtual void OnQuestComplete(Player* mTarget) {}
+	virtual void OnQuestStart(Player* mTarget, QuestLogEntry *qLogEntry) {}
+	virtual void OnQuestComplete(Player* mTarget, QuestLogEntry *qLogEntry) {}
 	virtual void OnQuestCancel(Player* mTarget) {}
-	virtual void OnGameObjectActivate(uint32 entry, Player* mTarget) {}
-	virtual void OnCreatureKill(uint32 entry, Player* mTarget) {}
-	virtual void OnExploreArea(uint32 areaId, Player* mTarget) {}
-	virtual void OnPlayerItemPickup(uint32 itemId, uint32 totalCount, Player* mTarget) {}
-	virtual void EventUpdate() {};
-
-	void RegisterQuestEvent(uint32 frequency);
-	void RemoveQuestEvent();
-
-	virtual void Destroy() {}
-
-protected:
-	QuestLogEntry *_qLogEntry;
+	virtual void OnGameObjectActivate(uint32 entry, Player* mTarget, QuestLogEntry *qLogEntry) {}
+	virtual void OnCreatureKill(uint32 entry, Player* mTarget, QuestLogEntry *qLogEntry) {}
+	virtual void OnExploreArea(uint32 areaId, Player* mTarget, QuestLogEntry *qLogEntry) {}
+	virtual void OnPlayerItemPickup(uint32 itemId, uint32 totalCount, Player* mTarget, QuestLogEntry *qLogEntry) {}
 };
 
 class SERVER_DECL HookInterface : public Singleton<HookInterface>
@@ -264,6 +259,7 @@
 	void OnEnterCombat(Player * pPlayer, Unit * pTarget);
 	bool OnCastSpell(Player * pPlayer, SpellEntry * pSpell);
 	bool OnLogoutRequest(Player * pPlayer);
+	void OnLogout(Player * pPlayer);
 	void OnQuestAccept(Player * pPlayer, Quest * pQuest);
 	void OnZone(Player * pPlayer, uint32 Zone);
 	bool OnChat(Player * pPlayer, uint32 Type, uint32 Lang, const char * Message, const char * Misc);
Index: SkillHandler.cpp
===================================================================
--- SkillHandler.cpp	(revision 187)
+++ SkillHandler.cpp	(working copy)
@@ -80,9 +80,9 @@
 {
 	if(!_player->IsInWorld()) return;
  	 
-	uint32 talent_id, requested_rank;
+	uint32 talent_id, requested_rank, unk;
 	unsigned int i;
-	recv_data >> talent_id >> requested_rank;
+	recv_data >> talent_id >> requested_rank >> unk;
 
 	uint32 CurTalentPoints =  GetPlayer()->GetUInt32Value(PLAYER_CHARACTER_POINTS1);
 	if(CurTalentPoints == 0)
Index: Spell.cpp
===================================================================
--- Spell.cpp	(revision 187)
+++ Spell.cpp	(working copy)
@@ -37,7 +37,7 @@
 	m_unitTarget = m_itemTarget = 0;
 	m_srcX = m_srcY = m_srcZ = m_destX = m_destY = m_destZ = 0;
 	m_strTarget = "";
-
+	
 	data >> m_targetMask;
 	WoWGuid guid;
 
@@ -133,7 +133,7 @@
 		    i_caster = NULL;
 		    p_caster = NULL;
 		    u_caster = static_cast< Unit* >( Caster );
-		    if( u_caster->IsPet() != NULL && static_cast< Pet* >( u_caster)->GetPetOwner() != NULL && static_cast< Pet* >( u_caster )->GetPetOwner()->DuelingWith != NULL )
+		    if( u_caster->IsPet() && static_cast< Pet* >( u_caster)->GetPetOwner() != NULL && static_cast< Pet* >( u_caster )->GetPetOwner()->DuelingWith != NULL )
 			    duelSpell = true;
         }break;
 
@@ -672,7 +672,10 @@
 			res =  (Rand(resistchance) ? SPELL_DID_HIT_RESIST : SPELL_DID_HIT_SUCCESS);
 
 		if (res == SPELL_DID_HIT_SUCCESS) // proc handling. mb should be moved outside this function
+		{
 			target->HandleProc(PROC_ON_SPELL_LAND_VICTIM,this->u_caster,this->m_spellInfo);
+			this->u_caster->HandleProc(PROC_ON_SPELL_LAND,target,this->m_spellInfo);
+		}
 
 		return res;
 	}
@@ -988,7 +991,6 @@
 	//if( p_caster != NULL )
 	//   m_castTime -= 100;	  // session update time
 
-	SendSpellStart();
 
 	if( !m_triggeredSpell && p_caster != NULL && p_caster->CooldownCheat )
 		p_caster->ClearCooldownForSpell( m_spellInfo->Id );
@@ -1031,6 +1033,8 @@
 	}
 	else
 	{
+		SendSpellStart();
+
 		// start cooldown handler
 		if( p_caster != NULL && p_caster->CastTimeCheat && !m_triggeredSpell )
 		{
@@ -1687,9 +1691,13 @@
 		}
 		if(m_Delayed)
 		{
-			Unit *pTarget = p_caster->GetMapMgr()->GetUnit(m_caster->GetUInt64Value(UNIT_FIELD_CHANNEL_OBJECT));
-			if(!pTarget)
-				pTarget = p_caster->GetMapMgr()->GetUnit(p_caster->GetSelection());
+			Unit *pTarget = NULL;
+			if( p_caster->IsInWorld() )
+			{
+				pTarget = p_caster->GetMapMgr()->GetUnit(m_caster->GetUInt64Value(UNIT_FIELD_CHANNEL_OBJECT));
+				if(!pTarget)
+					pTarget = p_caster->GetMapMgr()->GetUnit(p_caster->GetSelection());
+			}
 			   
 			if(pTarget)
 			{
@@ -1739,7 +1747,7 @@
 enum SpellStartFlags
 {
     //0x01
-    SPELL_START_FLAG_DEFAULT = 0x02, // atm set as defailt flag
+    SPELL_START_FLAG_DEFAULT = 0x02, // atm set as default flag
     //0x04
     //0x08
     //0x10
@@ -2203,6 +2211,14 @@
 	{
 		SM_FIValue(u_caster->SM_FCost,&cost,m_spellInfo->SpellGroupType);
 		SM_PIValue(u_caster->SM_PCost,&cost,m_spellInfo->SpellGroupType);
+#ifdef COLLECTION_OF_UNTESTED_STUFF_AND_TESTERS
+		int32 spell_flat_modifers=0;
+		int32 spell_pct_modifers=1;
+		SM_FIValue(u_caster->SM_FCost,&spell_flat_modifers,m_spellInfo->SpellGroupType);
+		SM_PIValue(u_caster->SM_PCost,&spell_pct_modifers,m_spellInfo->SpellGroupType);
+		if(spell_flat_modifers!=0 || spell_pct_modifers!=0)
+			printf("!!!!!spell cost mod flat %f , spell cost mod pct %f , spell cost %f, spell group %u\n",spell_flat_modifers,spell_pct_modifers,cost,m_spellInfo->SpellGroupType);
+#endif
 	}
 
 	if (cost <=0)
@@ -2404,6 +2420,10 @@
 	}
 	else
 		sLog.outError("SPELL: unknown effect %u spellid %u",m_spellInfo->Effect[i], m_spellInfo->Id);
+
+	// remove stealth!
+	if( unitTarget )
+	unitTarget->RemoveAllAuraType( SPELL_AURA_MOD_STEALTH );
 }
 
 void Spell::HandleAddAura(uint64 guid)
@@ -2577,9 +2597,14 @@
 	if( p_caster != NULL )
 	{
 #ifdef COLLISION
-		if( m_spellInfo->Attributes & ATTRIBUTES_ONLY_OUTDOORS )
+		if (m_spellInfo->MechanicsType == MECHANIC_MOUNTED)
 		{
-			if( CollideInterface.IsIndoorMod( p_caster->GetMapId(), p_caster->GetPositionV() ) )
+			if (CollideInterface.IsIndoor( p_caster->GetMapId(), p_caster->GetPositionNC() ))
+				return SPELL_FAILED_NO_MOUNTS_ALLOWED;
+		}
+		else if( m_spellInfo->Attributes & ATTRIBUTES_ONLY_OUTDOORS )
+		{
+			if( !CollideInterface.IsOutdoor( p_caster->GetMapId(), p_caster->GetPositionNC() ) )
 				return SPELL_FAILED_ONLY_OUTDOORS;
 		}
 #endif
@@ -2976,6 +3001,10 @@
 					if(!itm || itm->GetDurability() == 0)
 						return SPELL_FAILED_NO_AMMO;
 				}
+#ifdef COLLISION
+				if (p_caster->GetMapId() == target->GetMapId() && !CollideInterface.CheckLOS(p_caster->GetMapId(),p_caster->GetPositionNC(),target->GetPositionNC()))
+					return SPELL_FAILED_LINE_OF_SIGHT;
+#endif
 
 				if(target->IsPlayer())
 				{
@@ -3264,6 +3293,16 @@
 	if (m_spellInfo->MechanicsType == 16 && ((target) ? target->HasAura(11196) : u_caster->HasAura(11196)))
 		return SPELL_FAILED_DAMAGE_IMMUNE;
 
+	//Checking for Debuffs that dont allow power word:shield, those Pala spells, ice block or use first aid, hacky, is there any way to check if he has "immune mechanic"?
+	if (m_spellInfo->MechanicsType == 19 && ((target) ? target->HasAura(6788) : u_caster->HasAura(6766))) //Weakened Soul
+		return SPELL_FAILED_DAMAGE_IMMUNE;
+	if (m_spellInfo->MechanicsType == 25 && ((target) ? target->HasAura(25771) : u_caster->HasAura(25771))) //Forbearance
+		return SPELL_FAILED_DAMAGE_IMMUNE;
+	if (m_spellInfo->NameHash == SPELL_HASH_ICE_BLOCK && u_caster->HasAura(41425))
+		return SPELL_FAILED_DAMAGE_IMMUNE;
+	if (m_spellInfo->MechanicsType == 16 && ((target) ? target->HasAura(11196) : u_caster->HasAura(11196)))
+		return SPELL_FAILED_DAMAGE_IMMUNE;
+
 	// Special State Checks (for creatures & players)
 	if( u_caster )
 	{
@@ -3566,15 +3605,14 @@
 					if(it)
 						value += float2int32(150 + float(it->GetProto()->Damage[0].Min)/float(it->GetProto()->Delay)*2.8f);
 				}
-				if(target->HasNegativeAura(CREATURE_SPELL_TO_DAZE))
-					value += 175;
 			}
+			if(target && target->HasNegativeAura(CREATURE_SPELL_TO_DAZE))
+				value += 175;
 			value += (uint32)(u_caster->GetRAP()*0.2);
 		}
 	}
     // HACK FIX
-    else if( m_spellInfo->Id == 34428 || m_spellInfo->Id ==23881 ||m_spellInfo->Id == 23892 || m_spellInfo->Id==23893 ||m_spellInfo->Id == 23894||
-		    m_spellInfo->Id == 25251 || m_spellInfo->Id == 30335)
+    else if( m_spellInfo->NameHash == SPELL_HASH_VICTORY_RUSH )
 	{//causing ${$AP*$m1/100} damage
 		if(i==0 && u_caster)
 			value = (value*u_caster->GetAP())/100;
@@ -3591,6 +3629,36 @@
 				value=(int32)ceilf((float(value * 3) + ceilf((ap*0.06f))) / 3.0f);
 		}
 	}
+	else if( m_spellInfo->NameHash == SPELL_HASH_GARROTE )
+	{
+		// WoWWiki says +( 0.18 * attack power / number of ticks )
+		// Tooltip gives no specific reading, but says ", increased by your attack power.".
+		if( u_caster != NULL )
+		{
+			float ap = (float)u_caster->GetAP();
+			if( i == 0 )
+			{
+				value += (uint32) ceilf( ( ap * 0.18f ) / 6 );
+			}
+		}
+
+	}
+	else if( m_spellInfo->NameHash == SPELL_HASH_RUPTURE )
+	{
+		/* 
+		1pt = Attack Power * 0.04 + x
+		2pt = Attack Power * 0.10 + y
+		3pt = Attack Power * 0.18 + z
+		4pt = Attack Power * 0.21 + a
+		5pt = Attack Power * 0.24 + b
+		*/
+		if( u_caster->IsPlayer() )
+		{
+			float ap = (float)u_caster->GetAP();
+			float cp = (float)static_cast<Player*>(u_caster)->m_comboPoints;
+			value += (uint32) ceilf( ( ap * ( 0.04f * cp ) ) / ( ( 6 + ( cp * 2 ) ) / 2 ) );
+		}
+	}
 	else if( m_spellInfo->NameHash == SPELL_HASH_RIP ) //rip
 	{
 		if( u_caster != NULL ) 
@@ -3643,6 +3711,7 @@
 			{
 				//DK:FIXME->yeni bir map olutur
                 // Capt: WHAT THE FUCK DOES THIS MEAN....
+				// Supa: WHAT THE FUCK DOES THIS MEAN?
 				value += RandomUInt((*itrSO)->damage);
 			}
 		}
@@ -4066,7 +4135,7 @@
 	skilllinespell* skill = objmgr.GetSpellSkill(m_spellInfo->Id);
 	if( skill != NULL && static_cast< Player* >( m_caster )->_HasSkillLine( skill->skilline ) )
 	{
-		uint32 amt = static_cast< Player* >( m_caster )->_GetSkillLineCurrent( skill->skilline );
+		uint32 amt = static_cast< Player* >( m_caster )->_GetSkillLineCurrent( skill->skilline, false );
 		uint32 max = static_cast< Player* >( m_caster )->_GetSkillLineMax( skill->skilline );
 		if( amt >= max )
 			return;
Index: Spell.h
===================================================================
--- Spell.h	(revision 187)
+++ Spell.h	(working copy)
@@ -21,6 +21,7 @@
 #define __SPELL_H
 
 #include "SpellFailure.h"
+#include "StdAfx.h"
 
 class WorldSession;
 class Unit;
@@ -233,7 +234,8 @@
 //    PROC_ON_UNK_DAMAGE_VICTIM       = 0x80,//seems to be on ranged dmg victim 99% sure('each melee or ranged attack' -> flag =680 (dec))
     PROC_ON_PHYSICAL_ATTACK         = 0x100,
     PROC_ON_MELEE_ATTACK_VICTIM     = 0x200,
-    PROC_ON_ANY_ACTION              = 0x400,
+//    PROC_ON_ANY_ACTION              = 0x400,
+    PROC_ON_SPELL_LAND              = 0x400,
 //    PROC_UNK_DEFILLED               = 0x800,
     PROC_ON_RANGED_CRIT_ATTACK_VICTIM = 0x800,
     PROC_ON_CRIT_ATTACK             = 0x1000,
@@ -663,7 +665,7 @@
     SPELL_EFFECT_DUMMYMELEE,                //    121
     SPELL_EFFECT_UNKNOWN1,                  //    122
     SPELL_EFFECT_UNKNOWN2,                  //    123
-    SPELL_EFFECT_UNKNOWN3,                  //    124
+    SPELL_EFFECT_PLAYER_PULL,               //    124
     SPELL_EFFECT_UNKNOWN4,                  //    125
     SPELL_EFFECT_UNKNOWN5,                  //    126
     SPELL_EFFECT_PROSPECTING,               //    127
@@ -1069,6 +1071,7 @@
         case SPELL_EFFECT_HEALTH_FUNNEL:
         case SPELL_EFFECT_HEAL_MAX_HEALTH:
             return true;
+		default: break;
     }
     switch( sp->Effect[1] )
     {
@@ -1077,6 +1080,7 @@
         case SPELL_EFFECT_HEALTH_FUNNEL:
         case SPELL_EFFECT_HEAL_MAX_HEALTH:
             return true;
+		default: break;
     }
     switch( sp->Effect[2] )
     {
@@ -1085,6 +1089,7 @@
         case SPELL_EFFECT_HEALTH_FUNNEL:
         case SPELL_EFFECT_HEAL_MAX_HEALTH:
             return true;
+		default: break;
     }
     if( sp->Effect[0] == SPELL_EFFECT_APPLY_AURA ||
 		sp->Effect[0] == SPELL_EFFECT_APPLY_AREA_AURA )
@@ -1092,9 +1097,9 @@
         switch( sp->EffectApplyAuraName[0] )
         {
             case 8://SPELL_AURA_PERIODIC_HEAL:
-            case 34://SPELL_AURA_MOD_INCREASE_HEALTH:
             case 62://SPELL_AURA_PERIODIC_HEALTH_FUNNEL:
                 return true;
+			default: break;
         }
     }
     if( sp->Effect[1] == SPELL_EFFECT_APPLY_AURA ||
@@ -1103,9 +1108,9 @@
         switch (sp->EffectApplyAuraName[1])
         {
             case 8://SPELL_AURA_PERIODIC_HEAL:
-            case 34://SPELL_AURA_MOD_INCREASE_HEALTH:
             case 62://SPELL_AURA_PERIODIC_HEALTH_FUNNEL:
                 return true;
+			default: break;
         }
     }
     if( sp->Effect[2] == SPELL_EFFECT_APPLY_AURA ||
@@ -1114,18 +1119,14 @@
         switch( sp->EffectApplyAuraName[2] )
         {
             case 8://SPELL_AURA_PERIODIC_HEAL:
-            case 34://SPELL_AURA_MOD_INCREASE_HEALTH:
             case 62://SPELL_AURA_PERIODIC_HEALTH_FUNNEL:
                 return true;
+			default: break;
         }
     }
-	//holy light uses scripted effect which is not neceserally heal spell
-	if( sp->NameHash == SPELL_HASH_HOLY_LIGHT )
+	//flash of light, holy light uses scripted effect which is not neceserally heal spell
+	if( sp->NameHash == SPELL_HASH_HOLY_LIGHT || sp->NameHash == SPELL_HASH_FLASH_OF_LIGHT  )
 		return true;
-
-	//flash of light uses scripted effect which is not neceserally heal spell
-	if( sp->NameHash == SPELL_HASH_FLASH_OF_LIGHT )
-		return true;
 	
     return false;
 }
@@ -1154,7 +1155,7 @@
     r+=t*t;
     return ( r<=square_r);
 }
-    
+   
 ASCENT_INLINE bool IsInrange(Object * o1,Object * o2,float square_r)
 {
     return IsInrange(o1->GetPositionX(),o1->GetPositionY(),o1->GetPositionZ(),
@@ -1540,7 +1541,7 @@
     void writeSpellGoTargets( WorldPacket * data );
     void writeSpellMissedTargets( WorldPacket * data );
 
-    SpellEntry * m_spellInfo;
+    SpellEntry* m_spellInfo;
     uint32 pSpellId;
     SpellEntry *ProcedOnSpell; //some spells need to know the origins of the proc too
     SpellCastTargets m_targets;
@@ -1602,6 +1603,7 @@
     void SpellEffectScriptEffect(uint32 i);
     void SpellEffectSanctuary(uint32 i);
     void SpellEffectAddComboPoints(uint32 i);
+	void SpellEffectCreateHouse(uint32 i);
     void SpellEffectDuel(uint32 i);
     void SpellEffectStuck(uint32 i);
     void SpellEffectSummonPlayer(uint32 i);
@@ -1626,6 +1628,7 @@
     void SpellEffectSkill(uint32 i);
     void SpellEffectApplyPetAura(uint32 i);
     void SpellEffectDummyMelee(uint32 i);
+    void SpellEffectPlayerPull( uint32 i );
     void SpellEffectSpellSteal(uint32 i);
     void SpellEffectProspecting(uint32 i);
     void SpellEffectOpenLockItem(uint32 i);
@@ -1693,7 +1696,7 @@
     Object*			m_caster;
 
     // 15007 = resurecting sickness
-
+	
 	// This returns SPELL_ENTRY_Spell_Dmg_Type where 0 = SPELL_DMG_TYPE_NONE, 1 = SPELL_DMG_TYPE_MAGIC, 2 = SPELL_DMG_TYPE_MELEE, 3 = SPELL_DMG_TYPE_RANGED
 	// It should NOT be used for weapon_damage_type which needs: 0 = MELEE, 1 = OFFHAND, 2 = RANGED
 	ASCENT_INLINE uint32 GetType() { return ( m_spellInfo->Spell_Dmg_Type == SPELL_DMG_TYPE_NONE ? SPELL_DMG_TYPE_MAGIC : m_spellInfo->Spell_Dmg_Type ); }
@@ -1793,12 +1796,12 @@
             SM_FFValue(u_caster->SM_FRadius,&Rad[i],m_spellInfo->SpellGroupType);
             SM_PFValue(u_caster->SM_PRadius,&Rad[i],m_spellInfo->SpellGroupType);
 #ifdef COLLECTION_OF_UNTESTED_STUFF_AND_TESTERS
-			int spell_flat_modifers=0;
-			int spell_pct_modifers=0;
-			SM_FIValue(u_caster->SM_FRadius,&spell_flat_modifers,m_spellInfo->SpellGroupType);
-			SM_FIValue(u_caster->SM_PRadius,&spell_pct_modifers,m_spellInfo->SpellGroupType);
-			if(spell_flat_modifers!=0 || spell_pct_modifers!=0)
-				printf("!!!!!spell radius mod flat %d , spell radius mod pct %d , spell radius %d, spell group %u\n",spell_flat_modifers,spell_pct_modifers,Rad[i],m_spellInfo->SpellGroupType);
+			float spell_flat_modifers=0;
+			float spell_pct_modifers=1;
+			SM_FFValue(u_caster->SM_FRadius,&spell_flat_modifers,m_spellInfo->SpellGroupType);
+			SM_PFValue(u_caster->SM_PRadius,&spell_pct_modifers,m_spellInfo->SpellGroupType);
+			if(spell_flat_modifers!=0 || spell_pct_modifers!=1)
+				printf("!!!!!spell radius mod flat %f , spell radius mod pct %f , spell radius %f, spell group %u\n",spell_flat_modifers,spell_pct_modifers,Rad[i],m_spellInfo->SpellGroupType);
 #endif
         }
 
Index: SpellAuras.cpp
===================================================================
--- SpellAuras.cpp	(revision 187)
+++ SpellAuras.cpp	(working copy)
@@ -222,7 +222,7 @@
 		&Aura::SpellAuraIncreaseHitRate,//199 Apply Aura: Increases Spell % To Hit (Fire, Nature, Frost)
 		&Aura::SpellAuraNULL,//200 // Increases experience earned by $s1%.  Lasts $d.
 		&Aura::SpellAuraNULL,//201 Apply Aura: Cannot be Dodged
-		&Aura::SpellAuraNULL,//202 // Finishing moves cannot be dodged - 32601, 44452
+		&Aura::SpellAuraFinishingMovesCannotBeDodged,//202 // Finishing moves cannot be dodged - 32601, 44452
 		&Aura::SpellAuraReduceCritMeleeAttackDmg,//203 Apply Aura: Reduces Attacker Critical Hit Damage with Melee by %
 		&Aura::SpellAuraReduceCritRangedAttackDmg,//204 Apply Aura: Reduces Attacker Critical Hit Damage with Ranged by %
 		&Aura::SpellAuraNULL,//205 // "School" Vulnerability
@@ -251,11 +251,16 @@
 		&Aura::SpellAuraNULL,//228 Stealth Detection. http://www.thottbot.com/s34709
 		&Aura::SpellAuraNULL,//229 Apply Aura:Reduces the damage your pet takes from area of effect attacks http://www.thottbot.com/s35694
 		&Aura::SpellAuraIncreaseMaxHealth,//230 Increase Max Health (commanding shout);
-        //231 curse a target http://www.thottbot.com/s40303
-        //232 // Reduces duration of Magic effects by $s2%.
-        //233 // Beer Goggles
-        //234 Apply Aura: Reduces Silence or Interrupt effects, Item spell magic http://www.thottbot.com/s42184
-		//235 33206 Instantly reduces a friendly target's threat by $44416s1%, reduces all damage taken by $s1% and increases resistance to Dispel mechanics by $s2% for $d.
+        &Aura::SpellAuraNULL,//231 curse a target http://www.thottbot.com/s40303
+        &Aura::SpellAuraNULL,//232 // Reduces duration of Magic effects by $s2%.
+        &Aura::SpellAuraNULL,//233 // Beer Goggles
+        &Aura::SpellAuraNULL,//234 Apply Aura: Reduces Silence or Interrupt effects, Item spell magic http://www.thottbot.com/s42184
+		&Aura::SpellAuraNULL,//235 33206 Instantly reduces a friendly target's threat by $44416s1%, reduces all damage taken by $s1% and increases resistance to Dispel mechanics by $s2% for $d.
+		&Aura::SpellAuraNULL,//236
+		&Aura::SpellAuraNULL,//237
+		&Aura::SpellAuraNULL,//238
+		&Aura::SpellAuraNULL,//239
+		&Aura::SpellAuraAxeSkillModifier,//240 Increase Axe Skill http://www.wowhead.com/?spell=20574
 };
 /*
 ASCENT_INLINE void ApplyFloatSM(float ** m,float v,uint32 mask, float def)
@@ -480,7 +485,7 @@
 	* m_spellProto->Attributes == 0x2040100
 	* are handled. Its possible there are more spells like this
 	*************************************************************/
-	if( caster != NULL && caster->IsPlayer() && caster->IsInWorld() && m_spellProto->c_is_flags & SPELL_FLAG_IS_REQUIRECOOLDOWNUPDATE )
+	if( caster != NULL && caster->IsPlayer() && caster->IsInWorld() && m_spellProto->c_is_flags & SPELL_FLAG_IS_REQUIRECOOLDOWNUPDATE && static_cast<Player*>(caster)->CooldownCheat )
 	{
 		WorldPacket data( 12 );
 		data.SetOpcode( SMSG_COOLDOWN_EVENT );
@@ -959,7 +964,7 @@
 			static_cast<Player*>(caster)->UnPossess();
 
 		// make sure Player::UnPossess() didn't fail, if it did we will just free the target here
-		if( m_target->GetUInt64Value( UNIT_FIELD_CHARMEDBY ) != NULL )
+		if( m_target->GetUInt64Value( UNIT_FIELD_CHARMEDBY ) != 0 )
 		{
 			if( m_target->GetTypeId() == TYPEID_UNIT )
 			{
@@ -967,7 +972,7 @@
 				m_target->m_redirectSpellPackets = 0;
 			}
 
-			m_target->SetUInt64Value( UNIT_FIELD_CHARMEDBY, NULL );
+			m_target->SetUInt64Value( UNIT_FIELD_CHARMEDBY, 0 );
 			m_target->RemoveFlag( UNIT_FIELD_FLAGS, UNIT_FLAG_PLAYER_CONTROLLED_CREATURE );
 			m_target->SetUInt32Value( UNIT_FIELD_FACTIONTEMPLATE, m_target->GetCharmTempVal() );
 			m_target->_setFaction();
@@ -1179,6 +1184,13 @@
 		dmg.full_damage = ress;
 		dmg.resisted_damage = 0;
 		
+		if(ress < 0) ress = 0;
+		res=(float)ress;
+		dealdamage dmg;
+		dmg.school_type = school;
+		dmg.full_damage = ress;
+		dmg.resisted_damage = 0;
+
 		if(res <= 0) 
 			dmg.resisted_damage = dmg.full_damage;
 
@@ -1188,7 +1200,7 @@
 			if((int32)dmg.resisted_damage > dmg.full_damage)
 				res = 0;
 			else
-                res = float(dmg.full_damage - dmg.resisted_damage);
+				res = float(dmg.full_damage - dmg.resisted_damage);
 		}
 
 		SendPeriodicAuraLog(m_casterGuid, m_target, GetSpellProto()->Id, school, float2int32(res), abs_dmg, dmg.resisted_damage, FLAG_PERIODIC_DAMAGE);
@@ -1712,13 +1724,16 @@
 			}
 			else
 			{
-				Creature *summon = m_target->GetMapMgr()->GetCreature(m_target->GetUInt32Value(UNIT_FIELD_SUMMON));
+				// disabled this due to unstableness :S
+#if 0
+				Creature *summon = m_target->GetMapMgr()->GetCreature(m_target->GetUInt32Value(PLAYER_FARSIGHT));
 				if(summon)
 				{
 					summon->RemoveFromWorld(false,true);
 					delete summon;
 				}
 				m_target->SetUInt64Value(PLAYER_FARSIGHT,0);
+#endif
 			}
 		}break;
 	case 15286://Vampiric Embrace
@@ -1929,7 +1944,7 @@
 	case 24125:
 	case 21171:
 		{
-			if(!apply && m_target->GetTypeId() == TYPEID_PLAYER && m_target->IsInWorld())
+			/*if(!apply && m_target->GetTypeId() == TYPEID_PLAYER && m_target->IsInWorld())
 			{
 				// reset players vision
 				Player * plr = static_cast<Player*>(m_target);
@@ -1942,7 +1957,7 @@
 					farsight->RemoveFromWorld(false,true);
 					delete farsight;
 				}
-			}
+			}*/
 		}break;
 	case 33763: // LifeBloom
 		 {
@@ -2160,7 +2175,7 @@
 		if( target->GetEnslaveCount() >= 10 )
 			return;
 
-		if( caster->GetUInt64Value( UNIT_FIELD_CHARM ) != NULL )
+		if( caster->GetUInt64Value( UNIT_FIELD_CHARM ) != 0 )
 			return;
 
 		m_target->m_special_state |= UNIT_STATE_CHARM;
@@ -2465,17 +2480,17 @@
 		if(apply)
 		{
 			mod->fixed_amount[0] = m_target->GetModPUInt32Value(UNIT_FIELD_BASEATTACKTIME,mod->m_amount);
-			mod->fixed_amount[1] = m_target->GetModPUInt32Value(UNIT_FIELD_BASEATTACKTIME,mod->m_amount);
-			mod->fixed_amount[2] = m_target->GetModPUInt32Value(UNIT_FIELD_BASEATTACKTIME,mod->m_amount);
-			m_target->ModUInt32Value(UNIT_FIELD_BASEATTACKTIME,mod->fixed_amount[0]);
-			m_target->ModUInt32Value(UNIT_FIELD_BASEATTACKTIME_01,mod->fixed_amount[1]);
-			m_target->ModUInt32Value(UNIT_FIELD_RANGEDATTACKTIME,mod->fixed_amount[2]);
+			mod->fixed_amount[1] = m_target->GetModPUInt32Value(UNIT_FIELD_BASEATTACKTIME_01,mod->m_amount);
+			mod->fixed_amount[2] = m_target->GetModPUInt32Value(UNIT_FIELD_RANGEDATTACKTIME,mod->m_amount);
+			m_target->ModUInt32Value(UNIT_FIELD_BASEATTACKTIME, -mod->fixed_amount[0]);
+			m_target->ModUInt32Value(UNIT_FIELD_BASEATTACKTIME_01, -mod->fixed_amount[1]);
+			m_target->ModUInt32Value(UNIT_FIELD_RANGEDATTACKTIME, -mod->fixed_amount[2]);
 		}
 		else
 		{
-			m_target->ModUInt32Value(UNIT_FIELD_BASEATTACKTIME,-mod->fixed_amount[0]);
-			m_target->ModUInt32Value(UNIT_FIELD_BASEATTACKTIME_01,-mod->fixed_amount[1]);
-			m_target->ModUInt32Value(UNIT_FIELD_RANGEDATTACKTIME,-mod->fixed_amount[2]);
+			m_target->ModUInt32Value(UNIT_FIELD_BASEATTACKTIME, mod->fixed_amount[0]);
+			m_target->ModUInt32Value(UNIT_FIELD_BASEATTACKTIME_01, mod->fixed_amount[1]);
+			m_target->ModUInt32Value(UNIT_FIELD_RANGEDATTACKTIME, mod->fixed_amount[2]);
 		}
 	}
 	 
@@ -2638,30 +2653,31 @@
 void Aura::SpellAuraModDamageDone(bool apply)
 {
 	int32 val;
-	if(m_target->IsPlayer())
+
+	if( m_target->IsPlayer() )
 	{
 		uint32 index;
 		 
-		if(mod->m_amount > 0)
+		if( mod->m_amount > 0 )
 		{
-			if(apply)
+			if( apply )
 			{
 				SetPositive();
 				val = mod->m_amount;
 			}
 			else
 			{
-				val =- mod->m_amount;
+				val = -mod->m_amount;
 			}
 			index = PLAYER_FIELD_MOD_DAMAGE_DONE_POS;
 		
 		}
 		else
 		{
-			if(apply)
+			if( apply )
 			{
 				SetNegative();
-				val =- mod->m_amount;
+				val = -mod->m_amount;
 			}
 			else
 			{
@@ -2670,52 +2686,52 @@
 			index = PLAYER_FIELD_MOD_DAMAGE_DONE_NEG;
 		}
 
-		for(uint32 x=0;x<7;x++)
+		for( uint32 x = 0; x < 7; x++ )
 		{
-			if (mod->m_miscValue & (((uint32)1)<<x) )
+			if( mod->m_miscValue & ( ( (uint32)1 ) << x ) )
 			{
-				m_target->ModUInt32Value(index + x,val);
+				m_target->ModUInt32Value( index + x, val );
 			}
 		}
 	}
-	else if(m_target->GetTypeId() == TYPEID_UNIT)
+	else if( m_target->GetTypeId() == TYPEID_UNIT )
 	{
-		if(mod->m_amount > 0)
+		if( mod->m_amount > 0 )
 		{
-			if(apply)
+			if( apply )
 			{
 				SetPositive();
 				val = mod->m_amount;
 			}
 			else
 			{
-				val =- mod->m_amount;
+				val = -mod->m_amount;
 			}
 
 		}
 		else
 		{
-			if(apply)
+			if( apply )
 			{
 				SetNegative();
 				val = mod->m_amount;
 			}
 			else
 			{
-				val =- mod->m_amount;
+				val = -mod->m_amount;
 			}
 		}
 
-		for(uint32 x=0;x<7;x++)
+		for( uint32 x = 0; x < 7; x++ )
 		{
-			if (mod->m_miscValue & (((uint32)1)<<x) )
+			if( mod->m_miscValue & ( ( (uint32)1 ) << x ) )
 			{
-				static_cast<Creature*>(m_target)->ModDamageDone[x]+=val;
+				static_cast< Creature* >( m_target )->ModDamageDone[x] += val;
 			}
 		}
 	}
    
-	if(mod->m_miscValue&1)
+	if( mod->m_miscValue & 1 )
 		m_target->CalcDamage();
 }
 
@@ -3535,17 +3551,19 @@
 
 void Aura::SpellAuraModShapeshift(bool apply)
 {
-	if(!p_target) return;
+	if( p_target == NULL )
+		return;
 
-	if(p_target->m_MountSpellId && p_target->m_MountSpellId != m_spellProto->Id)
-		m_target->RemoveAura(p_target->m_MountSpellId); // these spells are not compatible
+	if( p_target->m_MountSpellId && p_target->m_MountSpellId != m_spellProto->Id )
+		if( !(mod->m_miscValue & FORM_BATTLESTANCE | FORM_DEFENSIVESTANCE | FORM_BERSERKERSTANCE ) )
+			m_target->RemoveAura( p_target->m_MountSpellId ); // these spells are not compatible
 
 	uint32 spellId = 0;
 	uint32 modelId = 0;
+
 	bool freeMovements = false;
 
-
-	switch(mod->m_miscValue)
+	switch( mod->m_miscValue )
 	{
 	case FORM_CAT: 
 		{//druid
@@ -3631,7 +3649,7 @@
 			spellId = 9635;
 			if(apply)
 			{
-				 m_target->SetByte(UNIT_FIELD_BYTES_0,3,POWER_TYPE_RAGE);
+				m_target->SetByte(UNIT_FIELD_BYTES_0,3,POWER_TYPE_RAGE);
 				m_target->SetUInt32Value(UNIT_FIELD_MAXPOWER2, 1000);
 				m_target->SetUInt32Value(UNIT_FIELD_POWER2, 0);//0 rage
 				if(m_target->getRace() == 4)//NE
@@ -3656,13 +3674,17 @@
 					static_cast<Player*>(m_target)->m_MountSpellId = 0;
 			}
 		} break;  
+	case FORM_BATTLESTANCE:
+		{
+			spellId = 21156;
+		} break;
 	case FORM_DEFENSIVESTANCE:
 		{
-			spellId = 7376;			   
+			spellId = 7376;
 		} break;
 	case FORM_BERSERKERSTANCE:
 		{
-			spellId = 7381;   
+			spellId = 7381;
 		} break;
 	case FORM_SHADOW:
 		{
@@ -3718,28 +3740,28 @@
 		}break;
 	}
 
-	if (apply)
+	if( apply )
 	{
-		if(m_target->getClass() == WARRIOR && m_target->GetUInt32Value(UNIT_FIELD_POWER2) > static_cast<Player*>(m_target)->m_retainedrage)
-			m_target->SetUInt32Value(UNIT_FIELD_POWER2, static_cast<Player*>(m_target)->m_retainedrage);
+		if( m_target->getClass() == WARRIOR && m_target->GetUInt32Value( UNIT_FIELD_POWER2 ) > static_cast< Player* >( m_target )->m_retainedrage )
+			m_target->SetUInt32Value(UNIT_FIELD_POWER2, static_cast< Player* >( m_target )->m_retainedrage );
 
-		if(m_target->getClass() == DRUID)
+		if( m_target->getClass() == DRUID )
 		{
-			if(Rand(((Player*)m_target)->m_furorChance))
+			if( Rand( static_cast< Player* >( m_target )->m_furorChance ) )
 			{
 				uint32 furorSpell;
-				if(mod->m_miscValue == FORM_CAT)
+				if( mod->m_miscValue == FORM_CAT )
 					furorSpell = 17099;
-				else if(mod->m_miscValue == FORM_BEAR || mod->m_miscValue == FORM_DIREBEAR)
+				else if( mod->m_miscValue == FORM_BEAR || mod->m_miscValue == FORM_DIREBEAR )
 					furorSpell = 17057;
 				else
 					furorSpell = 0;
 
-				if(furorSpell)
+				if( furorSpell != 0 )
 				{
-					SpellEntry *spellInfo = dbcSpell.LookupEntry(furorSpell);
+					SpellEntry *spellInfo = dbcSpell.LookupEntry( furorSpell );
 
-					Spell *sp = new Spell(m_target, spellInfo, true, NULL);
+					Spell *sp = new Spell( m_target, spellInfo, true, NULL );
 					SpellCastTargets tgt;
 					tgt.m_unitTarget = m_target->GetGUID();
 					sp->prepare(&tgt);
@@ -3747,43 +3769,46 @@
 			}
 		}
 
-		if(spellId != GetSpellId())
+		if( spellId != GetSpellId() )
 		{
-			if(static_cast<Player*>(m_target)->m_ShapeShifted)
-				static_cast<Player*>(m_target)->RemoveAura(static_cast<Player*>(m_target)->m_ShapeShifted);
+			if( static_cast< Player* >( m_target )->m_ShapeShifted )
+				static_cast< Player* >( m_target )->RemoveAura( static_cast< Player* >( m_target )->m_ShapeShifted );
 
-			static_cast<Player*>(m_target)->m_ShapeShifted = GetSpellId();
+			static_cast< Player* >( m_target )->m_ShapeShifted = GetSpellId();
 		}
 
-		if(modelId)
-			m_target->SetUInt32Value(UNIT_FIELD_DISPLAYID, modelId);
+		if( modelId != 0 )
+			m_target->SetUInt32Value( UNIT_FIELD_DISPLAYID, modelId );
 
-		((Player*)m_target)->SetShapeShift(mod->m_miscValue);
+		static_cast< Player* >( m_target )->SetShapeShift( mod->m_miscValue );
 
-		if(spellId == 0)
+		// check for spell id
+		if( spellId == 0 )
 			return;
-		// check for spell id
-		SpellEntry *spellInfo = dbcSpell.LookupEntry(spellId );
+
+		SpellEntry* spellInfo = dbcSpell.LookupEntry(spellId );
 		
-		Spell *sp = new Spell(m_target, spellInfo, true, NULL);
+		Spell *sp = new Spell( m_target, spellInfo, true, NULL );
 		SpellCastTargets tgt;
 		tgt.m_unitTarget = m_target->GetGUID();
-		sp->prepare(&tgt);
+		sp->prepare( &tgt );
 		
 		// remove the caster from imparing movements
-		if(freeMovements)
+		if( freeMovements )
 		{
-			for(uint32 x=MAX_POSITIVE_AURAS;x<MAX_AURAS;x++)
+			for( uint32 x = MAX_POSITIVE_AURAS; x < MAX_AURAS; x++ )
 			{
-				if(m_target->m_auras[x])
+				if( m_target->m_auras[x] != NULL )
 				{
-					if(m_target->m_auras[x]->GetSpellProto()->MechanicsType == 7 || m_target->m_auras[x]->GetSpellProto()->MechanicsType == 11) // Remove roots and slow spells
+					if( m_target->m_auras[x]->GetSpellProto()->MechanicsType == 7 || m_target->m_auras[x]->GetSpellProto()->MechanicsType == 11 ) // Remove roots and slow spells
+					{
 						m_target->m_auras[x]->Remove();
+					}
 					else // if got immunity for slow, remove some that are not in the mechanics
 					{
-						for(int i=0;i<3;i++)
+						for( int i = 0; i < 3; i++ )
 						{
-							if(m_target->m_auras[x]->GetSpellProto()->EffectApplyAuraName[i] == SPELL_AURA_MOD_DECREASE_SPEED||m_target->m_auras[x]->GetSpellProto()->EffectApplyAuraName[i] == SPELL_AURA_MOD_ROOT)
+							if( m_target->m_auras[x]->GetSpellProto()->EffectApplyAuraName[i] == SPELL_AURA_MOD_DECREASE_SPEED || m_target->m_auras[x]->GetSpellProto()->EffectApplyAuraName[i] == SPELL_AURA_MOD_ROOT )
 							{
 								m_target->m_auras[x]->Remove();
 								break;
@@ -3793,25 +3818,26 @@
 			   }
 			}
 		}
+
 		//execute after we changed shape
-		((Player*)m_target)->EventTalentHearthOfWildChange(true);
+		static_cast< Player* >( m_target )->EventTalentHearthOfWildChange( true );
 	}
 	else 
 	{
 		//execute before changing shape back
-		((Player*)m_target)->EventTalentHearthOfWildChange(false);
-		m_target->SetUInt32Value(UNIT_FIELD_DISPLAYID, m_target->GetUInt32Value(UNIT_FIELD_NATIVEDISPLAYID));				
-		if(spellId != GetSpellId())
+		static_cast< Player* >( m_target )->EventTalentHearthOfWildChange( false );
+		m_target->SetUInt32Value( UNIT_FIELD_DISPLAYID, m_target->GetUInt32Value( UNIT_FIELD_NATIVEDISPLAYID ) );				
+		if( spellId != GetSpellId() )
 		{
-			if(spellId)
-				m_target->RemoveAura(spellId);
+			if( spellId )
+				m_target->RemoveAura( spellId );
 		}
-		static_cast<Player*>(m_target)->m_ShapeShifted=0;
+		static_cast< Player* >( m_target )->m_ShapeShifted = 0;
 
-		((Player*)m_target)->SetShapeShift(0);
+		static_cast< Player* >( m_target )->SetShapeShift( 0 );
 
 	}
-	static_cast<Player*>(m_target)->UpdateStats();
+	static_cast< Player* >( m_target )->UpdateStats();
 }
 
 void Aura::SpellAuraModEffectImmunity(bool apply)
@@ -4658,7 +4684,7 @@
 		else
 			m_caster->SetUInt32Value(UNIT_FIELD_HEALTH, mh);
 
-		SendPeriodicAuraLog(m_target, m_target, m_spellProto->Id, m_spellProto->School, 1000, 0,0, FLAG_PERIODIC_LEECH);
+		SendPeriodicAuraLog(m_target, m_target, m_spellProto->Id, m_spellProto->School, 1000, 0, 0, FLAG_PERIODIC_LEECH);
 	}
 }
 
@@ -6415,13 +6441,19 @@
 		{
 			mod->fixed_amount[0] = m_target->GetModPUInt32Value( UNIT_FIELD_BASEATTACKTIME, mod->m_amount );
 			mod->fixed_amount[1] = m_target->GetModPUInt32Value( UNIT_FIELD_BASEATTACKTIME_01, mod->m_amount );
-			m_target->ModUInt32Value( UNIT_FIELD_BASEATTACKTIME, mod->fixed_amount[0] );
-			m_target->ModUInt32Value( UNIT_FIELD_BASEATTACKTIME_01, mod->fixed_amount[1] );
+
+			if( (int32)m_target->GetUInt32Value ( UNIT_FIELD_BASEATTACKTIME ) <= mod->fixed_amount[0] )
+				mod->fixed_amount[0] = m_target->GetUInt32Value ( UNIT_FIELD_BASEATTACKTIME ); //watch it, a negative timer might be bad ;)
+			if( (int32)m_target->GetUInt32Value ( UNIT_FIELD_BASEATTACKTIME_01 ) <= mod->fixed_amount[1] )
+				mod->fixed_amount[1] = m_target->GetUInt32Value ( UNIT_FIELD_BASEATTACKTIME_01 );//watch it, a negative timer might be bad ;)
+
+			m_target->ModUInt32Value( UNIT_FIELD_BASEATTACKTIME, -mod->fixed_amount[0] );
+			m_target->ModUInt32Value( UNIT_FIELD_BASEATTACKTIME_01, -mod->fixed_amount[1] );
 		}
 		else
 		{
-			m_target->ModUInt32Value( UNIT_FIELD_BASEATTACKTIME, -mod->fixed_amount[0] );
-			m_target->ModUInt32Value( UNIT_FIELD_BASEATTACKTIME_01, -mod->fixed_amount[1] );
+			m_target->ModUInt32Value( UNIT_FIELD_BASEATTACKTIME, mod->fixed_amount[0] );
+			m_target->ModUInt32Value( UNIT_FIELD_BASEATTACKTIME_01, mod->fixed_amount[1] );
 		}
 	}
 }
@@ -6475,9 +6507,9 @@
 		if(apply)
 		{
 			mod->fixed_amount[0] = m_target->GetModPUInt32Value(UNIT_FIELD_RANGEDATTACKTIME,mod->m_amount);
-			m_target->ModUInt32Value(UNIT_FIELD_RANGEDATTACKTIME,mod->fixed_amount[0]);
+			m_target->ModUInt32Value(UNIT_FIELD_RANGEDATTACKTIME, -mod->fixed_amount[0]);
 		}
-		else m_target->ModUInt32Value(UNIT_FIELD_RANGEDATTACKTIME,-mod->fixed_amount[0]);
+		else m_target->ModUInt32Value(UNIT_FIELD_RANGEDATTACKTIME, mod->fixed_amount[0]);
 	}
 }
 
@@ -6710,21 +6742,21 @@
 }
 
 
-void Aura::SpellAuraWaterBreathing(bool apply)
+void Aura::SpellAuraWaterBreathing( bool apply )
 {
-   if(m_target->GetTypeId() == TYPEID_PLAYER)
+   if( m_target->GetTypeId() == TYPEID_PLAYER )
    {
-	   if(apply)
+	   if( apply )
 	   {
 			SetPositive();
-			   WorldPacket data(4);
-			data.SetOpcode(SMSG_STOP_MIRROR_TIMER);
-			data << uint32(1);
-			static_cast<Player*>(m_target)->GetSession()->SendPacket(&data);
-			static_cast<Player*>(m_target)->m_UnderwaterState = 0;			
+			WorldPacket data( 4 );
+			data.SetOpcode( SMSG_STOP_MIRROR_TIMER );
+			data << uint32( 1 );
+			static_cast< Player* >( m_target )->GetSession()->SendPacket( &data );
+			static_cast< Player* >( m_target )->m_UnderwaterState = 0;			
 	   }
 
-	   static_cast<Player*>(m_target)->m_bUnlimitedBreath=apply;
+	   static_cast< Player* >( m_target )->m_bUnlimitedBreath = apply;
    }
 }
 
@@ -7515,6 +7547,24 @@
 	}
 }
 
+void Aura::SpellAuraFinishingMovesCannotBeDodged(bool apply)
+{
+	if(apply)
+	{
+		if(!m_target->IsPlayer())
+			return;
+
+		((Player*)m_target)->m_finishingmovesdodge = true;
+	}
+	else
+	{
+		if(!m_target->IsPlayer())
+			return;
+
+		((Player*)m_target)->m_finishingmovesdodge = false;
+	}
+}
+
 void Aura::SpellAuraIncreaseMaxHealth(bool apply)
 {
 	//should only be used by a player
@@ -7718,3 +7768,22 @@
 		}
 	}
 }
+
+void Aura::SpellAuraAxeSkillModifier(bool apply)
+{
+	if( p_target != NULL )
+	{
+		SetPositive();
+		if( apply )
+		{
+			p_target->_ModifySkillBonus( SKILL_AXES, mod->m_amount );
+			p_target->_ModifySkillBonus( SKILL_2H_AXES, mod->m_amount );
+		}
+		else
+		{
+			p_target->_ModifySkillBonus( SKILL_AXES, -mod->m_amount );
+			p_target->_ModifySkillBonus( SKILL_2H_AXES, -mod->m_amount );
+		}
+		p_target->UpdateStats();
+	}
+}
Index: SpellAuras.h
===================================================================
--- SpellAuras.h	(revision 187)
+++ SpellAuras.h	(working copy)
@@ -235,6 +235,7 @@
     SPELL_AURA_REDUCE_ATTACKER_CRICTICAL_HIT_CHANCE_PCT = 197,
     SPELL_AURA_INCREASE_SPELL_HIT_PCT = 199,
     SPELL_AURA_CANNOT_BE_DODGED = 201,
+	SPELL_AURA_FINISHING_MOVES_CANNOT_BE_DODGED = 202,
     SPELL_AURA_REDUCE_ATTACKER_CRICTICAL_HIT_DAMAGE_MELEE_PCT = 203,
     SPELL_AURA_REDUCE_ATTACKER_CRICTICAL_HIT_DAMAGE_RANGED_PCT = 204,
     SPELL_AURA_INCREASE_RANGED_ATTACK_POWER_PCT_OF_INTELLECT = 212,
@@ -243,7 +244,8 @@
     SPELL_AURA_REGEN_MANA_STAT_PCT=219,
     SPELL_AURA_HEALING_STAT_PCT=220,
     SPELL_AURA_INCREASE_MAX_HEALTH=230,//Used by Commanding Shout
-    TOTAL_SPELL_AURAS = 231,
+	SPELL_AURA_MODIFY_AXE_SKILL=240,
+    TOTAL_SPELL_AURAS = 241,
 };
 enum AuraTickFlags
 {
@@ -551,6 +553,8 @@
 	void SpellAuraIncreaseRangedAPStatPCT(bool apply);
 	//void SpellAuraModRangedDamageTakenPCT(bool apply);
 	void SpellAuraModBlockValue(bool apply);
+	void SpellAuraFinishingMovesCannotBeDodged(bool apply);
+	void SpellAuraAxeSkillModifier(bool apply);
 
 	void SendModifierLog(int32 ** m,int32 v,uint64 mask,uint8 type,bool pct = false);
 	void SendDummyModifierLog(std::map<SpellEntry*,uint32> * m,SpellEntry * spellInfo,uint32 i,bool apply,bool pct = false);
Index: SpellEffects.cpp
===================================================================
--- SpellEffects.cpp	(revision 187)
+++ SpellEffects.cpp	(working copy)
@@ -101,7 +101,7 @@
 		&Spell::SpellEffectNULL,//SPELL_EFFECT_ATTACK - 78
 		&Spell::SpellEffectSanctuary,//SPELL_EFFECT_SANCTUARY - 79
 		&Spell::SpellEffectAddComboPoints,//SPELL_EFFECT_ADD_COMBO_POINTS - 80
-		&Spell::SpellEffectNULL,//SPELL_EFFECT_CREATE_HOUSE - 81
+		&Spell::SpellEffectCreateHouse,//SPELL_EFFECT_CREATE_HOUSE - 81
 		&Spell::SpellEffectNULL,//SPELL_EFFECT_BIND_SIGHT - 82
 		&Spell::SpellEffectDuel,//SPELL_EFFECT_DUEL - 83
 		&Spell::SpellEffectStuck,//SPELL_EFFECT_STUCK - 84
@@ -144,7 +144,7 @@
 		&Spell::SpellEffectDummyMelee,//SPELL_EFFECT_DUMMYMELEE	- 121
 		&Spell::SpellEffectNULL,//unknown - 122 //not used
 		&Spell::SpellEffectNULL,//SPELL_EFFECT_FILMING - 123 // http://www.thottbot.com/?sp=27998: flightpath 
-		&Spell::SpellEffectNULL,//SPELL_EFFECT_PULL - 124 //http://www.thottbot.com/?sp=28337
+		&Spell::SpellEffectPlayerPull, // SPELL_EFFECT_PLAYER_PULL - 124 - http://thottbot.com/e2312
 		&Spell::SpellEffectNULL,//unknown - 125 // Reduce Threat by % //http://www.thottbot.com/?sp=32835
 		&Spell::SpellEffectSpellSteal,//SPELL_EFFECT_SPELL_STEAL - 126 // Steal Beneficial Buff (Magic) //http://www.thottbot.com/?sp=30449
 		&Spell::SpellEffectProspecting,//unknown - 127 // Search 5 ore of a base metal for precious gems.  This will destroy the ore in the process.
@@ -156,14 +156,14 @@
 		&Spell::SpellEffectNULL,// SPELL_EFFECT_FORGET_SPECIALIZATION - 133 // http://www.thottbot.com/s36441 // I think this is a gm/npc spell
 		&Spell::SpellEffectNULL,// unknown - 134 // related to summoning objects and removing them, http://www.thottbot.com/s39161
 		&Spell::SpellEffectNULL,// unknown - 135 // no spells
-        &Spell::SpellEffectNULL,// unknown - 136 // http://www.thottbot.com/s41542 and http://www.thottbot.com/s39703
-        &Spell::SpellEffectNULL,// unknown - 137 // http://www.thottbot.com/s41542
-        &Spell::SpellEffectNULL,// unknown - 138 // related to superjump or even "*jump" spells http://www.thottbot.com/?e=Unknown%20138
-        &Spell::SpellEffectNULL,// unknown - 139 // no spells
-        &Spell::SpellEffectTeleportUnits,//SPELL_EFFECT_TELEPORT_UNITS - 140 IronForge teleport / portal only it seems
-        &Spell::SpellEffectNULL,// unknown - 141 // triggers spell, magic one,  (Mother spell) http://www.thottbot.com/s41065
-        &Spell::SpellEffectNULL,// unknown - 142 // triggers some kind of "Put spell on target" thing... (dono for sure) http://www.thottbot.com/s40872 and http://www.thottbot.com/s33076
-        &Spell::SpellEffectNULL,// unknown - 143 // Master -> deamon effecting spell, http://www.thottbot.com/s25228 and http://www.thottbot.com/s35696
+		&Spell::SpellEffectNULL,// unknown - 136 // http://www.thottbot.com/s41542 and http://www.thottbot.com/s39703
+		&Spell::SpellEffectNULL,// unknown - 137 // http://www.thottbot.com/s41542
+		&Spell::SpellEffectNULL,// unknown - 138 // related to superjump or even "*jump" spells http://www.thottbot.com/?e=Unknown%20138
+		&Spell::SpellEffectNULL,// unknown - 139 // no spells
+		&Spell::SpellEffectTeleportUnits,//SPELL_EFFECT_TELEPORT_UNITS - 140 IronForge teleport / portal only it seems
+		&Spell::SpellEffectNULL,// unknown - 141 // triggers spell, magic one,  (Mother spell) http://www.thottbot.com/s41065
+		&Spell::SpellEffectNULL,// unknown - 142 // triggers some kind of "Put spell on target" thing... (dono for sure) http://www.thottbot.com/s40872 and http://www.thottbot.com/s33076
+		&Spell::SpellEffectNULL,// unknown - 143 // Master -> deamon effecting spell, http://www.thottbot.com/s25228 and http://www.thottbot.com/s35696
 };
 
 void Spell::SpellEffectNULL(uint32 i)
@@ -268,9 +268,11 @@
 			}break;
 		}
 		//now caster gains this buff
-		if (spellid1 && spellid1 != 0)
+		if( spellid1 != 0 )
 		{
-			u_caster->CastSpell(u_caster, dbcSpell.LookupEntry(spellid1), true);
+			SpellEntry* sp = dbcSpell.LookupEntry( spellid1 );
+			if( sp != NULL )
+				u_caster->CastSpell( u_caster, sp, true );
 		}
 	}
 
@@ -1154,8 +1156,11 @@
 			if(!u_caster || !u_caster->isAlive() || !unitTarget || !unitTarget->isAlive())
 				return;
 			uint32 pet_dmg = this->forced_basepoints[0]*20/100;
-			unitTarget->ModUInt32Value(UNIT_FIELD_HEALTH,pet_dmg);
-			unitTarget->DealDamage(u_caster,pet_dmg,0,0,25228,true);
+			if( pet_dmg )
+			{
+				unitTarget->ModUInt32Value(UNIT_FIELD_HEALTH,pet_dmg);
+				unitTarget->DealDamage(u_caster,pet_dmg,0,0,25228,true);
+			}
 		}break;
 	}										 
 }
@@ -1597,7 +1602,7 @@
 
 void Spell::SpellEffectQuestComplete(uint32 i) // Quest Complete
 {
-	//damage is id of the quest to complete
+	//misc value is id of the quest to complete
 }
 
 //wand->
@@ -1822,55 +1827,63 @@
 
 void Spell::SpellEffectWeapon(uint32 i)
 {
-	if(!playerTarget)
+	if( playerTarget == NULL )
 		return;
 
 	uint32 skill = 0;
 	uint32 spell = 0;
 
-	switch(this->m_spellInfo->Id)
+	switch( this->m_spellInfo->Id )
 	{
 	case 201:    // one-handed swords
-		skill = SKILL_SWORDS;
-		break;
+		{
+			skill = SKILL_SWORDS;
+		}break;
 	case 202:   // two-handed swords
-		skill = SKILL_2H_SWORDS;
-		break;
+		{
+			skill = SKILL_2H_SWORDS;
+		}break;
 	case 203:   // Unarmed
-		skill = SKILL_UNARMED;
-		break;
+		{
+			skill = SKILL_UNARMED;
+		}break;
 	case 199:   // two-handed maces
-		skill = SKILL_2H_MACES;
-		break;
+		{
+			skill = SKILL_2H_MACES;
+		}break;
 	case 198:   // one-handed maces
-		skill = SKILL_MACES;
-		break;
+		{
+			skill = SKILL_MACES;
+		}break;
 	case 197:   // two-handed axes
-		skill = SKILL_2H_AXES;
-		break;
+		{
+			skill = SKILL_2H_AXES;
+		}break;
 	case 196:   // one-handed axes
-		skill = SKILL_AXES;
-		break;
+		{
+			skill = SKILL_AXES;
+		}break;
 	case 5011: // crossbows
 		{
 			skill = SKILL_CROSSBOWS;
 			spell = SPELL_RANGED_GENERAL;
 		}break;
 	case 227:   // staves
-		skill = SKILL_STAVES;
-		break;
+		{
+			skill = SKILL_STAVES;
+		}break;
 	case 1180:  // daggers
-		skill = SKILL_DAGGERS;
-		break;
-	case 3386:  // spears
-		skill = 0;   // ??!!
-		break;
+		{
+			skill = SKILL_DAGGERS;
+		}break;
 	case 200:   // polearms
-		skill = SKILL_POLEARMS;
-		break;
+		{
+			skill = SKILL_POLEARMS;
+		}break;
 	case 15590: // fist weapons
-		skill = SKILL_UNARMED;
-		break;
+		{
+			skill = SKILL_UNARMED;
+		}break;
 	case 264:   // bows
 		{
 			skill = SKILL_BOWS;
@@ -1882,8 +1895,17 @@
 			spell = SPELL_RANGED_GENERAL;
 		}break;
 	case 2567:  // thrown
-		skill = SKILL_THROWN;
-		break;
+		{
+			skill = SKILL_THROWN;
+		}break;
+	case 5009:  // wands
+		{
+			skill = SKILL_WANDS;
+			spell = SPELL_RANGED_GENERAL;
+		}break;
+	//case 3386:  // spears
+	//	skill = 0;   // ??!!
+	//	break;
 	default:
 		{
 			skill = 0;
@@ -2106,7 +2128,7 @@
 	float ori = m_caster->GetOrientation();				
 	float posX = m_caster->GetPositionX()+(radius*(cosf(ori)));
 	float posY = m_caster->GetPositionY()+(radius*(sinf(ori)));
-	float z = CollideInterface.GetHeight(m_caster->GetMapId(), posX, posY, m_caster->GetPositionZ() + 5.0f);
+	float z = CollideInterface.GetHeight(m_caster->GetMapId(), posX, posY, m_caster->GetPositionZ() + 2.0f);
 	if(z == NO_WMO_HEIGHT)		// not found height, or on adt
 		z = m_caster->GetMapMgr()->GetLandHeight(posX,posY);
 
@@ -2117,14 +2139,16 @@
 	LocationVector destest(posX, posY, dest.z, ori);
 	LocationVector src(m_caster->GetPositionX(), m_caster->GetPositionY(), m_caster->GetPositionZ() + 2.0f);
 
-	if(CollideInterface.GetFirstPoint(m_caster->GetMapId(), &src, &destest, &dest, -1.0f))
+	if(CollideInterface.GetFirstPoint(m_caster->GetMapId(), src, destest, dest, -1.5f))
 	{
 		// hit an object new point is in dest.
-		dest.z = CollideInterface.GetHeight(m_caster->GetMapId(), dest.x, dest.y, dest.z + 2.0f);
+		// is this necessary?
+		//dest.z = CollideInterface.GetHeight(m_caster->GetMapId(), dest.x, dest.y, dest.z + 2.0f);
 	}
 	else
 		dest.z = z;
 
+	dest.o = p_caster->GetOrientation();
 	p_caster->SafeTeleport( p_caster->GetMapId(), p_caster->GetInstanceID(), dest );
 #endif
 	// just in case
@@ -3473,6 +3497,7 @@
 
 void Spell::SpellEffectAddFarsight(uint32 i) // Add Farsight
 {
+#if 0
 	//farsight
 	//14501 and 11686
 	if(!p_caster)
@@ -3531,6 +3556,7 @@
 		// call changefarsightlocation
 		p_caster->GetMapMgr()->ChangeFarsightLocation(p_caster, InvisibleSummon);
 	}
+#endif
 }
 
 void Spell::SpellEffectSummonPossessed(uint32 i) // eye of kilrog
@@ -4102,6 +4128,12 @@
 	p_caster->AddComboPoints(p_caster->GetSelection(), damage);
 }
 
+void Spell::SpellEffectCreateHouse(uint32 i) // Create House
+{
+
+
+}
+
 void Spell::SpellEffectDuel(uint32 i) // Duel
 {
 	if(!p_caster)
@@ -4483,6 +4515,37 @@
 	p_caster->ResetHeartbeatCoords();
 }
 
+void Spell::SpellEffectPlayerPull( uint32 i )
+{
+	if( unitTarget == NULL || !unitTarget->isAlive() || !unitTarget->IsPlayer() )
+		return;
+
+	Player* p_target = static_cast< Player* >( unitTarget );
+
+	// calculate destination
+	float pullD = p_target->CalcDistance( m_caster ) - p_target->GetFloatValue( UNIT_FIELD_BOUNDINGRADIUS ) - m_caster->GetFloatValue( UNIT_FIELD_BOUNDINGRADIUS ) - 1.0f;
+	float pullO = p_target->calcRadAngle( p_target->GetPositionX(), p_target->GetPositionY(), m_caster->GetPositionX(), m_caster->GetPositionY() );
+	float pullX = p_target->GetPositionX() + pullD * cosf( pullO );
+	float pullY = p_target->GetPositionY() + pullD * sinf( pullO );
+	float pullZ = m_caster->GetPositionZ() + 0.3f;
+	uint32 time = uint32( pullD * 42.0f );
+
+	p_target->SetOrientation( pullO );
+
+	WorldPacket data( SMSG_MONSTER_MOVE, 60 );
+	data << p_target->GetNewGUID();
+	data << p_target->GetPositionX() << p_target->GetPositionY() << p_target->GetPositionZ();
+	data << getMSTime();
+	data << uint8( 4 );
+	data << pullO;
+	data << uint32( 0x00000100 );
+	data << time;
+	data << uint32( 1 );
+	data << pullX << pullY << pullZ;
+
+	p_target->SendMessageToSet( &data, true );   
+}
+
 void Spell::SpellEffectSummonCritter(uint32 i)
 {
 	if(!u_caster || u_caster->IsInWorld() == false)
@@ -5042,6 +5105,7 @@
 
 		Aura *aur;
 	uint32 start,end;
+	int32 spells_to_steal = damage;
 	if(isAttackable(u_caster,unitTarget))
 	{
 		start=0;
@@ -5125,7 +5189,7 @@
 			// unit resurrection handler
 			if(unitTarget)
 			{
-				if(unitTarget->GetTypeId()==TYPEID_UNIT)
+				if(unitTarget->GetTypeId()==TYPEID_UNIT && unitTarget->IsPet() && unitTarget->isDead())
 				{
 					uint32 hlth = ((uint32)m_spellInfo->EffectBasePoints[i] > unitTarget->GetUInt32Value(UNIT_FIELD_MAXHEALTH)) ? unitTarget->GetUInt32Value(UNIT_FIELD_MAXHEALTH) : (uint32)m_spellInfo->EffectBasePoints[i];
 					uint32 mana = ((uint32)m_spellInfo->EffectBasePoints[i] > unitTarget->GetUInt32Value(UNIT_FIELD_MAXPOWER1)) ? unitTarget->GetUInt32Value(UNIT_FIELD_MAXPOWER1) : (uint32)m_spellInfo->EffectBasePoints[i];
Index: SpellHandler.cpp
===================================================================
--- SpellHandler.cpp	(revision 187)
+++ SpellHandler.cpp	(working copy)
@@ -98,6 +98,15 @@
 		// loop through the auras and removing existing eating spells
 	}
 
+	if(itemProto->RequiredLevel)
+	{
+		if(_player->getLevel() < itemProto->RequiredLevel)
+		{
+			_player->GetItemInterface()->BuildInventoryChangeError(tmpItem,NULL,INV_ERR_ITEM_RANK_NOT_ENOUGH);
+			return;
+		}
+	}
+
 	if(itemProto->RequiredSkill)
 	{
 		if(!_player->_HasSkillLine(itemProto->RequiredSkill))
@@ -224,8 +233,9 @@
 			{
 				if(_player->IsMounted())
 				{
-                    _player->SendCastResult(spellInfo->Id, SPELL_FAILED_NOT_MOUNTED, 0);
-					return;
+					if( !( spellInfo->Id & 2457 | 71 | 2458 ) )
+	                    _player->SendCastResult(spellInfo->Id, SPELL_FAILED_NOT_MOUNTED, 0);
+						return;
 				}
 				_player->m_AutoShotTarget = _player->GetSelection();
 				uint32 duration = _player->GetUInt32Value(UNIT_FIELD_RANGEDATTACKTIME);
Index: SpellNameHashes.h
===================================================================
--- SpellNameHashes.h	(revision 187)
+++ SpellNameHashes.h	(working copy)
@@ -2730,7 +2730,6 @@
 #define SPELL_HASH_CURSE_OF_BLOOD                                                       0xDE7EA8EB
 #define SPELL_HASH_SNUFFLENOSE_COMMAND                                                  0x00A8E26E
 #define SPELL_HASH_RAMPAGE                                                              0x230EFEA1
-#define SPELL_HASH_RAMPAGE_PROC                                                         0x230EFEA2
 #define SPELL_HASH_SUMMON_BOAR_SPIRIT                                                   0x133823B2
 #define SPELL_HASH_CHAIN_BOLT                                                           0x8FD0FA07
 #define SPELL_HASH_DMG2                                                                 0x162094C7
@@ -3532,7 +3531,6 @@
 #define SPELL_HASH_IMPROVED_FLAMESTRIKE                                                 0x35501174
 #define SPELL_HASH_CRITICAL_MASS                                                        0xCCEA73C6
 #define SPELL_HASH_COMBUSTION                                                           0xAF39E04E
-#define SPELL_HASH_COMBUSTION_PROC                                                      0xAF39E04F
 #define SPELL_HASH_ICICLE                                                               0x0EEA2AB5
 #define SPELL_HASH_TEACH_ORCISH_WAR_LEGGINGS                                            0x59B53511
 #define SPELL_HASH_BLESSED_ANVIL                                                        0xFB292531
Index: SpellTarget.cpp
===================================================================
--- SpellTarget.cpp	(revision 187)
+++ SpellTarget.cpp	(working copy)
@@ -339,14 +339,25 @@
 				return;
 	}
 
-	if(p_caster)
+	if(p_caster && pTarget != p_caster)
 	{
 		// this is mostly used for things like duels
-		if(pTarget != p_caster && pTarget->IsPlayer() && !isAttackable(p_caster, pTarget, false))
+		if(pTarget->IsPlayer() && !isAttackable(p_caster, pTarget, false))
 		{
 			cancastresult = SPELL_FAILED_BAD_TARGETS;
 			return;
 		}
+
+#ifdef COLLISION
+		// this distance check may have to be removed in the future.
+		//Shady: wtf is that? it causes a bug when caster and target too close to each other.
+		/*if( p_caster->GetDistance2dSq( pTarget ) < 4.0f && CollideInterface.CheckLOS( p_caster->GetMapId(), p_caster->GetPositionNC(), pTarget->GetPositionNC() ) )
+		{
+			cancastresult = SPELL_FAILED_LINE_OF_SIGHT;
+			return;
+		}*/
+
+#endif
 	}
 
 	uint8 did_hit_result = DidHit(i,pTarget);
Index: TradeHandler.cpp
===================================================================
--- TradeHandler.cpp	(revision 187)
+++ TradeHandler.cpp	(working copy)
@@ -230,9 +230,27 @@
 	uint8 SourceSlot = recv_data.contents()[2];
 
 	Item * pItem = _player->GetItemInterface()->GetInventoryItem(SourceBag, SourceSlot);
-	if(pItem == 0 || TradeSlot > 6)
+	if( pItem == 0 || TradeSlot > 6 || ( TradeSlot < 6 && pItem->IsSoulbound() ) )
 		return;
 
+	if(TradeSlot < 6 && pItem->IsSoulbound())
+	{
+		sCheatLog.writefromsession(this, "tried to cheat trade a soulbound item");
+		Disconnect();
+		return;
+	}
+
+	for(uint32 i = 0; i < 8; ++i)
+	{
+		// duping little shits
+		if(_player->mTradeItems[i] == pItem)
+		{
+			sCheatLog.writefromsession(this, "tried to dupe an item through trade");
+			Disconnect();
+			return;
+		}
+	}
+
 	_player->mTradeItems[TradeSlot] = pItem;
 	_player->SendTradeUpdate();
 }
Index: Unit.cpp
===================================================================
--- Unit.cpp	(revision 187)
+++ Unit.cpp	(working copy)
@@ -760,6 +760,15 @@
 							if (!this->IsPlayer() || static_cast<Player*>(this)->GetShapeShift() != FORM_CAT)
 								continue;
 						}break;
+                        case 34754: //holy concentration
+                        {
+                            if (!CastingSpell)
+								continue;
+							if (CastingSpell->NameHash != SPELL_HASH_FLASH_HEAL &&
+								CastingSpell->NameHash != SPELL_HASH_BINDING_HEAL &&
+								CastingSpell->NameHash != SPELL_HASH_GREATER_HEAL)
+								continue;
+						}break;
 						case 5530:
 						{
 							//warrior/rogue mace specialization can trigger only when using maces
@@ -935,28 +944,6 @@
 									CastingSpell->NameHash != SPELL_HASH_DRAIN_LIFE )//Drain Life								
 									continue;
 							}break;
-/*                        //warlock - Demonic Knowledge
-                        case 39576:
-                            {
-                                if( !CastingSpell )
-                                    continue;
-                                if( CastingSpell->Effect[0] != 56 )
-                                    continue;
-                                Pet* ps = static_cast< Player* >( this )->GetSummon();
-                                if( ps == NULL)
-                                    return;//no pet
-                                int32 val;
-                                SpellEntry *parentproc= dbcSpell.LookupEntry( origId );
-                                val = parentproc->EffectBasePoints[0] + 1;
-                                val = val * (ps->GetUInt32Value( UNIT_FIELD_STAT2 ) + ps->GetUInt32Value( UNIT_FIELD_STAT3 ) );
-                                SpellEntry *spellInfo = dbcSpell.LookupEntry( 39576 );
-                                Spell *spell = new Spell( this, spellInfo ,true, NULL );
-                                spell->forced_basepoints[0] = ( val / 100 );
-                                SpellCastTargets targets;
-                                targets.m_unitTarget = GetGUID();
-                                spell->prepare( &targets );
-                                continue;
-                            }break;*/
 						//mage - Arcane Blast proc
 						case 36032:
 							{
@@ -1076,10 +1063,7 @@
 								{
 									itr2->procCharges++;
 									if( itr2->procCharges >= 3 ) //whatch that number cause it depends on original stack count !
-									{
 										RemoveAllAuraByNameHash( SPELL_HASH_COMBUSTION );
-										RemoveAllAuraByNameHash( SPELL_HASH_COMBUSTION_PROC );
-									}
 									continue;
 								}
 							}break;
@@ -1274,7 +1258,7 @@
 							{
 								if( !CastingSpell )
 									continue;
-								if( CastingSpell->School!=SCHOOL_FIRE || CastingSpell->School!=SCHOOL_FROST) //fire and frost criticals
+								if( CastingSpell->School!=SCHOOL_FIRE && CastingSpell->School!=SCHOOL_FROST) //fire and frost criticals
 									continue;
 								dmg_overwrite = CastingSpell->manaCost * (ospinfo->EffectBasePoints[0] + 1) / 100;
 							}break;
@@ -1539,6 +1523,7 @@
 					continue;
 				}
 				spell->pSpellId=origId;
+				sLog.outDebug("HandleProc: Spell %u proced %u with chance %u , owner %u victim %u and target %u",origId,spellId,itr->procChance,GetGUIDLow(),victim->GetGUIDLow(),(uint32)targets.m_unitTarget);
 				spell->prepare(&targets);
 			}//not always we have a spell to cast
 		}
@@ -2322,6 +2307,9 @@
 		dodge=parry=block=0.0f;
 	}
 
+	if(IsPlayer() && ((Player*)this)->m_finishingmovesdodge && ability && (ability->EffectPointsPerComboPoint[0] > 0 || ability->EffectPointsPerComboPoint[1] > 0 || ability->EffectPointsPerComboPoint[2] > 0) )  // SPELL: Surprise Attacks
+		dodge = 0.0f;
+
 //==========================================================================================
 //==============================One Roll Processing=========================================
 //==========================================================================================
@@ -2334,6 +2322,7 @@
 	chances[4]=chances[3]+block;
 	chances[5]=chances[4]+crit;
 	chances[6]=chances[5]+crush;
+
 //--------------------------------roll------------------------------------------------------
 	float Roll = RandomFloat(100.0f);
 	uint32 r = 0;
@@ -2343,6 +2332,8 @@
 	}
 //--------------------------------postroll processing---------------------------------------
 	uint32 abs = 0;
+
+
 	switch(r)
 	{ 
 //--------------------------------miss------------------------------------------------------
@@ -2878,25 +2869,76 @@
 			}
 		}
 	}
-//--------------------------rage processing-------------------------------------------------
-	uint32 val;
+	//--------------------------rage processing-------------------------------------------------
 	//http://www.wowwiki.com/Formulas:Rage_generation
-	// It only regens rage if in combat, don't know why but this is making
-	// the player to regen 1 rage every 3 secs.....
-	// and the formula is wrong also ... TODO
-	//attacker made white damage
-	if(realdamage && IsPlayer() && GetPowerType() == POWER_TYPE_RAGE && !ability && CombatStatus.IsInCombat())
+
+	if( dmg.full_damage && IsPlayer() && GetPowerType() == POWER_TYPE_RAGE && !ability && CombatStatus.IsInCombat() )
 	{
-		val = GetUInt32Value(UNIT_FIELD_POWER2)+(realdamage*20)/getLevel();
-		val += (static_cast<Player *>(this)->rageFromDamageDealt*val)/100;
-		SetUInt32Value(UNIT_FIELD_POWER2, val>=1000?1000:val);
+		float val;
+		float level = (float)getLevel();
+
+		// Conversion Value
+		float c = 0.0091107836f * level * level + 3.225598133f * level + 4.2652911f;
+
+		// Hit Factor
+		float f = ( weapon_damage_type == OFFHAND ) ? 1.75f : 3.5f;
+
+		if( hit_status & HITSTATUS_CRICTICAL )
+			f *= 2.0f;
+
+		float s = 1.0f;
+
+		// Weapon speed (normal)
+		Item* weapon = ( static_cast< Player* >( this )->GetItemInterface())->GetInventoryItem( INVENTORY_SLOT_NOT_SET, ( weapon_damage_type == OFFHAND ? EQUIPMENT_SLOT_OFFHAND : EQUIPMENT_SLOT_MAINHAND ) );
+		if( weapon == NULL )
+		{
+			if( weapon_damage_type == OFFHAND )
+				s = GetUInt32Value( UNIT_FIELD_BASEATTACKTIME_01 ) / 1000.0f;
+			else
+				s = GetUInt32Value( UNIT_FIELD_BASEATTACKTIME ) / 1000.0f;
+		}
+		else
+		{
+			uint32 entry = weapon->GetEntry();
+			ItemPrototype* pProto = ItemPrototypeStorage.LookupEntry( entry );
+			if( pProto != NULL )
+			{
+				s = pProto->Delay / 1000.0f;
+			}
+		}
+
+		val = ( 7.5f * dmg.full_damage / c + f * s ) / 2.0f;;
+		val *= ( 1 + ( static_cast< Player* >( this )->rageFromDamageDealt / 100.0f ) );
+		val *= 10;
+
+		//float r = ( 7.5f * dmg.full_damage / c + f * s ) / 2.0f;
+		//float p = ( 1 + ( static_cast< Player* >( this )->rageFromDamageDealt / 100.0f ) );
+		//sLog.outDebug( "Rd(%i) d(%i) c(%f) f(%f) s(%f) p(%f) r(%f) rage = %f", realdamage, dmg.full_damage, c, f, s, p, r, val );
+
+		ModUInt32Value( UNIT_FIELD_POWER2, (int32)val );
+		if( GetUInt32Value( UNIT_FIELD_POWER2 ) > 1000 )
+			ModUInt32Value( UNIT_FIELD_POWER2, 1000 - GetUInt32Value( UNIT_FIELD_POWER2 ) );
+
 	}
-	//victim received damage = we do not care the type of damage...we generate rage anyway
-	if(realdamage && pVictim->IsPlayer() && pVictim->GetPowerType() == POWER_TYPE_RAGE && pVictim->CombatStatus.IsInCombat())
+
+	// I am receiving damage!
+	if( dmg.full_damage && pVictim->IsPlayer() && pVictim->GetPowerType() == POWER_TYPE_RAGE && pVictim->CombatStatus.IsInCombat() )
 	{
-		val = pVictim->GetUInt32Value(UNIT_FIELD_POWER2)+(realdamage*20)/pVictim->getLevel();
-		val += (static_cast<Player *>(pVictim)->rageFromDamageDealt*val)/100;
-		pVictim->SetUInt32Value(UNIT_FIELD_POWER2, val>=1000?1000:val);
+		float val;
+		float level = (float)getLevel();
+
+		// Conversion Value
+		float c = 0.0091107836f * level * level + 3.225598133f * level + 4.2652911f;
+
+		val = 2.5f * dmg.full_damage / c;
+		val *= 10;
+
+		//sLog.outDebug( "Rd(%i) d(%i) c(%f) rage = %f", realdamage, dmg.full_damage, c, val );
+
+		pVictim->ModUInt32Value( UNIT_FIELD_POWER2, (int32)val );
+		if( pVictim->GetUInt32Value( UNIT_FIELD_POWER2) > 1000 )
+			pVictim->ModUInt32Value( UNIT_FIELD_POWER2, 1000 - pVictim->GetUInt32Value( UNIT_FIELD_POWER2 ) );
+
 	}
 		
 	RemoveAurasByInterruptFlag(AURA_INTERRUPT_ON_START_ATTACK);
@@ -2910,7 +2952,7 @@
 		while(extra_attacks > 0)
 		{
 			extra_attacks--;
-			Strike( pVictim, weapon_damage_type, ability, add_damage, pct_dmg_mod, exclusive_damage, false, false );
+			Strike( pVictim, weapon_damage_type, NULL, 0, 0, 0, false, false);
 		}
 
 		m_extraAttackCounter = false;
@@ -2927,7 +2969,7 @@
 			if(m_extra == 0)
 				break;
 
-			if((*itr) != pVictim && (*itr)->IsUnit() && CalcDistance(*itr) < 10.0f && isAttackable(this, (*itr)) && (*itr)->isInFront(this))
+			if((*itr) != pVictim && (*itr)->IsUnit() && CalcDistance(*itr) < 10.0f && isAttackable(this, (*itr)) && (*itr)->isInFront(this) && !((Unit*)(*itr))->IsPacified())
 			{
 				Strike( static_cast< Unit* >( *itr ), weapon_damage_type, ability, add_damage, pct_dmg_mod, exclusive_damage, false ,false );
 				--m_extra;
@@ -3547,7 +3589,7 @@
 void Unit::castSpell( Spell * pSpell )
 {
 	// check if we have a spell already casting etc
-	if(m_currentSpell&&pSpell!=m_currentSpell)
+	if(m_currentSpell && pSpell != m_currentSpell)
 	{
 		if(m_spellsbusy)
 		{
@@ -3689,7 +3731,7 @@
 	this->SetUInt32Value(UNIT_FIELD_DISPLAYID, displayid);
 }
 
-void Unit::Emote (EmoteType emote)
+void Unit::Emote(EmoteType emote)
 {
 	if(emote == 0)
 		return;
@@ -3700,6 +3742,47 @@
 	SendMessageToSet (&data, true);
 }
 
+void Unit::SendChatMessageToPlayer(uint8 type, uint32 lang, const char *msg, Player *plr)
+{
+  if(plr == NULL)
+    return;
+
+  size_t UnitNameLength = 0, MessageLength = 0;
+  const char *UnitName = "";
+  CreatureInfo *ci;
+
+  ci = CreatureNameStorage.LookupEntry(GetEntry());
+  if(!ci)
+    return;
+
+  UnitName = ci->Name;
+  UnitNameLength = strlen((char*)UnitName) + 1;
+  MessageLength = strlen((char*)msg) + 1;
+
+  switch(type)
+  {
+  case CHAT_MSG_MONSTER_WHISPER:
+    {
+      WorldPacket data(SMSG_MESSAGECHAT, 200);
+
+      data << uint8(type);
+      data << uint32(lang);
+      data << uint64(GetGUID());
+      data << uint32(0);
+      data << uint32(UnitNameLength);
+      data << UnitName;
+      data << uint64(plr->GetGUID());
+      data << uint32(MessageLength);
+      data << msg;
+      data << uint8(0);      
+
+      WorldSession *session = plr->GetSession();
+      session->SendPacket(&data);
+
+    }break;
+  }
+}
+
 void Unit::SendChatMessageAlternateEntry(uint32 entry, uint8 type, uint32 lang, const char * msg)
 {
 	size_t UnitNameLength = 0, MessageLength = 0;
@@ -3716,6 +3799,57 @@
 
 	switch(type)
 	{
+	case CHAT_MSG_MONSTER_EMOTE:
+		{
+			for(Object::InRangeSet::iterator i = GetInRangeSetBegin(); i != GetInRangeSetEnd(); i++)
+			{
+				if((*i)->GetTypeId() == TYPEID_PLAYER)
+				{
+					std::stringstream szMessage;
+					szMessage << UnitName << msg;
+
+					WorldPacket data(SMSG_MESSAGECHAT, 35 + UnitNameLength + MessageLength);
+					data << type;
+					data << lang;
+					data << GetGUID();
+					data << uint32(0);			// new in 2.1.0
+					data << uint32(UnitNameLength);
+					data << UnitName;
+					data << ((Player*)(*i))->GetGUID();
+					data << uint32(strlen(szMessage.str().c_str())+1);
+					data << szMessage.str().c_str();
+					data << uint8(0x00);
+					WorldSession *session = ((Player*)(*i))->GetSession();
+					session->SendPacket(&data);
+				}
+			}
+		}break;
+		case CHAT_MSG_RAID_BOSS_EMOTE:
+		{
+			for(Object::InRangeSet::iterator i = GetInRangeSetBegin(); i != GetInRangeSetEnd(); i++)
+			{
+				if((*i)->GetTypeId() == TYPEID_PLAYER)
+				{
+					std::stringstream szMessage;
+					szMessage << UnitName << msg;
+
+					WorldPacket data(SMSG_MESSAGECHAT, 35 + UnitNameLength + MessageLength);
+					data << type;
+					data << lang;
+					data << GetGUID();
+					data << uint32(0);			// new in 2.1.0
+					data << uint32(UnitNameLength);
+					data << UnitName;
+					data << ((Player*)(*i))->GetGUID();
+					data << uint32(strlen(szMessage.str().c_str())+1);
+					data << szMessage.str().c_str();
+					data << uint8(0x00);
+
+					WorldSession *session = ((Player*)(*i))->GetSession();
+					session->SendPacket(&data);
+				}
+			}
+		}break;
 	case CHAT_MSG_MONSTER_SAY:
 		{
 			for(Object::InRangeSet::iterator i = GetInRangeSetBegin(); i != GetInRangeSetEnd(); i++)
@@ -4167,10 +4301,10 @@
 
 int32 Unit::GetDamageDoneMod(uint32 school)
 {
-	if(this->IsPlayer())
-	   return (int32)(GetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_POS+school)-GetUInt32Value(PLAYER_FIELD_MOD_DAMAGE_DONE_NEG+school));
+	if( this->IsPlayer() )
+	   return (int32)GetUInt32Value( PLAYER_FIELD_MOD_DAMAGE_DONE_POS + school ) - (int32)GetUInt32Value( PLAYER_FIELD_MOD_DAMAGE_DONE_NEG + school );
 	else
-	   return ((Creature*)this)->ModDamageDone[school];
+	   return static_cast< Creature* >( this )->ModDamageDone[school];
 }
 	
 float Unit::GetDamageDonePctMod(uint32 school)
@@ -4557,6 +4691,9 @@
 
 void Unit::CastSpell(Unit* Target, SpellEntry* Sp, bool triggered)
 {
+	if( Sp == NULL )
+		return;
+
 	Spell *newSpell = new Spell(this, Sp, triggered, 0);
 	SpellCastTargets targets(0);
 	if(Target)
@@ -4581,6 +4718,9 @@
 
 void Unit::CastSpell(uint64 targetGuid, SpellEntry* Sp, bool triggered)
 {
+	if( Sp == NULL )
+		return;
+
 	SpellCastTargets targets(targetGuid);
 	Spell *newSpell = new Spell(this, Sp, triggered, 0);
 	newSpell->prepare(&targets);
@@ -4595,6 +4735,9 @@
 }
 void Unit::CastSpellAoF(float x,float y,float z,SpellEntry* Sp, bool triggered)
 {
+	if( Sp == NULL )
+		return;
+
 	SpellCastTargets targets;
 	targets.m_destX = x;
 	targets.m_destY = y;
Index: Unit.h
===================================================================
--- Unit.h	(revision 187)
+++ Unit.h	(working copy)
@@ -953,6 +953,7 @@
 	}
 
 	void SendChatMessage(uint8 type, uint32 lang, const char *msg);
+	void SendChatMessageToPlayer(uint8 type, uint32 lang, const char *msg, Player *plr);
 	void SendChatMessageAlternateEntry(uint32 entry, uint8 type, uint32 lang, const char * msg);
 	void RegisterPeriodicChatMessage(uint32 delay, uint32 msgid, std::string message, bool sendnotify);
 
Index: WarsongGulch.cpp
===================================================================
--- WarsongGulch.cpp	(revision 187)
+++ WarsongGulch.cpp	(working copy)
@@ -130,10 +130,15 @@
 		/* capture flag points */
 		plr->m_bgScore.Misc1++;
 
-		PlaySoundToAll(plr->GetTeam() ? SOUND_HORDE_SCORES : SOUND_ALLIANCE_SCORES);
-		SendChatMessage(CHAT_MSG_BATTLEGROUND_EVENT, plr->GetGUID(), "%s captured the %s flag!", plr->GetName(), plr->GetTeam() ? "Alliance" : "Horde");
-		SetWorldState(plr->GetTeam() ? WSG_ALLIANCE_FLAG_CAPTURED : WSG_HORDE_FLAG_CAPTURED, 1);
+		PlaySoundToAll( plr->GetTeam() ? SOUND_HORDE_SCORES : SOUND_ALLIANCE_SCORES );
 
+		if( plr->GetTeam() == 1 )
+			SendChatMessage( CHAT_MSG_BG_EVENT_HORDE, plr->GetGUID(), "%s captured the Alliance flag!", plr->GetName() );
+		else
+			SendChatMessage( CHAT_MSG_BG_EVENT_ALLIANCE, plr->GetGUID(), "%s captured the Horde flag!", plr->GetName() );
+
+		SetWorldState( plr->GetTeam() ? WSG_ALLIANCE_FLAG_CAPTURED : WSG_HORDE_FLAG_CAPTURED, 1 );
+
 		/* respawn the home flag */
 		m_homeFlags[plr->GetTeam()]->PushToWorld(m_mapMgr);
 
@@ -199,7 +204,10 @@
 
 	sEventMgr.AddEvent(((WarsongGulch*)m_dropFlags[plr->GetTeam()]), &WarsongGulch::ReturnFlag, plr->GetTeam(), this, EVENT_BATTLEGROND_WSG_AUTO_RETURN_FLAG, 60000, 1, 0);
 
-	SendChatMessage(CHAT_MSG_BATTLEGROUND_EVENT, plr->GetGUID(), "The %s flag was dropped by %s!", plr->GetTeam() ? "Alliance" : "Horde", plr->GetName());
+	if( plr->GetTeam() == 1 )
+		SendChatMessage( CHAT_MSG_BG_EVENT_ALLIANCE, plr->GetGUID(), "The Alliance flag was dropped by %s!", plr->GetName() );
+	else
+		SendChatMessage( CHAT_MSG_BG_EVENT_HORDE, plr->GetGUID(), "The Horde flag was dropped by %s!", plr->GetName() );
 }
 
 void WarsongGulch::HookFlagDrop(Player * plr, GameObject * obj)
@@ -220,7 +228,11 @@
 			plr->m_bgScore.Misc2++;
 			UpdatePvPData();
 
-			SendChatMessage(CHAT_MSG_BATTLEGROUND_EVENT, plr->GetGUID(), "The %s flag was returned to its base by %s!", plr->GetTeam() ? "Horde" : "Alliance", plr->GetName());
+			if( plr->GetTeam() == 1 )
+				SendChatMessage( CHAT_MSG_BG_EVENT_HORDE, plr->GetGUID(), "The Horde flag was returned to its base by %s!", plr->GetName() );
+			else
+				SendChatMessage( CHAT_MSG_BG_EVENT_ALLIANCE, plr->GetGUID(), "The Alliance flag was returned to its base by %s!", plr->GetName() );
+
 			SetWorldState(plr->GetTeam() ? WSG_ALLIANCE_FLAG_CAPTURED : WSG_HORDE_FLAG_CAPTURED, 1);
 			PlaySoundToAll(plr->GetTeam() ? SOUND_HORDE_RETURNED : SOUND_ALLIANCE_RETURNED);
 		}
@@ -251,7 +263,11 @@
 	if (ws->m_dropFlags[team]->IsInWorld())
 		ws->m_dropFlags[team]->RemoveFromWorld(false);
 	ws->m_homeFlags[team]->PushToWorld(ws->m_mapMgr);
-	ws->SendChatMessage(CHAT_MSG_BATTLEGROUND_EVENT, 0, "The %s flag was returned to its base!", team ? "Alliance" : "Horde");
+	
+	if( team )
+		ws->SendChatMessage( CHAT_MSG_BG_EVENT_ALLIANCE, 0, "The Alliance flag was returned to its base!" );
+	else
+		ws->SendChatMessage( CHAT_MSG_BG_EVENT_HORDE, 0, "The Horde flag was returned to its base!" );
 }
 
 void WarsongGulch::HookFlagStand(Player * plr, GameObject * obj)
@@ -272,7 +288,11 @@
 	m_homeFlags[plr->GetTeam()]->RemoveFromWorld(false);
 	plr->m_bgHasFlag = true;
 
-	SendChatMessage(CHAT_MSG_BATTLEGROUND_EVENT, 0, "The %s flag was picked up by %s!", plr->GetTeam() ? "Alliance" : "Horde", plr->GetName());
+	if( plr->GetTeam() == 1 )
+		SendChatMessage( CHAT_MSG_BG_EVENT_HORDE, plr->GetGUID(), "The Alliance flag was picked up by %s!", plr->GetName() );
+	else
+		SendChatMessage( CHAT_MSG_BG_EVENT_ALLIANCE, plr->GetGUID(), "The Horde flag was picked up by %s!", plr->GetName() );
+
 	PlaySoundToAll(plr->GetTeam() ? SOUND_HORDE_CAPTURE : SOUND_ALLIANCE_CAPTURE);
 	SetWorldState(plr->GetTeam() ? WSG_ALLIANCE_FLAG_CAPTURED : WSG_HORDE_FLAG_CAPTURED, 2);
 }
@@ -467,7 +487,7 @@
 	for(int i = 0; i < 2; ++i)
 		m_homeFlags[i]->PushToWorld(m_mapMgr);
 
-	SendChatMessage(CHAT_MSG_BATTLEGROUND_EVENT, 0, "The flags are now placed at their bases.");
+	SendChatMessage( CHAT_MSG_BG_EVENT_NEUTRAL, 0, "The flags are now placed at their bases." );
 
 	/* correct? - burlex */
 	PlaySoundToAll(SOUND_BATTLEGROUND_BEGIN);
Index: World.cpp
===================================================================
--- World.cpp	(revision 187)
+++ World.cpp	(working copy)
@@ -351,8 +351,8 @@
 
 	uint32 start_time = getMSTime();
 
-	Log.Notice("World", "Loading DBC files...");
-	if(!LoadDBCs())
+	Log.Notice( "World", "Loading DBC files..." );
+	if( !LoadDBCs() )
 		return false;
 
 	/*{
@@ -531,7 +531,6 @@
 	sLog.outString("");
 	LoadNameGenData();
 
-
 	//Updating spell.dbc--this is slow like hell due to we cant read string fields
 	//dbc method will be changed in future
 	DBCFile dbc;
@@ -641,6 +640,11 @@
 				if(itr == TeachingSpellMap.end())
 					TeachingSpellMap.insert(make_pair(sp->EffectTriggerSpell[b],sp->Id));
 			}
+
+			if( sp->Attributes & ATTRIBUTES_ONLY_OUTDOORS && sp->EffectApplyAuraName[b] == SPELL_AURA_MOUNTED )
+			{
+				sp->Attributes &= ~ATTRIBUTES_ONLY_OUTDOORS;
+			}
 		}
 
 		sp->proc_interval = 0;//trigger at each event
@@ -1484,10 +1488,7 @@
 				sp->procChance = itr->first;
 		}
 
-		// warlock - intensity
-		if( namehash == SPELL_HASH_INTENSITY)
-			sp->EffectSpellGroupRelation[0] |= 4 | 1 | 64 | 256 | 32 | 128 | 512; //destruction spell
-		else if(
+		if(
 			((sp->Attributes & ATTRIBUTES_TRIGGER_COOLDOWN) && (sp->AttributesEx & ATTRIBUTESEX_DELAY_SOME_TRIGGERS)) //rogue cold blood
 			|| ((sp->Attributes & ATTRIBUTES_TRIGGER_COOLDOWN) && (!sp->AttributesEx || sp->AttributesEx & ATTRIBUTESEX_REMAIN_OOC))
 			)
@@ -1568,28 +1569,91 @@
     sp = dbcSpell.LookupEntryForced( 35691 );
     if( sp != NULL )
 	{
-        sp->EffectApplyAuraName[0] = 42;
-        sp->EffectTriggerSpell[0] = 39576;
-        sp->procFlags = PROC_ON_CAST_SPELL;
+        sp->EffectApplyAuraName[0] = 13;
+		sp->EffectImplicitTargetA[0]=EFF_TARGET_SELF;
+        sp->Effect[1] = 6;
+        sp->EffectApplyAuraName[1] = 13;
+        sp->EffectBasePoints[1] = sp->EffectBasePoints[0];
+		sp->EffectImplicitTargetA[1]=EFF_TARGET_PET;
+        sp->Effect[2] = SPELL_EFFECT_TRIGGER_SPELL;
+        sp->EffectTriggerSpell[2] = 35696;
+		sp->EffectImplicitTargetA[2]=EFF_TARGET_PET;
 		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_PET_OWNER | SPELL_FLAG_IS_EXPIREING_WITH_PET;
     }
     sp = dbcSpell.LookupEntryForced( 35692 );
     if( sp != NULL )
 	{
-        sp->EffectApplyAuraName[0] = 42;
-        sp->EffectTriggerSpell[0] = 39576;
-        sp->procFlags = PROC_ON_CAST_SPELL;
+        sp->EffectApplyAuraName[0] = 13;
+		sp->EffectImplicitTargetA[0]=EFF_TARGET_SELF;
+        sp->Effect[1] = 6;
+        sp->EffectApplyAuraName[1] = 13;
+        sp->EffectBasePoints[1] = sp->EffectBasePoints[0];
+		sp->EffectImplicitTargetA[1]=EFF_TARGET_PET;
+        sp->Effect[2] = SPELL_EFFECT_TRIGGER_SPELL;
+        sp->EffectTriggerSpell[2] = 35696;
+		sp->EffectImplicitTargetA[2]=EFF_TARGET_PET;
 		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_PET_OWNER | SPELL_FLAG_IS_EXPIREING_WITH_PET;
     }
     sp = dbcSpell.LookupEntryForced( 35693 );
     if( sp != NULL )
 	{
-        sp->EffectApplyAuraName[0] = 42;
-        sp->EffectTriggerSpell[0] = 39576;
-        sp->procFlags = PROC_ON_CAST_SPELL;
+        sp->EffectApplyAuraName[0] = 13;
+		sp->EffectImplicitTargetA[0]=EFF_TARGET_SELF;
+        sp->Effect[1] = 6;
+        sp->EffectApplyAuraName[1] = 13;
+        sp->EffectBasePoints[1] = sp->EffectBasePoints[0];
+		sp->EffectImplicitTargetA[1]=EFF_TARGET_PET;
+        sp->Effect[2] = SPELL_EFFECT_TRIGGER_SPELL;
+        sp->EffectTriggerSpell[2] = 35696;
+		sp->EffectImplicitTargetA[2]=EFF_TARGET_PET;
 		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_PET_OWNER | SPELL_FLAG_IS_EXPIREING_WITH_PET;
     }
+    sp = dbcSpell.LookupEntryForced( 35696 );
+    if( sp != NULL )
+	{
+        sp->Effect[0] = 6; //making this only for the visible effect
+        sp->EffectApplyAuraName[0] = 4; //no effect here
+		sp->EffectImplicitTargetA[0]=EFF_TARGET_PET;
+	}
 
+    //Priest - Holy Nova
+    sp = dbcSpell.LookupEntry( 15237 );
+    if( sp != NULL )
+    {
+        sp->Effect[1] = 64;
+        sp->EffectTriggerSpell[1] = 23455;
+    }
+    sp = dbcSpell.LookupEntry( 15430 );
+    if( sp != NULL )
+    {
+        sp->Effect[1] = 64;
+        sp->EffectTriggerSpell[1] = 23458;
+    }
+    sp = dbcSpell.LookupEntry( 15431 );
+    if( sp != NULL )
+    {
+        sp->Effect[1] = 64;
+        sp->EffectTriggerSpell[1] = 23459;
+    }
+    sp = dbcSpell.LookupEntry( 27799 );
+    if( sp != NULL )
+    {
+        sp->Effect[1] = 64;
+        sp->EffectTriggerSpell[1] = 27803;
+    }
+    sp = dbcSpell.LookupEntry( 27800 );
+    if( sp != NULL )
+    {
+        sp->Effect[1] = 64;
+        sp->EffectTriggerSpell[1] = 27804;
+    }
+    sp = dbcSpell.LookupEntry( 27801 );
+    if( sp != NULL )
+    {
+        sp->Effect[1] = 64;
+        sp->EffectTriggerSpell[1] = 27805;
+    }
+
 	//Bloodlust targets sorounding creatures instead of us
 	sp = dbcSpell.LookupEntryForced( 2825 );
 	if( sp != NULL )
@@ -2056,7 +2120,9 @@
 	if( sp != NULL )
 	{
 		sp->EffectSpellGroupRelation[0] = 0xFFFFFFFF;//nature+fire+frost is all that shaman can do
+		sp->EffectSpellGroupRelation_high[0] = 0xFFFFFFFF;//nature+fire+frost is all that shaman can do
 		sp->EffectSpellGroupRelation[1] = 0xFFFFFFFF;//nature+fire+frost is all that shaman can do
+		sp->EffectSpellGroupRelation_high[1] = 0xFFFFFFFF;//nature+fire+frost is all that shaman can do
 	}
 
 	//Shaman - Eye of the Storm
@@ -2546,6 +2612,23 @@
 	if( sp != NULL )
 		sp->EffectSpellGroupRelation[0] = 64 | 32;	//Sprint + Evasion
 
+     //priest - Holy Concentration
+     sp = dbcSpell.LookupEntryForced( 34753 );
+     if (sp != NULL)
+          sp->procFlags = PROC_ON_CAST_SPELL;
+     sp = dbcSpell.LookupEntryForced( 34859 );
+     if (sp != NULL)
+	     sp->procFlags = PROC_ON_CAST_SPELL;
+     sp = dbcSpell.LookupEntryForced( 34860 );
+     if (sp != NULL)
+          sp->procFlags = PROC_ON_CAST_SPELL;
+     sp = dbcSpell.LookupEntryForced( 34754 );
+     if (sp != NULL)
+     {
+          //sp->EffectSpellGroupRelation[0] = 2048 | 4096;
+          sp->EffectSpellGroupRelation_high[0] = 4;
+     }
+
 	//priest - Focused Mind 
 	sp = dbcSpell.LookupEntryForced( 33213 ); 
 	if( sp != NULL )
@@ -3054,7 +3137,9 @@
 	}
 
 	//Druid: Improved Leader of the Pack
-	sp = dbcSpell.LookupEntryForced( 34299 ); if( sp != NULL ) sp->proc_interval = 6000;//6 secs
+	sp = dbcSpell.LookupEntryForced( 34299 );
+	if( sp != NULL )
+		sp->proc_interval = 6000;//6 secs
 
 	//fix for the right Enchant ID for Enchant Cloak - Major Resistance
 	sp = dbcSpell.LookupEntryForced( 27962 );
@@ -3210,35 +3295,35 @@
 	sp = dbcSpell.LookupEntryForced( 34466 );
 	if( sp != NULL )
 	{
-		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET | SPELL_FLAG_IS_EXPIREING_WITH_PET;
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
 		sp->EffectApplyAuraName[1] = SPELL_AURA_MOD_HASTE;
 		sp->EffectImplicitTargetA[1] = EFF_TARGET_PET;
 	}
 	sp = dbcSpell.LookupEntryForced( 34467 );
 	if( sp != NULL )
 	{
-		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET | SPELL_FLAG_IS_EXPIREING_WITH_PET;
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
 		sp->EffectApplyAuraName[1] = SPELL_AURA_MOD_HASTE;
 		sp->EffectImplicitTargetA[1] = EFF_TARGET_PET;
 	}
 	sp = dbcSpell.LookupEntryForced( 34468 );
 	if( sp != NULL )
 	{
-		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET | SPELL_FLAG_IS_EXPIREING_WITH_PET;
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
 		sp->EffectApplyAuraName[1] = SPELL_AURA_MOD_HASTE;
 		sp->EffectImplicitTargetA[1] = EFF_TARGET_PET;
 	}
 	sp = dbcSpell.LookupEntryForced( 34469 );
 	if( sp != NULL )
 	{
-		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET | SPELL_FLAG_IS_EXPIREING_WITH_PET;
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
 		sp->EffectApplyAuraName[1] = SPELL_AURA_MOD_HASTE;
 		sp->EffectImplicitTargetA[1] = EFF_TARGET_PET;
 	}
 	sp = dbcSpell.LookupEntryForced( 34470 );
 	if( sp != NULL )
 	{
-		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET | SPELL_FLAG_IS_EXPIREING_WITH_PET;
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
 		sp->EffectApplyAuraName[1] = SPELL_AURA_MOD_HASTE;
 		sp->EffectImplicitTargetA[1] = EFF_TARGET_PET;
 	}
@@ -3303,7 +3388,7 @@
 	sp = dbcSpell.LookupEntryForced( 19609 );
 	if( sp != NULL )
 	{
-		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_PET_OWNER | SPELL_FLAG_IS_EXPIREING_WITH_PET;
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_PET_OWNER ;
 		sp->EffectApplyAuraName[0] = SPELL_AURA_MOD_RESISTANCE; //we do not support armor rating for pets yet !
 		sp->EffectBasePoints[0] *= 10; //just give it a little juice :P
 		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
@@ -3311,7 +3396,7 @@
 	sp = dbcSpell.LookupEntryForced( 19610 );
 	if( sp != NULL )
 	{
-		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_PET_OWNER | SPELL_FLAG_IS_EXPIREING_WITH_PET;
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_PET_OWNER ;
 		sp->EffectApplyAuraName[0] = SPELL_AURA_MOD_RESISTANCE; //we do not support armor rating for pets yet !
 		sp->EffectBasePoints[0] *= 10; //just give it a little juice :P
 		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
@@ -3319,7 +3404,7 @@
 	sp = dbcSpell.LookupEntryForced( 19612 );
 	if( sp != NULL )
 	{
-		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_PET_OWNER | SPELL_FLAG_IS_EXPIREING_WITH_PET;
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_PET_OWNER ;
 		sp->EffectApplyAuraName[0] = SPELL_AURA_MOD_RESISTANCE; //we do not support armor rating for pets yet !
 		sp->EffectBasePoints[0] *= 10; //just give it a little juice :P
 		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
@@ -3375,35 +3460,35 @@
 	sp = dbcSpell.LookupEntryForced( 19583 );
 	if( sp != NULL )
 	{
-		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_PET_OWNER | SPELL_FLAG_IS_EXPIREING_WITH_PET;
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_PET_OWNER ;
 		sp->EffectApplyAuraName[0] = SPELL_AURA_MOD_INCREASE_HEALTH_PERCENT;
 		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
 	}
 	sp = dbcSpell.LookupEntryForced( 19584 );
 	if( sp != NULL )
 	{
-		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_PET_OWNER | SPELL_FLAG_IS_EXPIREING_WITH_PET;
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_PET_OWNER ;
 		sp->EffectApplyAuraName[0] = SPELL_AURA_MOD_INCREASE_HEALTH_PERCENT;
 		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
 	}
 	sp = dbcSpell.LookupEntryForced( 19585 );
 	if( sp != NULL )
 	{
-		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_PET_OWNER | SPELL_FLAG_IS_EXPIREING_WITH_PET;
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_PET_OWNER ;
 		sp->EffectApplyAuraName[0] = SPELL_AURA_MOD_INCREASE_HEALTH_PERCENT;
 		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
 	}
 	sp = dbcSpell.LookupEntryForced( 19586 );
 	if( sp != NULL )
 	{
-		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_PET_OWNER | SPELL_FLAG_IS_EXPIREING_WITH_PET;
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_PET_OWNER ;
 		sp->EffectApplyAuraName[0] = SPELL_AURA_MOD_INCREASE_HEALTH_PERCENT;
 		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
 	}
 	sp = dbcSpell.LookupEntryForced( 19587 );
 	if( sp != NULL )
 	{
-		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_PET_OWNER | SPELL_FLAG_IS_EXPIREING_WITH_PET;
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_PET_OWNER ;
 		sp->EffectApplyAuraName[0] = SPELL_AURA_MOD_INCREASE_HEALTH_PERCENT;
 		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
 	}
@@ -3771,9 +3856,9 @@
 		sp->procFlags = PROC_ON_TARGET_DIE;
 		sp->procChance = 100;
 	}
-	sp = dbcSpell.LookupEntryForced( 27285 );
-	if( sp != NULL )
-		sp->EffectImplicitTargetA[0] = EFF_TARGET_ALL_FRIENDLY_IN_AREA;
+//	sp = dbcSpell.LookupEntry( 27285 );
+//	if( sp != NULL )
+//		sp->EffectImplicitTargetA[0] = EFF_TARGET_ALL_FRIENDLY_IN_AREA;
 
 	//warlock -  soul link
 	sp = dbcSpell.LookupEntryForced( 19028 );
@@ -4028,9 +4113,9 @@
 	sp = dbcSpell.LookupEntryForced( 31583 );
 	if( sp != NULL )
 	{
-		sp->EffectSpellGroupRelation[0] = 2097152;
+		sp->EffectSpellGroupRelation[0] = 2097152; //damage
 		sp->EffectBasePoints[0] *= 5; //heh B thinks he is smart by adding this to description ? If it doesn;t work std then it still needs to made by hand
-		sp->EffectSpellGroupRelation[1] = 2048;
+		sp->EffectSpellGroupRelation[1] = 2048; //cost
 	}
 
 	//mage : Empowered Fireball
@@ -4053,10 +4138,16 @@
 	//mage : Ice Floes
 	sp = dbcSpell.LookupEntryForced( 31670 );
 	if( sp != NULL )
-		sp->EffectSpellGroupRelation[0] = 2097152;
+	{
+		sp->EffectSpellGroupRelation[0] = 512;
+		sp->EffectSpellGroupRelation_high[0] = 4 | 1;
+	}
 	sp = dbcSpell.LookupEntryForced( 31672 );
 	if( sp != NULL )
-		sp->EffectSpellGroupRelation[0] = 2097152;
+	{
+		sp->EffectSpellGroupRelation[0] = 512;
+		sp->EffectSpellGroupRelation_high[0] = 4 | 1;
+	}
 
 	//mage : Empowered Frostbolt
 	sp = dbcSpell.LookupEntryForced( 31682 );
@@ -4180,10 +4271,7 @@
 	}
 	sp = dbcSpell.LookupEntryForced( 28682 );
 	if( sp != NULL )
-	{
 		sp->EffectSpellGroupRelation[0] = 8388608 | 16 | 2 | 4 | 4194304 | 1;
-		sp->NameHash = SPELL_HASH_COMBUSTION_PROC;
-	}
 
 	//mage - Empowered Fireball
 	sp = dbcSpell.LookupEntryForced( 31656 );
@@ -4241,6 +4329,7 @@
 		sp->EffectApplyAuraName[0] = 42;
 		sp->EffectTriggerSpell[0] = 29077;
 		sp->procFlags = uint32(PROC_ON_SPELL_CRIT_HIT|PROC_TARGET_SELF);
+		sp->procChance = 100;
 	}
 	sp = dbcSpell.LookupEntryForced( 29075 );
 	if( sp != NULL )
@@ -4248,6 +4337,7 @@
 		sp->EffectApplyAuraName[0] = 42;
 		sp->EffectTriggerSpell[0] = 29077;
 		sp->procFlags = uint32(PROC_ON_SPELL_CRIT_HIT|PROC_TARGET_SELF);
+		sp->procChance = 100;
 	}
 	sp = dbcSpell.LookupEntryForced( 29076 );
 	if( sp != NULL )
@@ -4255,6 +4345,7 @@
 		sp->EffectApplyAuraName[0] = 42;
 		sp->EffectTriggerSpell[0] = 29077;
 		sp->procFlags = uint32(PROC_ON_SPELL_CRIT_HIT|PROC_TARGET_SELF);
+		sp->procChance = 100;
 	}
 
 	//mage: Blazing Speed
@@ -4280,6 +4371,14 @@
 	if( sp != NULL )
 		sp->Effect[1]=80;
 
+	//warlock - Improved Curse of Weakness
+	sp = dbcSpell.LookupEntryForced( 18179 );
+	if( sp != NULL )
+		sp->EffectSpellGroupRelation[0] = 32768;
+	sp = dbcSpell.LookupEntryForced( 18180 );
+	if( sp != NULL )
+		sp->EffectSpellGroupRelation[0] = 32768;
+
 	//warlock - Amplify Curse
 	sp = dbcSpell.LookupEntryForced( 18288 );
 	if( sp != NULL )
@@ -4372,6 +4471,66 @@
 		sp->EffectSpellGroupRelation_high[1] = 128 | 4096 ;
 	}
 
+	//warlock - Cataclysm 
+	sp = dbcSpell.LookupEntryForced( 17778 );
+	if( sp != NULL )
+	{
+		sp->EffectSpellGroupRelation[0] = 1 | 4 | 32 | 64 | 128 | 256 | 512 ;
+		sp->EffectSpellGroupRelation_high[0] = 128 | 4096 ;
+		sp->EffectSpellGroupRelation[1] = 1 | 4 | 32 | 64 | 128 | 256 | 512 ;
+		sp->EffectSpellGroupRelation_high[1] = 128 | 4096 ;
+	}
+	sp = dbcSpell.LookupEntryForced( 17779 );
+	if( sp != NULL )
+	{
+		sp->EffectSpellGroupRelation[0] = 1 | 4 | 32 | 64 | 128 | 256 | 512 ;
+		sp->EffectSpellGroupRelation_high[0] = 128 | 4096 ;
+		sp->EffectSpellGroupRelation[1] = 1 | 4 | 32 | 64 | 128 | 256 | 512 ;
+		sp->EffectSpellGroupRelation_high[1] = 128 | 4096 ;
+	}
+	sp = dbcSpell.LookupEntryForced( 17780 );
+	if( sp != NULL )
+	{
+		sp->EffectSpellGroupRelation[0] = 1 | 4 | 32 | 64 | 128 | 256 | 512 ;
+		sp->EffectSpellGroupRelation_high[0] = 128 | 4096 ;
+		sp->EffectSpellGroupRelation[1] = 1 | 4 | 32 | 64 | 128 | 256 | 512 ;
+		sp->EffectSpellGroupRelation_high[1] = 128 | 4096 ;
+	}
+	sp = dbcSpell.LookupEntryForced( 17781 );
+	if( sp != NULL )
+	{
+		sp->EffectSpellGroupRelation[0] = 1 | 4 | 32 | 64 | 128 | 256 | 512 ;
+		sp->EffectSpellGroupRelation_high[0] = 128 | 4096 ;
+		sp->EffectSpellGroupRelation[1] = 1 | 4 | 32 | 64 | 128 | 256 | 512 ;
+		sp->EffectSpellGroupRelation_high[1] = 128 | 4096 ;
+	}
+	sp = dbcSpell.LookupEntryForced( 17782 );
+	if( sp != NULL )
+	{
+		sp->EffectSpellGroupRelation[0] = 1 | 4 | 32 | 64 | 128 | 256 | 512 ;
+		sp->EffectSpellGroupRelation_high[0] = 128 | 4096 ;
+		sp->EffectSpellGroupRelation[1] = 1 | 4 | 32 | 64 | 128 | 256 | 512 ;
+		sp->EffectSpellGroupRelation_high[1] = 128 | 4096 ;
+	}
+
+	//warlock - Intensity 
+	sp = dbcSpell.LookupEntryForced( 18135 );
+	if( sp != NULL )
+	{
+		sp->EffectSpellGroupRelation[0] = 1 | 4 | 32 | 64 | 128 | 256 | 512 ;
+		sp->EffectSpellGroupRelation_high[0] = 128 | 4096 ;
+		sp->EffectSpellGroupRelation[1] = 1 | 4 | 32 | 64 | 128 | 256 | 512 ;
+		sp->EffectSpellGroupRelation_high[1] = 128 | 4096 ;
+	}
+	sp = dbcSpell.LookupEntryForced( 18136 );
+	if( sp != NULL )
+	{
+		sp->EffectSpellGroupRelation[0] = 1 | 4 | 32 | 64 | 128 | 256 | 512 ;
+		sp->EffectSpellGroupRelation_high[0] = 128 | 4096 ;
+		sp->EffectSpellGroupRelation[1] = 1 | 4 | 32 | 64 | 128 | 256 | 512 ;
+		sp->EffectSpellGroupRelation_high[1] = 128 | 4096 ;
+	}
+
 	//warlock - Suppression
 	sp = dbcSpell.LookupEntryForced( 18174 );
 	if( sp != NULL )
@@ -4405,19 +4564,226 @@
 	if( sp != NULL )
 		sp->EffectSpellGroupRelation[0] = 2 | 8 | 32768 | 2147483648UL | 1024 | 16384 | 262144 | 16 | 524288 | 4194304;
 
-
 	//warlock - Demonic Sacrifice
-	sp = dbcSpell.LookupEntryForced( 18788 );
+	sp = dbcSpell.LookupEntryForced( 18789 );
 	if( sp != NULL )
+		sp->c_is_flags |= SPELL_FLAG_IS_EXPIREING_ON_PET;
+	sp = dbcSpell.LookupEntryForced( 18790 );
+	if( sp != NULL )
+		sp->c_is_flags |= SPELL_FLAG_IS_EXPIREING_ON_PET;
+	sp = dbcSpell.LookupEntryForced( 18791 );
+	if( sp != NULL )
+		sp->c_is_flags |= SPELL_FLAG_IS_EXPIREING_ON_PET;
+	sp = dbcSpell.LookupEntryForced( 18792 );
+	if( sp != NULL )
+		sp->c_is_flags |= SPELL_FLAG_IS_EXPIREING_ON_PET;
+	sp = dbcSpell.LookupEntryForced( 35701 );
+	if( sp != NULL )
+		sp->c_is_flags |= SPELL_FLAG_IS_EXPIREING_ON_PET;
+	
+
+	//warlock - Improved Imp
+	sp = dbcSpell.LookupEntryForced( 18694 );
+	if( sp != NULL )
 	{
-		sp->Effect[1] = SPELL_EFFECT_TRIGGER_SPELL;
-		sp->EffectTriggerSpell[1] = 18789;
-		sp->EffectImplicitTargetA[1] = EFF_TARGET_SELF;
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
 	}
-	sp = dbcSpell.LookupEntryForced( 18788 );
+	sp = dbcSpell.LookupEntryForced( 18695 );
 	if( sp != NULL )
-		sp->c_is_flags |= SPELL_FLAG_IS_EXPIREING_ON_PET;
+	{
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
+	}
+	sp = dbcSpell.LookupEntryForced( 18696 );
+	if( sp != NULL )
+	{
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
+	}
 
+	//warlock - Improved Voidwalker
+	sp = dbcSpell.LookupEntryForced( 18705 );
+	if( sp != NULL )
+	{
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
+	}
+	sp = dbcSpell.LookupEntryForced( 18706 );
+	if( sp != NULL )
+	{
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
+	}
+	sp = dbcSpell.LookupEntryForced( 18707 );
+	if( sp != NULL )
+	{
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
+	}
+
+	//warlock - Improved Succubus
+	sp = dbcSpell.LookupEntryForced( 18754 );
+	if( sp != NULL )
+	{
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
+		sp->EffectImplicitTargetA[1] = EFF_TARGET_PET;
+	}
+	sp = dbcSpell.LookupEntryForced( 18755 );
+	if( sp != NULL )
+	{
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
+		sp->EffectImplicitTargetA[1] = EFF_TARGET_PET;
+	}
+	sp = dbcSpell.LookupEntryForced( 18756 );
+	if( sp != NULL )
+	{
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
+		sp->EffectImplicitTargetA[1] = EFF_TARGET_PET;
+	}
+
+	//warlock - Fel Intellect
+	sp = dbcSpell.LookupEntryForced( 18731 );
+	if( sp != NULL )
+	{
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
+		sp->EffectApplyAuraName[0] = SPELL_AURA_MOD_PERCENT_STAT;
+		sp->EffectMiscValue[0] = 3;
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
+	}
+	sp = dbcSpell.LookupEntryForced( 18743 );
+	if( sp != NULL )
+	{
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
+		sp->EffectApplyAuraName[0] = SPELL_AURA_MOD_PERCENT_STAT;
+		sp->EffectMiscValue[0] = 3;
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
+	}
+	sp = dbcSpell.LookupEntryForced( 18744 );
+	if( sp != NULL )
+	{
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
+		sp->EffectApplyAuraName[0] = SPELL_AURA_MOD_PERCENT_STAT;
+		sp->EffectMiscValue[0] = 3;
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
+	}
+
+	//warlock - Fel Stamina
+	sp = dbcSpell.LookupEntryForced( 18748 );
+	if( sp != NULL )
+	{
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
+		sp->EffectApplyAuraName[0] = SPELL_AURA_MOD_PERCENT_STAT;
+		sp->EffectMiscValue[0] = 2;
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
+	}
+	sp = dbcSpell.LookupEntryForced( 18749 );
+	if( sp != NULL )
+	{
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
+		sp->EffectApplyAuraName[0] = SPELL_AURA_MOD_PERCENT_STAT;
+		sp->EffectMiscValue[0] = 2;
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
+	}
+	sp = dbcSpell.LookupEntryForced( 18750 );
+	if( sp != NULL )
+	{
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
+		sp->EffectApplyAuraName[0] = SPELL_AURA_MOD_PERCENT_STAT;
+		sp->EffectMiscValue[0] = 2;
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
+	}
+
+	//warlock - Demonic Tactics
+	sp = dbcSpell.LookupEntryForced( 30242 );
+	if( sp != NULL )
+	{
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
+		sp->EffectApplyAuraName[0] = SPELL_AURA_ADD_PCT_MODIFIER;
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
+		//this is required since blizz uses spells for melee attacks while we use fixed functions
+		sp->Effect[1] = SPELL_EFFECT_APPLY_AURA;
+		sp->EffectApplyAuraName[1] = SPELL_AURA_MOD_DAMAGE_PERCENT_DONE;
+		sp->EffectImplicitTargetA[1] = EFF_TARGET_PET;
+		sp->EffectMiscValue[1] = SCHOOL_NORMAL;
+		sp->EffectBasePoints[1] = sp->EffectBasePoints[0] ;
+	}
+
+	//warlock - Unholy Power
+	sp = dbcSpell.LookupEntryForced( 18769 );
+	if( sp != NULL )
+	{
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
+		sp->EffectApplyAuraName[0] = SPELL_AURA_ADD_PCT_MODIFIER;
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
+		sp->EffectSpellGroupRelation[0] = 4096;
+		//this is required since blizz uses spells for melee attacks while we use fixed functions
+		sp->Effect[1] = SPELL_EFFECT_APPLY_AURA;
+		sp->EffectApplyAuraName[1] = SPELL_AURA_MOD_DAMAGE_PERCENT_DONE;
+		sp->EffectImplicitTargetA[1] = EFF_TARGET_PET;
+		sp->EffectMiscValue[1] = SCHOOL_NORMAL;
+		sp->EffectBasePoints[1] = sp->EffectBasePoints[0] ;
+	}
+	sp = dbcSpell.LookupEntryForced( 18770 );
+	if( sp != NULL )
+	{
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
+		sp->EffectApplyAuraName[0] = SPELL_AURA_ADD_PCT_MODIFIER;
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
+		sp->EffectSpellGroupRelation[0] = 4096;
+		//this is required since blizz uses spells for melee attacks while we use fixed functions
+		sp->Effect[1] = SPELL_EFFECT_APPLY_AURA;
+		sp->EffectApplyAuraName[1] = SPELL_AURA_MOD_DAMAGE_PERCENT_DONE;
+		sp->EffectImplicitTargetA[1] = EFF_TARGET_PET;
+		sp->EffectMiscValue[1] = SCHOOL_NORMAL;
+		sp->EffectBasePoints[1] = sp->EffectBasePoints[0] ;
+	}
+	sp = dbcSpell.LookupEntryForced( 18771 );
+	if( sp != NULL )
+	{
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
+		sp->EffectApplyAuraName[0] = SPELL_AURA_ADD_PCT_MODIFIER;
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
+		sp->EffectSpellGroupRelation[0] = 4096;
+		//this is required since blizz uses spells for melee attacks while we use fixed functions
+		sp->Effect[1] = SPELL_EFFECT_APPLY_AURA;
+		sp->EffectApplyAuraName[1] = SPELL_AURA_MOD_DAMAGE_PERCENT_DONE;
+		sp->EffectImplicitTargetA[1] = EFF_TARGET_PET;
+		sp->EffectMiscValue[1] = SCHOOL_NORMAL;
+		sp->EffectBasePoints[1] = sp->EffectBasePoints[0] ;
+	}
+	sp = dbcSpell.LookupEntryForced( 18772 );
+	if( sp != NULL )
+	{
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
+		sp->EffectApplyAuraName[0] = SPELL_AURA_ADD_PCT_MODIFIER;
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
+		sp->EffectSpellGroupRelation[0] = 4096;
+		//this is required since blizz uses spells for melee attacks while we use fixed functions
+		sp->Effect[1] = SPELL_EFFECT_APPLY_AURA;
+		sp->EffectApplyAuraName[1] = SPELL_AURA_MOD_DAMAGE_PERCENT_DONE;
+		sp->EffectImplicitTargetA[1] = EFF_TARGET_PET;
+		sp->EffectMiscValue[1] = SCHOOL_NORMAL;
+		sp->EffectBasePoints[1] = sp->EffectBasePoints[0] ;
+	}
+	sp = dbcSpell.LookupEntryForced( 18773 );
+	if( sp != NULL )
+	{
+		sp->c_is_flags |= SPELL_FLAG_IS_CASTED_ON_PET_SUMMON_ON_PET ;
+		sp->EffectApplyAuraName[0] = SPELL_AURA_ADD_PCT_MODIFIER;
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
+		sp->EffectSpellGroupRelation[0] = 4096;
+		//this is required since blizz uses spells for melee attacks while we use fixed functions
+		sp->Effect[1] = SPELL_EFFECT_APPLY_AURA;
+		sp->EffectApplyAuraName[1] = SPELL_AURA_MOD_DAMAGE_PERCENT_DONE;
+		sp->EffectImplicitTargetA[1] = EFF_TARGET_PET;
+		sp->EffectMiscValue[1] = SCHOOL_NORMAL;
+		sp->EffectBasePoints[1] = sp->EffectBasePoints[0] ;
+	}
+
 	//warlock - Master Demonologist - 25 spells here
 	sp = dbcSpell.LookupEntryForced( 23785 );
 	if( sp != NULL )
@@ -4455,6 +4821,21 @@
 		sp->EffectTriggerSpell[0] = 35708;
 	}
 	//and the rest
+	sp = dbcSpell.LookupEntryForced( 23784 );
+	if( sp != NULL )
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
+	sp = dbcSpell.LookupEntryForced( 23830 );
+	if( sp != NULL )
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
+	sp = dbcSpell.LookupEntryForced( 23831 );
+	if( sp != NULL )
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
+	sp = dbcSpell.LookupEntryForced( 23832 );
+	if( sp != NULL )
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
+	sp = dbcSpell.LookupEntryForced( 35708 );
+	if( sp != NULL )
+		sp->EffectImplicitTargetA[0] = EFF_TARGET_PET;
 	sp = dbcSpell.LookupEntryForced( 23759 );
 	if( sp != NULL )
 	{
@@ -4721,7 +5102,7 @@
 	{
 		sp->Effect[0] = 0; //delete this owerride effect :P
 		sp->EffectTriggerSpell[1] = 18093; //trigger spell was wrong :P
-		sp->procFlags = PROC_ON_CAST_SPELL;
+		sp->procFlags = PROC_ON_SPELL_LAND;
 		sp->procChance = 13; //god, save us from fixed values !
 	}
 	sp = dbcSpell.LookupEntryForced( 18096 );
@@ -4729,7 +5110,7 @@
 	{
 		sp->Effect[0] = 0; //delete this owerride effect :P
 		sp->EffectTriggerSpell[1] = 18093; //trigger spell was wrong :P
-		sp->procFlags = PROC_ON_CAST_SPELL;
+		sp->procFlags = PROC_ON_SPELL_LAND;
 		sp->procChance = 26; //god, save us from fixed values !
 	}
 
@@ -5157,12 +5538,6 @@
 		sp->procFlags = PROC_ON_MELEE_ATTACK | PROC_TARGET_SELF;
 		sp->EffectTriggerSpell[0] = sp->EffectTriggerSpell[1];
 	}
-	sp = dbcSpell.LookupEntryForced( 30031 );
-	if( sp != NULL )
-		sp->NameHash = SPELL_HASH_RAMPAGE_PROC;
-	sp = dbcSpell.LookupEntryForced( 30032 );
-	if( sp != NULL )
-		sp->NameHash = SPELL_HASH_RAMPAGE_PROC;
 
 	//warrior - Unbridled Wrath
 	sp = dbcSpell.LookupEntryForced( 12322 );
@@ -5219,30 +5594,40 @@
 	{
 		sp->EffectSpellGroupRelation[0] = 65536 | 131072;
 		sp->EffectSpellGroupRelation_high[0] = 128;
+		sp->EffectSpellGroupRelation[1] = 65536 | 131072;
+		sp->EffectSpellGroupRelation_high[1] = 128;
 	}
 	sp = dbcSpell.LookupEntryForced( 12835 );
 	if( sp != NULL )
 	{
 		sp->EffectSpellGroupRelation[0] = 65536 | 131072;
 		sp->EffectSpellGroupRelation_high[0] = 128;
+		sp->EffectSpellGroupRelation[1] = 65536 | 131072;
+		sp->EffectSpellGroupRelation_high[1] = 128;
 	}
 	sp = dbcSpell.LookupEntryForced( 12836 );
 	if( sp != NULL )
 	{
 		sp->EffectSpellGroupRelation[0] = 65536 | 131072;
 		sp->EffectSpellGroupRelation_high[0] = 128;
+		sp->EffectSpellGroupRelation[1] = 65536 | 131072;
+		sp->EffectSpellGroupRelation_high[1] = 128;
 	}
 	sp = dbcSpell.LookupEntryForced( 12837 );
 	if( sp != NULL )
 	{
 		sp->EffectSpellGroupRelation[0] = 65536 | 131072;
 		sp->EffectSpellGroupRelation_high[0] = 128;
+		sp->EffectSpellGroupRelation[1] = 65536 | 131072;
+		sp->EffectSpellGroupRelation_high[1] = 128;
 	}
 	sp = dbcSpell.LookupEntryForced( 12838 );
 	if( sp != NULL )
 	{
 		sp->EffectSpellGroupRelation[0] = 65536 | 131072;
 		sp->EffectSpellGroupRelation_high[0] = 128;
+		sp->EffectSpellGroupRelation[1] = 65536 | 131072;
+		sp->EffectSpellGroupRelation_high[1] = 128;
 	}
 
 	//warrior - Improved Intercept
@@ -5309,7 +5694,7 @@
 	//warrior - Improved Commanding Shout
 	sp = dbcSpell.LookupEntryForced( 38408 );
 	if( sp != NULL )
-		sp->EffectSpellGroupRelation[0] = 1048576;
+		sp->EffectSpellGroupRelation_high[0] = 128;
 
 	// priest - Reflective Shield
 	sp = dbcSpell.LookupEntryForced( 33201 );
@@ -6429,6 +6814,67 @@
 	ThreadPool.ExecuteTask(dw);
 	ThreadPool.ExecuteTask(new CharacterLoaderThread());
 
+	// Preload and compile talent and talent tab data to speed up talent inspect
+
+	uint32 talent_max_rank;
+	uint32 talent_pos;
+	uint32 talent_class;
+
+    for( uint32 i = 0; i < dbcTalent.GetNumRows(); ++i )
+    {
+        TalentEntry const* talent_info = dbcTalent.LookupRow( i );
+		if( talent_info == NULL )
+			continue;
+
+		TalentTabEntry const* tab_info = dbcTalentTab.LookupEntry( talent_info->TalentTree );
+		if( tab_info == NULL )
+			continue;
+
+        talent_max_rank = 0;
+        for( uint32 j = 5; j > 0; --j )
+        {
+            if( talent_info->RankID[j - 1] )
+            {
+                talent_max_rank = j;
+                break;
+            }
+		}
+
+		InspectTalentTabBit[( talent_info->Row << 24 ) + ( talent_info->Col << 16 ) + talent_info->TalentID] = talent_max_rank;
+		InspectTalentTabSize[talent_info->TalentTree] += talent_max_rank;
+	}
+
+	for( uint32 i = 1; i < dbcTalentTab.GetNumRows(); ++i )
+	{
+		TalentTabEntry const* tab_info = dbcTalentTab.LookupRow( i );
+		if( tab_info == NULL )
+			continue;
+
+		talent_pos = 0;
+        
+		for( talent_class = 0; talent_class < 12; ++talent_class )
+		{
+			if( tab_info->ClassMask & ( 1 << talent_class ) )
+				break;
+		}
+
+		InspectTalentTabPages[talent_class + 1][tab_info->TabPage] = tab_info->TalentTabID;
+
+		for( std::map< uint32, uint32 >::iterator itr = InspectTalentTabBit.begin(); itr != InspectTalentTabBit.end(); ++itr )
+		{
+			uint32 talent_id = itr->first & 0xFFFF;
+			TalentEntry const* talent_info = dbcTalent.LookupEntry( talent_id );
+			if( talent_info == NULL )
+				continue;
+
+			if( talent_info->TalentTree != tab_info->TalentTabID )
+				continue;
+
+			InspectTalentTabPos[talent_id] = talent_pos;
+			talent_pos += itr->second;
+		}
+	}
+
 	sEventMgr.AddEvent(this, &World::CheckForExpiredInstances, EVENT_WORLD_UPDATEAUCTIONS, 120000, 0, 0);
 	return true;
 }
@@ -6498,6 +6944,25 @@
 	m_sessionlock.ReleaseReadLock();
 }
 
+void World::SendInstanceMessage(WorldPacket *packet, uint32 instanceid, WorldSession *self)
+{
+	m_sessionlock.AcquireReadLock();
+
+	SessionMap::iterator itr;
+	for (itr = m_sessions.begin(); itr != m_sessions.end(); itr++)
+	{
+		if (itr->second->GetPlayer() &&
+			itr->second->GetPlayer()->IsInWorld()
+			&& itr->second != self)  // dont send to self!
+		{
+			if (itr->second->GetPlayer()->GetInstanceID() == instanceid)
+				itr->second->SendPacket(packet);
+		}
+	}
+
+	m_sessionlock.ReleaseReadLock();
+}
+
 void World::SendWorldText(const char* text, WorldSession *self)
 {
     uint32 textLen = (uint32)strlen((char*)text) + 1;
@@ -7042,6 +7507,18 @@
 		if(log_enabled)
 			GMCommand_Log->Open();
 
+	log_enabled = Config.MainConfig.GetBoolDefault("Log", "Player", false);
+	if(Player_Log->IsOpen())
+	{
+		if(!log_enabled)
+			Player_Log->Close();
+	}
+	else
+	{
+		if(log_enabled)
+			Player_Log->Open();
+	}
+
 #ifdef WIN32
 	DWORD current_priority_class = GetPriorityClass( GetCurrentProcess() );
 	bool high = Config.MainConfig.GetBoolDefault( "Server", "AdjustPriority", false );
Index: World.h
===================================================================
--- World.h	(revision 187)
+++ World.h	(working copy)
@@ -413,6 +413,7 @@
 	void SendWorldWideScreenText(const char *text, WorldSession *self = 0);
 	void SendGlobalMessage(WorldPacket *packet, WorldSession *self = 0);
 	void SendZoneMessage(WorldPacket *packet, uint32 zoneid, WorldSession *self = 0);
+	void SendInstanceMessage(WorldPacket *packet, uint32 instanceid, WorldSession *self = 0);
 	void SendFactionMessage(WorldPacket *packet, uint8 teamId);
 
 	ASCENT_INLINE void SetStartTime(uint32 val) { m_StartTime = val; }
@@ -478,6 +479,12 @@
 		int_rates[index] = value;
 	}
 
+	// talent inspection lookup tables
+	std::map< uint32, uint32 > InspectTalentTabPos;
+	std::map< uint32, uint32 > InspectTalentTabSize;
+	std::map< uint32, uint32 > InspectTalentTabBit;
+	uint32 InspectTalentTabPages[12][3];
+
 	// map text emote to spell prices
 	typedef std::map< uint32, uint32> SpellPricesMap;
 	SpellPricesMap mPrices;
Index: WorldRunnable.cpp
===================================================================
--- WorldRunnable.cpp	(revision 187)
+++ WorldRunnable.cpp	(working copy)
@@ -26,7 +26,7 @@
 
 WorldRunnable::WorldRunnable() : CThread()
 {
-	ThreadType = THREADTYPE_WORLDRUNNABLE;
+
 }
 
 bool WorldRunnable::run()
Index: WorldSession.cpp
===================================================================
--- WorldSession.cpp	(revision 187)
+++ WorldSession.cpp	(working copy)
@@ -214,12 +214,15 @@
 		}
 
 		// ping timeout!
-		Disconnect();
-		bDeleted = true;
-		LogoutPlayer(true);
+		if( _socket != NULL )
+		{
+			Disconnect();
+			_socket = NULL;
+		}
 
-		// 1 - Complete deletion
-		return 1;
+		m_lastPing = (uint32)UNIXTIME;		// Prevent calling this code over and over.
+		if(!_logoutTime)
+			_logoutTime = m_currMsTime + PLAYER_LOGOUT_DELAY;
 	}
 
 	return 0;
@@ -228,12 +231,14 @@
 
 void WorldSession::LogoutPlayer(bool Save)
 {
+	Player *pPlayer = GetPlayer();
 	if(_loggingOut)
 		return;
 
 	_loggingOut = true;
 	if (_player)
 	{
+		sHookInterface.OnLogout(pPlayer);
 		if(_player->DuelingWith)
 			_player->EndDuel(DUEL_WINNER_RETREAT);
 
@@ -384,7 +389,7 @@
 	WorldPacket data(13);
 	data.SetOpcode(SMSG_BUY_FAILED);
 	data << guid << itemid << error;
-	_socket->SendPacket(&data);
+	SendPacket(&data);
 }
 
 void WorldSession::SendSellItem(uint64 vendorguid, uint64 itemid, uint8 error)
@@ -392,7 +397,7 @@
 	WorldPacket data(17);
 	data.SetOpcode(SMSG_SELL_ITEM);
 	data << vendorguid << itemid << error;
-	_socket->SendPacket(&data);
+	SendPacket(&data);
 }
 
 void WorldSession::LoadSecurity(std::string securitystring)
@@ -872,6 +877,7 @@
 	WorldPacketHandlers[CMSG_ARENA_TEAM_REMOVE_PLAYER].handler = &WorldSession::HandleArenaTeamRemoveMemberOpcode;
 	WorldPacketHandlers[CMSG_ARENA_TEAM_DISBAND].handler = &WorldSession::HandleArenaTeamDisbandOpcode;
 	WorldPacketHandlers[CMSG_ARENA_TEAM_PROMOTE].handler = &WorldSession::HandleArenaTeamPromoteOpcode;
+	WorldPacketHandlers[MSG_INSPECT_ARENA_STATS].handler = &WorldSession::HandleInspectArenaStatsOpcode;
 
 #ifdef CLUSTERING
 	WorldPacketHandlers[CMSG_PING].handler = &WorldSession::HandlePingOpcode;
Index: WorldSession.h
===================================================================
--- WorldSession.h	(revision 187)
+++ WorldSession.h	(working copy)
@@ -643,6 +643,7 @@
 	void HandleArenaTeamPromoteOpcode(WorldPacket & recv_data);
 	void HandleArenaTeamQueryOpcode(WorldPacket & recv_data);
 	void HandleArenaTeamRosterOpcode(WorldPacket & recv_data);
+	void HandleInspectArenaStatsOpcode(WorldPacket & recv_data);
 
 	void HandleTeleportCheatOpcode(WorldPacket & recv_data);
 	void HandleTeleportToUnitOpcode(WorldPacket & recv_data);
